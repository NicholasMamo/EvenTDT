

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta content="The Automatic Term Extraction (ATE) library" name="description" />
<meta content="Python, TDT, ATE" name="keywords" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>11. Automatic Term Extraction (ATE) &mdash; EvenTDT 0.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="12. Other" href="other.html" />
    <link rel="prev" title="10. Machine Learning" href="ml.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> EvenTDT
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="config.html">0. Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="tools.html">1. Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="vsm.html">2. Vector Space Model (VSM)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nlp.html">3. Natural Language Processing (NLP)</a></li>
<li class="toctree-l1"><a class="reference internal" href="wikinterface.html">4. Wikinterface</a></li>
<li class="toctree-l1"><a class="reference internal" href="apd.html">5. Automatic Participant Detection (APD)</a></li>
<li class="toctree-l1"><a class="reference internal" href="tdt.html">6. Topic Detection and Tracking (TDT)</a></li>
<li class="toctree-l1"><a class="reference internal" href="summarization.html">7. Summarization</a></li>
<li class="toctree-l1"><a class="reference internal" href="twitter.html">8. Twitter</a></li>
<li class="toctree-l1"><a class="reference internal" href="consumers.html">9. Consumers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ml.html">10. Machine Learning</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">11. Automatic Term Extraction (ATE)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-ate.extractor">Extractor</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-ate.linguistic">Linguistic</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-ate.stat">Statistical</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#algorithms">Algorithms</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#module-ate.stat.tf">Term Frequency</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-ate.stat.tfidf">Term Frequency-Inverse Document Frequency</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-ate.stat.probability">Probability</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-ate.stat.corpus">Corpus Comparison</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#module-ate.stat.corpus.tfdcf">TF-DCF</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-ate.application">Application</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-ate.application.event">Events</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#event-frequency-ef">Event Frequency (EF)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#logarithmic-event-frequency-ef">Logarithmic Event Frequency (EF)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#event-frequency-inverse-document-frequency-ef-idf">Event Frequency-Inverse Document Frequency (EF-IDF)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#variability">Variability</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-ate.bootstrapping">Bootstrapping</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id1">Probability</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#module-ate.bootstrapping.probability.pmi">Pointwise Mutual Information (PMI)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-ate.bootstrapping.probability.chi">Chi-Square</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="other.html">12. Other</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">EvenTDT</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>11. Automatic Term Extraction (ATE)</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/ate.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="automatic-term-extraction-ate">
<h1>11. Automatic Term Extraction (ATE)<a class="headerlink" href="#automatic-term-extraction-ate" title="Permalink to this headline">¶</a></h1>
<p>Automatic Term Extraction (ATE) is a research that automatically extracts domain-specific terms.
The package includes algorithms that extract terms and bootstrap terms from a seed set.
These algorithms are both those that are popular as baselines and peer-reviewed algorithms.
Included are general functions that are likely to be useful for all algorithms.</p>
<span class="target" id="module-ate"></span><p>The ATE package includes functions and classes that are likely to be useful to all approaches.</p>
<dl class="function">
<dt id="ate.total_documents">
<code class="sig-name descname">total_documents</code><span class="sig-paren">(</span><em class="sig-param">corpora</em>, <em class="sig-param">focus=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.total_documents" title="Permalink to this definition">¶</a></dt>
<dd><p>Count the total number of documents in the given corpora.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>corpora</strong> (<em>str</em><em> or </em><em>list of str</em>) – <p>A corpus, or corpora, of documents.
If a string is given, it is assumed to be one corpus.
If a list is given, it is assumed to be a list of corpora.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is assumed that the corpora were extracted using the tokenizer tool.
Therefore each line should be a JSON string representing a document.
Each document should have a <cite>tokens</cite> attribute.</p>
</div>
</p></li>
<li><p><strong>focus</strong> (<em>None</em><em> or </em><em>str</em><em> or </em><em>list of str</em><em> or </em><em>tuple</em><em> or </em><em>list of tuple</em>) – <p>The tokens for which to compute the document frequency.
If nothing is given, the document frequency is calculated for all tokens.
The tokens can be provided as:</p>
<ul>
<li><p>A single word,</p></li>
<li><p>A list of tokens,</p></li>
<li><p>A tuple, or</p></li>
<li><p>A list of tuples.</p></li>
</ul>
<p>A tuple can be used to compute joint frequencies.</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The number of documents in the given corpora.
If one token or one tuple is given, the number of documents in which the token or tuple appears are returned.
If multiple tokens or tuples are given, a dictionary is given with the separate counts.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>int or dict</p>
</dd>
</dl>
</dd></dl>

<div class="section" id="module-ate.extractor">
<span id="extractor"></span><h2>Extractor<a class="headerlink" href="#module-ate.extractor" title="Permalink to this headline">¶</a></h2>
<p>The extractor outlines the functionality that all ATE approaches should offer.
The abstract class is very simple.
It requires only that all extractors must provide functionality to extract terms from a corpus or corpora.</p>
<dl class="class">
<dt id="ate.extractor.Extractor">
<em class="property">class </em><code class="sig-name descname">Extractor</code><a class="headerlink" href="#ate.extractor.Extractor" title="Permalink to this definition">¶</a></dt>
<dd><p>An abstract class that defines what all ATE extractors should be able to do.
This simple class necessitates only that all extractors accept a corpus or corpora and returns a list of terms.</p>
<dl class="method">
<dt id="ate.extractor.Extractor.extract">
<em class="property">abstract </em><code class="sig-name descname">extract</code><span class="sig-paren">(</span><em class="sig-param">corpora</em>, <em class="sig-param">candidates=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.extractor.Extractor.extract" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract terms from the given corpora.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>corpora</strong> (<em>str</em><em> or </em><em>list of str</em>) – A path to a corpus or a list of paths to corpora where to look for terms.
The basic extractor does not place any restrictions of the corpora.
Linguistic or hybrid approaches might need the original text to be available in the corpora.
For statistical approaches, a tokenized corpus might suffice.</p></li>
<li><p><strong>candidates</strong> (<em>None</em><em> or </em><em>list of str</em>) – A list of terms which may be extracted.
This is useful when calculating scores takes a long time and the list of candidate terms are known in advance.
If <cite>None</cite> is given, all words are considered to be candidates.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A dictionary with terms as keys and their scores as values.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ate.extractor.Extractor.to_list">
<code class="sig-name descname">to_list</code><span class="sig-paren">(</span><em class="sig-param">corpora</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.extractor.Extractor.to_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the given corpora to a list of corpora.
This function can be invoked when the input is either a list or a single path.
If a list of corpora is provided, this function returns the original input.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>corpora</strong> (<em>str</em><em> or </em><em>list of str</em>) – A path to a corpus or paths to corpora.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A list of corpora.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list of str</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="ate.extractor.Extractor.__weakref__">
<code class="sig-name descname">__weakref__</code><a class="headerlink" href="#ate.extractor.Extractor.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ate.extractor.DummyExtractor">
<em class="property">class </em><code class="sig-name descname">DummyExtractor</code><a class="headerlink" href="#ate.extractor.DummyExtractor" title="Permalink to this definition">¶</a></dt>
<dd><p>A dummy extractor that does nothing and returns an empty dictionary of terms.
It is used only for testing purposes.</p>
<dl class="method">
<dt id="ate.extractor.DummyExtractor.extract">
<code class="sig-name descname">extract</code><span class="sig-paren">(</span><em class="sig-param">corpora</em>, <em class="sig-param">candidates=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.extractor.DummyExtractor.extract" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an empty list of terms.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>corpora</strong> (<em>str</em><em> or </em><em>list of str</em>) – A path to a corpus or a list of paths to corpora where to look for terms.</p></li>
<li><p><strong>candidates</strong> (<em>None</em><em> or </em><em>list of str</em>) – A list of terms which may be extracted.
This is useful when calculating scores takes a long time and the list of candidate terms are known in advance.
If <cite>None</cite> is given, all words are considered to be candidates.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An empty list of terms.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-ate.linguistic">
<span id="linguistic"></span><h2>Linguistic<a class="headerlink" href="#module-ate.linguistic" title="Permalink to this headline">¶</a></h2>
<p>Linguistic approaches are those ATE algorithms that primarily use linguistic patterns to identify domain terms.
These kind of algorithms mostly focus on shallow parsing, or chunking, and look for common patterns or sequences of parts-of-speech.</p>
<p>The ATE linguistic package includes functions that are likely to be useful to all linguistic or hybrid algorithms.
These include methods to extract the vocabulary or a subset of it from a corpus or corpora.</p>
<dl class="function">
<dt id="ate.linguistic.vocabulary">
<code class="sig-name descname">vocabulary</code><span class="sig-paren">(</span><em class="sig-param">corpora</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.linguistic.vocabulary" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract the vocabulary from the given corpora.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>corpora</strong> (<em>str</em><em> or </em><em>list of str</em>) – <p>A corpus, or corpora, of documents.
If a string is given, it is assumed to be one corpus.
If a list is given, it is assumed to be a list of corpora.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is assumed that the corpora were extracted using the tokenizer tool.
Therefore each line should be a JSON string representing a document.
Each document should have a <cite>tokens</cite> attribute.</p>
</div>
</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A list of tokens in the corpora.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list of str</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="ate.linguistic.nouns">
<code class="sig-name descname">nouns</code><span class="sig-paren">(</span><em class="sig-param">corpora</em>, <em class="sig-param">stem=True</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.linguistic.nouns" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract the nouns from the given corpora.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>corpora</strong> (<em>str</em><em> or </em><em>list of str</em>) – <p>A corpus, or corpora, of documents.
If a string is given, it is assumed to be one corpus.
If a list is given, it is assumed to be a list of corpora.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is assumed that the corpora were extracted using the tokenizer tool.
Therefore each line should be a JSON string representing a document.
Each document should have a <cite>tokens</cite> attribute.</p>
</div>
</p></li>
<li><p><strong>stem</strong> (<em>bool</em>) – A boolean indicating whether the nouns should be stemmed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A list of tokens in the corpora.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list of str</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-ate.stat">
<span id="statistical"></span><h2>Statistical<a class="headerlink" href="#module-ate.stat" title="Permalink to this headline">¶</a></h2>
<p>Statistical approaches perform little linguistic processing.
These ATE algorithms range from simple metrics to more complex scoring mechanisms that rank tokens.
Although statistical approaches are not hybrid, many of them may be combined with linguistic approaches.
For example, statistical ATE algorithms often assume that only nouns can be terms.</p>
<div class="section" id="algorithms">
<h3>Algorithms<a class="headerlink" href="#algorithms" title="Permalink to this headline">¶</a></h3>
<div class="section" id="module-ate.stat.tf">
<span id="term-frequency"></span><h4>Term Frequency<a class="headerlink" href="#module-ate.stat.tf" title="Permalink to this headline">¶</a></h4>
<p>Term Frequency (TF) is a simple ATE approach that ranks terms based on the number of times that they appear.</p>
<dl class="class">
<dt id="ate.stat.tf.TFExtractor">
<em class="property">class </em><code class="sig-name descname">TFExtractor</code><a class="headerlink" href="#ate.stat.tf.TFExtractor" title="Permalink to this definition">¶</a></dt>
<dd><p>The TF extractor uses the TF term-weighting scheme to score all tokens in the given corpora.
The class expects tokenized corpora.</p>
<dl class="method">
<dt id="ate.stat.tf.TFExtractor.extract">
<code class="sig-name descname">extract</code><span class="sig-paren">(</span><em class="sig-param">corpora</em>, <em class="sig-param">candidates=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.stat.tf.TFExtractor.extract" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract terms from the given corpora.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>corpora</strong> (<em>str</em><em> or </em><em>list of str</em>) – A path to a corpus or a list of paths to corpora where to look for terms.
This extractor expects the corpora to be tokenized.</p></li>
<li><p><strong>candidates</strong> (<em>None</em><em> or </em><em>list of str</em>) – A list of terms for which to calculate a score.
If <cite>None</cite> is given, all words are considered to be candidates.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A dictionary with terms as keys and their TF scores as values.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-ate.stat.tfidf">
<span id="term-frequency-inverse-document-frequency"></span><h4>Term Frequency-Inverse Document Frequency<a class="headerlink" href="#module-ate.stat.tfidf" title="Permalink to this headline">¶</a></h4>
<p>Term Frequency-Inverse Document Frequency (TF-IDF) is a common and strong baseline for ATE tasks.
The approach scores tokens based on their accumulated TF-IDF score.</p>
<dl class="class">
<dt id="ate.stat.tfidf.TFIDFExtractor">
<em class="property">class </em><code class="sig-name descname">TFIDFExtractor</code><span class="sig-paren">(</span><em class="sig-param">scheme</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.stat.tfidf.TFIDFExtractor" title="Permalink to this definition">¶</a></dt>
<dd><p>The TF-IDF extractor uses a TF-IDF scheme to score all tokens in the given corpora.
The class expects tokenized corpora.</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><p><a class="reference internal" href="nlp.html#module-nlp.term_weighting.scheme" title="nlp.term_weighting.scheme"><strong>scheme</strong></a> (<a class="reference internal" href="nlp.html#nlp.term_weighting.tfidf.TFIDF" title="nlp.term_weighting.tfidf.TFIDF"><code class="xref py py-class docutils literal notranslate"><span class="pre">TFIDF</span></code></a>) – The scheme used by the TF-IDF extractor to score tokens.</p>
</dd>
</dl>
<dl class="method">
<dt id="ate.stat.tfidf.TFIDFExtractor.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">scheme</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.stat.tfidf.TFIDFExtractor.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the TF-IDF extractor with the given scheme.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>scheme</strong> (<a class="reference internal" href="nlp.html#nlp.term_weighting.tfidf.TFIDF" title="nlp.term_weighting.tfidf.TFIDF"><code class="xref py py-class docutils literal notranslate"><span class="pre">TFIDF</span></code></a>) – The scheme used by the TF-IDF extractor to score tokens.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ate.stat.tfidf.TFIDFExtractor.extract">
<code class="sig-name descname">extract</code><span class="sig-paren">(</span><em class="sig-param">corpora</em>, <em class="sig-param">candidates=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.stat.tfidf.TFIDFExtractor.extract" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract terms from the given corpora.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>corpora</strong> (<em>str</em><em> or </em><em>list of str</em>) – A path to a corpus or a list of paths to corpora where to look for terms.
This extractor expects the corpora to be tokenized.</p></li>
<li><p><strong>candidates</strong> (<em>None</em><em> or </em><em>list of str</em>) – A list of terms for which to calculate a score.
If <cite>None</cite> is given, all words are considered to be candidates.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A dictionary with terms as keys and their TF-IDF scores as values.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="module-ate.stat.probability">
<span id="probability"></span><h3>Probability<a class="headerlink" href="#module-ate.stat.probability" title="Permalink to this headline">¶</a></h3>
<p>The probability package includes probability-based ATE approaches.
In addition, the package comes with functions that are likely to be useful to probability-based algorithms.
This includes caching functionality, which collects all documents across all corpora that mention a particular token.</p>
<dl class="function">
<dt id="ate.stat.probability.p">
<code class="sig-name descname">p</code><span class="sig-paren">(</span><em class="sig-param">corpora</em>, <em class="sig-param">focus=None</em>, <em class="sig-param">cache=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.stat.probability.p" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the probability of tokens appearing in the corpus.
The probability is computed in terms of all tokens.</p>
<p>Apart from calculating the probability of single tokens, the joint probability can be calculated by providing tuples.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The joint probability is the minimum count of any token in the joint set in each document.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>corpora</strong> (<em>str</em><em> or </em><em>list of str</em>) – <p>A corpus, or corpora, of documents.
If a string is given, it is assumed to be one corpus.
If a list is given, it is assumed to be a list of corpora.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is assumed that the corpora were extracted using the tokenizer tool.
Therefore each line should be a JSON string representing a document.
Each document should have a <cite>tokens</cite> attribute.</p>
</div>
</p></li>
<li><p><strong>focus</strong> (<em>None</em><em> or </em><em>str</em><em> or </em><em>list of str</em><em> or </em><em>tuple</em><em> or </em><em>list of tuple</em>) – <p>The tokens for which to compute the probability.
If nothing is given, the probability is calculated for all tokens.
The tokens can be provided as:</p>
<ul>
<li><p>A single word,</p></li>
<li><p>A list of tokens,</p></li>
<li><p>A tuple, or</p></li>
<li><p>A list of tuples.</p></li>
</ul>
<p>A tuple can be used to compute joint probabilities.</p>
</p></li>
<li><p><strong>cache</strong> (<em>list of str</em>) – <p>A list of terms that are re-used often and which should be cached.
If an empty list is given, no cache is used.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Cache should be used when there is a lot of repetition.
For example, <cite>x</cite> can be used as cache when <cite>x</cite> is small and <cite>y</cite> is large.
If the data is small, using cache can be detrimental.</p>
</div>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A dictionary with tokens as keys and probabilities as values.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="ate.stat.probability.joint_vocabulary">
<code class="sig-name descname">joint_vocabulary</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">y</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.stat.probability.joint_vocabulary" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the joint vocabulary by creating the cross-product from <cite>x</cite> and <cite>y</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>str</em><em> or </em><em>list of str</em><em> or </em><em>tuple</em><em> or </em><em>list of tuple</em>) – <p>The tokens for which to compute the probability.
These tokens are combined as a cross-product with all tokens in <cite>y</cite>.
The tokens can be provided as:</p>
<ul>
<li><p>A single word,</p></li>
<li><p>A list of tokens,</p></li>
<li><p>A tuple, or</p></li>
<li><p>A list of tuples.</p></li>
</ul>
<p>A tuple translates to joint probabilities.</p>
</p></li>
<li><p><strong>y</strong> (<em>str</em><em> or </em><em>list of str</em><em> or </em><em>tuple</em><em> or </em><em>list of tuple</em>) – <p>The tokens for which to compute the probability.
These tokens are combined as a cross-product with all tokens in <cite>x</cite>.
The tokens can be provided as:</p>
<ul>
<li><p>A single word,</p></li>
<li><p>A list of tokens,</p></li>
<li><p>A tuple, or</p></li>
<li><p>A list of tuples.</p></li>
</ul>
<p>A tuple translates to joint probabilities.</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The joint vocabulary, which is the cross-product of each item in <cite>x</cite> with each item in <cite>y</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list of tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="ate.stat.probability.cached">
<code class="sig-name descname">cached</code><span class="sig-paren">(</span><em class="sig-param">corpora</em>, <em class="sig-param">token</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.stat.probability.cached" title="Permalink to this definition">¶</a></dt>
<dd><p>Compile all the documents in the given corpora that mention the token.
These documents can be used as cache.
In this way, the files do not have to be re-opened and documents without the token do not have to be iterated over.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>corpora</strong> (<em>str</em><em> or </em><em>list of str</em>) – <p>A corpus, or corpora, of documents.
If a string is given, it is assumed to be one corpus.
If a list is given, it is assumed to be a list of corpora.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is assumed that the corpora were extracted using the tokenizer tool.
Therefore each line should be a JSON string representing a document.
Each document should have a <cite>tokens</cite> attribute.</p>
</div>
</p></li>
<li><p><strong>token</strong> (<em>str</em>) – The token to look for in the documents.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A list of documents, each represented as a dictionary, that contain the given token.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list of dict</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-ate.stat.corpus">
<span id="corpus-comparison"></span><h3>Corpus Comparison<a class="headerlink" href="#module-ate.stat.corpus" title="Permalink to this headline">¶</a></h3>
<p>Corpus comparison ATE approaches extract domain terms by comparing term incidence in domain corpora with their incidence in general domains.
This package provides a new extractor meant especially for corpus comparison approaches.
Since all corpus comparison approaches require one or more general corpora, they can be provided in the constructor.</p>
<dl class="class">
<dt id="ate.stat.corpus.ComparisonExtractor">
<em class="property">class </em><code class="sig-name descname">ComparisonExtractor</code><span class="sig-paren">(</span><em class="sig-param">general</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.stat.corpus.ComparisonExtractor" title="Permalink to this definition">¶</a></dt>
<dd><p>The corpus comparison extractor stores the general corpora as a class variable.
All domain comparisons use these general corpora to extract terms.</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><p><strong>general</strong> (<em>list of str</em>) – A list of paths to general corpora, to be used for comparison.
Corpus comparison approaches expect the corpora to be tokenized.</p>
</dd>
</dl>
<dl class="method">
<dt id="ate.stat.corpus.ComparisonExtractor.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">general</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.stat.corpus.ComparisonExtractor.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the corpus comparison extractor with the general corpora.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>general</strong> (<em>str</em><em> or </em><em>list of str</em>) – A path or a list of paths to general corpora, to be used for comparison.
Corpus comparison approaches expect the corpora to be tokenized.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ate.stat.corpus.DummyComparisonExtractor">
<em class="property">class </em><code class="sig-name descname">DummyComparisonExtractor</code><span class="sig-paren">(</span><em class="sig-param">general</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.stat.corpus.DummyComparisonExtractor" title="Permalink to this definition">¶</a></dt>
<dd><p>A dummy comparison extractor that does nothing and returns an empty list of terms.
It is used only for testing purposes.</p>
<dl class="method">
<dt id="ate.stat.corpus.DummyComparisonExtractor.extract">
<code class="sig-name descname">extract</code><span class="sig-paren">(</span><em class="sig-param">corpora</em>, <em class="sig-param">candidates=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.stat.corpus.DummyComparisonExtractor.extract" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an empty list of terms.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>corpora</strong> (<em>str</em><em> or </em><em>list of str</em>) – A path to a corpus or a list of paths to corpora where to look for terms.</p></li>
<li><p><strong>candidates</strong> (<em>None</em><em> or </em><em>list of str</em>) – A list of terms which may be extracted.
This is useful when calculating scores takes a long time and the list of candidate terms are known in advance.
If <cite>None</cite> is given, all words are considered to be candidates.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An empty list of terms.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<div class="section" id="module-ate.stat.corpus.tfdcf">
<span id="tf-dcf"></span><h4>TF-DCF<a class="headerlink" href="#module-ate.stat.corpus.tfdcf" title="Permalink to this headline">¶</a></h4>
<p>Term Frequency-Disjoint Corpora Frequency (TF-DCF) is an ATE approach proposed by Lopes et al.
TF-DCF compares the term frequency of a term in a domain corpus against general corpora:</p>
<div class="math notranslate nohighlight">
\[tf-dcf_t^{(c)} = \frac{tf_t^{(c)}}{\prod_{\forall g \in G} 1 + \log( 1 + tf_t^{(g)} )}\]</div>
<p>where <span class="math notranslate nohighlight">\(t\)</span> is the term for which TF-DCF is being calculated.
<span class="math notranslate nohighlight">\(c\)</span> and <span class="math notranslate nohighlight">\(G\)</span> are the domain-specific corpus and the general corpora respectively.
<span class="math notranslate nohighlight">\(tf_t^{(c)}\)</span> is the term frequency of term <span class="math notranslate nohighlight">\(t\)</span> in corpus <span class="math notranslate nohighlight">\((c)\)</span>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Implementation based on the algorithm outlined in <a class="reference external" href="https://www.sciencedirect.com/science/article/abs/pii/S0950705115004979">Estimating term domain relevance through term frequency, disjoint corpora frequency - tf-dcf by Lopes et al. (2016)</a>.
This paper is based on an earlier paper by the same authors.</p>
</div>
<dl class="class">
<dt id="ate.stat.corpus.tfdcf.TFDCFExtractor">
<em class="property">class </em><code class="sig-name descname">TFDCFExtractor</code><span class="sig-paren">(</span><em class="sig-param">general</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.stat.corpus.tfdcf.TFDCFExtractor" title="Permalink to this definition">¶</a></dt>
<dd><p>The TF-DCF extractor stores a list of general corpora.
It uses these corpora to identify terms that appear very often in domain-specific corpora than in the general corpora.</p>
<dl class="method">
<dt id="ate.stat.corpus.tfdcf.TFDCFExtractor.extract">
<code class="sig-name descname">extract</code><span class="sig-paren">(</span><em class="sig-param">corpora</em>, <em class="sig-param">candidates=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.stat.corpus.tfdcf.TFDCFExtractor.extract" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract terms by scoring them using TF-DCF.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>corpora</strong> (<em>str</em><em> or </em><em>list of str</em>) – A path to a corpus or a list of paths to corpora where to look for terms.</p></li>
<li><p><strong>candidates</strong> (<em>None</em><em> or </em><em>list of str</em>) – A list of terms which may be extracted.
If <cite>None</cite> is given, all words are considered to be candidates.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A dictionary with terms as keys and their TF-DCF scores as values.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
</div>
</div>
<div class="section" id="module-ate.application">
<span id="application"></span><h2>Application<a class="headerlink" href="#module-ate.application" title="Permalink to this headline">¶</a></h2>
<p>Application-based approaches use the target application to learn the domain lexicon.</p>
<div class="section" id="module-ate.application.event">
<span id="events"></span><h3>Events<a class="headerlink" href="#module-ate.application.event" title="Permalink to this headline">¶</a></h3>
<p>Event-based ATE approaches use either event corpora or the output timelines to score and rank domain terms.</p>
<div class="section" id="event-frequency-ef">
<h4>Event Frequency (EF)<a class="headerlink" href="#event-frequency-ef" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="ate.application.event.EF">
<em class="property">class </em><code class="sig-name descname">EF</code><a class="headerlink" href="#ate.application.event.EF" title="Permalink to this definition">¶</a></dt>
<dd><p>The Event Frequency (EF) extractor looks for terms in timelines.
The scoring is based on simple frequency.</p>
<dl class="method">
<dt id="ate.application.event.EF.extract">
<code class="sig-name descname">extract</code><span class="sig-paren">(</span><em class="sig-param">timelines</em>, <em class="sig-param">candidates=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.application.event.EF.extract" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the event frequency of terms from the given timelines.
The event frequency is simply the number of events in which term appears in a development.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>timelines</strong> (<em>str</em><em> or </em><em>list of str</em>) – <p>The path to a timeline or a list of paths to timelines.
If a string is given, it is assumed to be one event timeline.
If a list is given, it is assumed to be a list of event timelines.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<dl class="simple">
<dt>It is assumed that the event timelines were extracted using the collection tool.</dt><dd><p>Therefore each file should be a JSON string representing a <a class="reference internal" href="summarization.html#summarization.timeline.timeline.Timeline" title="summarization.timeline.timeline.Timeline"><code class="xref py py-class docutils literal notranslate"><span class="pre">Timeline</span></code></a>.</p>
</dd>
</dl>
</div>
</p></li>
<li><p><strong>candidates</strong> (<em>None</em><em> or </em><em>list of str</em>) – A list of terms for which to calculate a score.
If <cite>None</cite> is given, all words are considered to be candidates.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A dictionary with terms as keys and their event frequency as the values.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="logarithmic-event-frequency-ef">
<h4>Logarithmic Event Frequency (EF)<a class="headerlink" href="#logarithmic-event-frequency-ef" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="ate.application.event.LogEF">
<em class="property">class </em><code class="sig-name descname">LogEF</code><span class="sig-paren">(</span><em class="sig-param">base=2</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.application.event.LogEF" title="Permalink to this definition">¶</a></dt>
<dd><p>The logarithmic Event Frequency (EF) extractor looks for terms in timelines.
The scoring is the logarithm of the simple frequency, as calculated in <a class="reference internal" href="#ate.application.event.EF" title="ate.application.event.EF"><code class="xref py py-class docutils literal notranslate"><span class="pre">EF</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><p><strong>base</strong> (<em>float</em>) – The logarithmic base.</p>
</dd>
</dl>
<dl class="method">
<dt id="ate.application.event.LogEF.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">base=2</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.application.event.LogEF.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the logarithmic EF extractor with the logarithmic base.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>base</strong> (<em>float</em>) – The logarithmic base.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ate.application.event.LogEF.extract">
<code class="sig-name descname">extract</code><span class="sig-paren">(</span><em class="sig-param">timelines</em>, <em class="sig-param">candidates=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.application.event.LogEF.extract" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the logarithmic event frequency of terms from the given timelines.
The event frequency is simply the number of events in which term appears in a development.</p>
<p>This weighting scheme is based on the <a class="reference internal" href="#ate.application.event.EF" title="ate.application.event.EF"><code class="xref py py-func docutils literal notranslate"><span class="pre">EF()</span></code></a> weighting scheme.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>timelines</strong> (<em>str</em><em> or </em><em>list of str</em>) – <p>The path to a timeline or a list of paths to timelines.
If a string is given, it is assumed to be one event timeline.
If a list is given, it is assumed to be a list of event timelines.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<dl class="simple">
<dt>It is assumed that the event timelines were extracted using the collection tool.</dt><dd><p>Therefore each file should be a JSON string representing a <a class="reference internal" href="summarization.html#summarization.timeline.timeline.Timeline" title="summarization.timeline.timeline.Timeline"><code class="xref py py-class docutils literal notranslate"><span class="pre">Timeline</span></code></a>.</p>
</dd>
</dl>
</div>
</p></li>
<li><p><strong>candidates</strong> (<em>None</em><em> or </em><em>list of str</em>) – A list of terms for which to calculate a score.
If <cite>None</cite> is given, all words are considered to be candidates.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A dictionary with terms as keys and their logarithmic event frequency as the values.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="event-frequency-inverse-document-frequency-ef-idf">
<h4>Event Frequency-Inverse Document Frequency (EF-IDF)<a class="headerlink" href="#event-frequency-inverse-document-frequency-ef-idf" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="ate.application.event.EFIDF">
<em class="property">class </em><code class="sig-name descname">EFIDF</code><span class="sig-paren">(</span><em class="sig-param">scheme</em>, <em class="sig-param">base=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.application.event.EFIDF" title="Permalink to this definition">¶</a></dt>
<dd><p>The EF-IDF extractor combines the event frequency with the inverse document frequency.
The algorithm can be made to work with the <a class="reference internal" href="#ate.application.event.LogEF" title="ate.application.event.LogEF"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogEF</span></code></a> class instead of the <a class="reference internal" href="#ate.application.event.EF" title="ate.application.event.EF"><code class="xref py py-class docutils literal notranslate"><span class="pre">EF</span></code></a> class by providing a logarithmic base.</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><ul class="simple">
<li><p><a class="reference internal" href="nlp.html#module-nlp.term_weighting.scheme" title="nlp.term_weighting.scheme"><strong>scheme</strong></a> (<code class="xref py py-class docutils literal notranslate"><span class="pre">TFIDF</span></code>) – The IDF table to use to score terms.</p></li>
<li><p><strong>base</strong> (<em>None</em><em> or </em><em>float</em>) – The logarithmic base.
If it is given, the <a class="reference internal" href="#ate.application.event.LogEF" title="ate.application.event.LogEF"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogEF</span></code></a> class is used.
Otherwise, the <a class="reference internal" href="#ate.application.event.EF" title="ate.application.event.EF"><code class="xref py py-class docutils literal notranslate"><span class="pre">EF</span></code></a> class is used.</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="ate.application.event.EFIDF.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">scheme</em>, <em class="sig-param">base=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.application.event.EFIDF.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the EF-IDF extractor with the scheme used to score terms and the logarithmic base.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>idf</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">TFIDF</span></code>) – The IDF table to use to score terms.</p></li>
<li><p><strong>base</strong> (<em>None</em><em> or </em><em>float</em>) – The logarithmic base.
If it is given, the <a class="reference internal" href="#ate.application.event.LogEF" title="ate.application.event.LogEF"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogEF</span></code></a> class is used.
Otherwise, the <a class="reference internal" href="#ate.application.event.EF" title="ate.application.event.EF"><code class="xref py py-class docutils literal notranslate"><span class="pre">EF</span></code></a> class is used.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ate.application.event.EFIDF.extract">
<code class="sig-name descname">extract</code><span class="sig-paren">(</span><em class="sig-param">timelines</em>, <em class="sig-param">candidates=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.application.event.EFIDF.extract" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the event-frequency-inverse-document-frequency metric for terms.
This is a local-global weighting scheme.
The local scheme is the event frequency, and the global scheme is the inverse-document-frequency.
If a logarithmic base is provided, the logarithmic event frequency is used instead.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>timelines</strong> (<em>str</em><em> or </em><em>list of str</em>) – <p>The path to a timeline or a list of paths to timelines.
If a string is given, it is assumed to be one event timeline.
If a list is given, it is assumed to be a list of event timelines.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<dl class="simple">
<dt>It is assumed that the event timelines were extracted using the collection tool.</dt><dd><p>Therefore each file should be a JSON string representing a <a class="reference internal" href="summarization.html#summarization.timeline.timeline.Timeline" title="summarization.timeline.timeline.Timeline"><code class="xref py py-class docutils literal notranslate"><span class="pre">Timeline</span></code></a>.</p>
</dd>
</dl>
</div>
</p></li>
<li><p><strong>candidates</strong> (<em>None</em><em> or </em><em>list of str</em>) – A list of terms for which to calculate a score.
If <cite>None</cite> is given, all words are considered to be candidates.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A dictionary with terms as keys and their EF-IDF scores as the values.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="variability">
<h4>Variability<a class="headerlink" href="#variability" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="ate.application.event.Variability">
<em class="property">class </em><code class="sig-name descname">Variability</code><span class="sig-paren">(</span><em class="sig-param">base=10</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.application.event.Variability" title="Permalink to this definition">¶</a></dt>
<dd><p>Variability is a metric that measures the consistency of appearance of a term across different events.
The variability metric is based on the chi-square statistic.
The intuition is that terms that appear more consistently in different events are more likely to belong to the domain.</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><p><strong>base</strong> (<em>float</em>) – The logarithmic base.</p>
</dd>
</dl>
<dl class="method">
<dt id="ate.application.event.Variability.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">base=10</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.application.event.Variability.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the variability extractor with a logarithmic base.
This base is used because the variability score is the inverse of the chi-square.
Therefore scores end up being very close to each other without a logarithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>base</strong> (<em>float</em>) – The logarithmic base.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ate.application.event.Variability.extract">
<code class="sig-name descname">extract</code><span class="sig-paren">(</span><em class="sig-param">idfs</em>, <em class="sig-param">candidates=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.application.event.Variability.extract" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate how variable the term is across events.
A term is highly-variable if it appears disproportionately in one or a few events.
A low variability indicates that the term appears consistently across all events.
To reflect this behavior in the score, the inverse of the variability is returned.</p>
<p>The method follows the leave-one-out principle: each event is compared against all other events.
The final result is an average weightg according to the event sizes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>idfs</strong> (list of <a class="reference internal" href="nlp.html#nlp.term_weighting.tfidf.TFIDF" title="nlp.term_weighting.tfidf.TFIDF"><code class="xref py py-class docutils literal notranslate"><span class="pre">TFIDF</span></code></a>) – A list of IDFs, one for each event.</p></li>
<li><p><strong>candidates</strong> (<em>None</em><em> or </em><em>list of str</em>) – A list of terms for which to calculate a score.
If <cite>None</cite> is given, all words are considered to be candidates.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A dictionary with terms as keys and their inverse variability score as the values.
A term is highly-variable if it appears disproportionately in one or a few events.
A low variability indicates that the term appears consistently across all events.
To reflect this behavior in the score, the inverse of the variability is returned.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ate.application.event.Variability._vocabulary">
<code class="sig-name descname">_vocabulary</code><span class="sig-paren">(</span><em class="sig-param">idfs</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.application.event.Variability._vocabulary" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract the vocabulary from the given IDFs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>idfs</strong> (list of <a class="reference internal" href="nlp.html#nlp.term_weighting.tfidf.TFIDF" title="nlp.term_weighting.tfidf.TFIDF"><code class="xref py py-class docutils literal notranslate"><span class="pre">TFIDF</span></code></a>) – A list of IDFs, one for each event.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A list of terms in the given IDFs.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list of str</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ate.application.event.Variability._contingency_table">
<code class="sig-name descname">_contingency_table</code><span class="sig-paren">(</span><em class="sig-param">term</em>, <em class="sig-param">current</em>, <em class="sig-param">comparison</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.application.event.Variability._contingency_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the contingency table comparing the term’s appearance in the current event versus other events.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>term</strong> (<em>str</em>) – The term for which to create the contingency table.</p></li>
<li><p><strong>current</strong> (<a class="reference internal" href="nlp.html#nlp.term_weighting.tfidf.TFIDF" title="nlp.term_weighting.tfidf.TFIDF"><code class="xref py py-class docutils literal notranslate"><span class="pre">TFIDF</span></code></a>) – The current event’s IDF table.</p></li>
<li><p><strong>comparison</strong> (list of <a class="reference internal" href="nlp.html#nlp.term_weighting.tfidf.TFIDF" title="nlp.term_weighting.tfidf.TFIDF"><code class="xref py py-class docutils literal notranslate"><span class="pre">TFIDF</span></code></a>) – A list of IDFs, one for each event.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The contingency table for the term, contrasting the current event with all other events.
The first row is the total number of documents in the current event.
The second row is the total number of documents in the comparison events.
The totals of both rows sum up to the total number of documents.
The contingency table is returned as a tuple with four floats.
These correspond to the first and second rows respectively.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple of float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ate.application.event.Variability._chi">
<code class="sig-name descname">_chi</code><span class="sig-paren">(</span><em class="sig-param">table</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.application.event.Variability._chi" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the chi-square statistic from the given table.
The chi-square statistic is 0 if the two variables are independent.
The higher the statistic, the more dependent the two variables are.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>table</strong> (<em>tuple of int</em>) – <p>The contingency table as a four-tuple.
The values are four-tuples representing the values of cells in the order:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Top-left,</p></li>
<li><p>Top-right,</p></li>
<li><p>Bottom-left, and</p></li>
<li><p>Bottom-right.</p></li>
</ol>
</div></blockquote>
</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The chi-square statistic.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
</div>
</div>
<div class="section" id="module-ate.bootstrapping">
<span id="bootstrapping"></span><h2>Bootstrapping<a class="headerlink" href="#module-ate.bootstrapping" title="Permalink to this headline">¶</a></h2>
<p>Bootstrapping is a process that can follow ATE.
Starting from a seed set of terms, bootstrapping looks for semantically-similar terms.</p>
<p>This package provides a skeleton structure of what bootstrapping algorithms should be able to do.</p>
<dl class="class">
<dt id="ate.bootstrapping.Bootstrapper">
<em class="property">class </em><code class="sig-name descname">Bootstrapper</code><a class="headerlink" href="#ate.bootstrapping.Bootstrapper" title="Permalink to this definition">¶</a></dt>
<dd><p>A bootstrapper must provide functionality to bootstrap.
Starting from a seed set and a corpus, or a list of corpora, a bootstrapper looks for semantically-similar terms.</p>
<p>Bootstrapping is implemented as all possible combinations of a seed set terms and candidate terms.
Therefore the main <a class="reference internal" href="#ate.bootstrapping.Bootstrapper.bootstrap" title="ate.bootstrapping.Bootstrapper.bootstrap"><code class="xref py py-func docutils literal notranslate"><span class="pre">bootstrap()</span></code></a> function returns a dictionary of scores.
Each score represents a seed set term’s score for a candidate.</p>
<dl class="method">
<dt id="ate.bootstrapping.Bootstrapper.bootstrap">
<em class="property">abstract </em><code class="sig-name descname">bootstrap</code><span class="sig-paren">(</span><em class="sig-param">corpora</em>, <em class="sig-param">seed=None</em>, <em class="sig-param">candidates=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.bootstrapping.Bootstrapper.bootstrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Using the given seed set of terms, look for semantically-similar terms in the given corpora.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>corpora</strong> (<em>str</em><em> or </em><em>list of str</em>) – <p>A corpus, or corpora, of documents.
If a string is given, it is assumed to be one corpus.
If a list is given, it is assumed to be a list of corpora.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is assumed that the corpora were extracted using the tokenizer tool.
Therefore each line should be a JSON string representing a document.
Each document should have a <cite>tokens</cite> attribute.</p>
</div>
</p></li>
<li><p><strong>seed</strong> (<em>None</em><em> or </em><em>str</em><em> or </em><em>list of str</em><em> or </em><em>tuple</em><em> or </em><em>list of tuple</em>) – <p>The terms for which to compute the probability.
These terms are combined as a cross-product with all terms in <cite>candidates</cite>.
The terms can be provided as:</p>
<ul>
<li><p>A single word,</p></li>
<li><p>A list of terms,</p></li>
<li><p>A tuple, or</p></li>
<li><p>A list of tuples.</p></li>
</ul>
<p>A tuple translates to joint probabilities.
If nothing is given, it is replaced with the corpora’s vocabulary.</p>
</p></li>
<li><p><strong>candidates</strong> (<em>None</em><em> or </em><em>str</em><em> or </em><em>list of str</em><em> or </em><em>tuple</em><em> or </em><em>list of tuple</em>) – <p>The terms for which to compute the probability.
These terms are combined as a cross-product with all terms in <cite>seed</cite>.
The terms can be provided as:</p>
<ul>
<li><p>A single word,</p></li>
<li><p>A list of terms,</p></li>
<li><p>A tuple, or</p></li>
<li><p>A list of tuples.</p></li>
</ul>
<p>A tuple translates to joint probabilities.
If nothing is given, it is replaced with the corpora’s vocabulary.</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The scores of each seed term for each candidate.
Bootstrapping computes a score for the cross-product of the seed set and candidates.
In other words, there is a score for every possible combination of terms in the seed set, and terms in the candidates.
The scores are returned as a dictionary.
The keys are these pairs, and the values are their scores.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ate.bootstrapping.Bootstrapper.to_list">
<code class="sig-name descname">to_list</code><span class="sig-paren">(</span><em class="sig-param">corpora</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.bootstrapping.Bootstrapper.to_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the given corpora to a list of corpora.
This function can be invoked when the input is either a list or a single path.
If a list of corpora is provided, this function returns the original input.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>corpora</strong> (<em>str</em><em> or </em><em>list of str</em>) – A path to a corpus or paths to corpora.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A list of corpora.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list of str</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="ate.bootstrapping.Bootstrapper.__weakref__">
<code class="sig-name descname">__weakref__</code><a class="headerlink" href="#ate.bootstrapping.Bootstrapper.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ate.bootstrapping.DummyBootstrapper">
<em class="property">class </em><code class="sig-name descname">DummyBootstrapper</code><a class="headerlink" href="#ate.bootstrapping.DummyBootstrapper" title="Permalink to this definition">¶</a></dt>
<dd><p>A dummy bootstrapper that does nothing and returns an empty dictionary of bootstrapped terms.
It is used only for testing purposes.</p>
<dl class="method">
<dt id="ate.bootstrapping.DummyBootstrapper.bootstrap">
<code class="sig-name descname">bootstrap</code><span class="sig-paren">(</span><em class="sig-param">corpora</em>, <em class="sig-param">seed=None</em>, <em class="sig-param">candidates=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.bootstrapping.DummyBootstrapper.bootstrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Using the given seed set of terms, look for semantically-similar terms in the given corpora.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>corpora</strong> (<em>str</em><em> or </em><em>list of str</em>) – <p>A corpus, or corpora, of documents.
If a string is given, it is assumed to be one corpus.
If a list is given, it is assumed to be a list of corpora.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is assumed that the corpora were extracted using the tokenizer tool.
Therefore each line should be a JSON string representing a document.
Each document should have a <cite>tokens</cite> attribute.</p>
</div>
</p></li>
<li><p><strong>seed</strong> (<em>None</em><em> or </em><em>str</em><em> or </em><em>list of str</em><em> or </em><em>tuple</em><em> or </em><em>list of tuple</em>) – <p>The terms for which to compute the probability.
These terms are combined as a cross-product with all terms in <cite>candidates</cite>.
The terms can be provided as:</p>
<ul>
<li><p>A single word,</p></li>
<li><p>A list of terms,</p></li>
<li><p>A tuple, or</p></li>
<li><p>A list of tuples.</p></li>
</ul>
<p>A tuple translates to joint probabilities.
If nothing is given, it is replaced with the corpora’s vocabulary.</p>
</p></li>
<li><p><strong>candidates</strong> (<em>None</em><em> or </em><em>str</em><em> or </em><em>list of str</em><em> or </em><em>tuple</em><em> or </em><em>list of tuple</em>) – <p>The terms for which to compute the probability.
These terms are combined as a cross-product with all terms in <cite>seed</cite>.
The terms can be provided as:</p>
<ul>
<li><p>A single word,</p></li>
<li><p>A list of terms,</p></li>
<li><p>A tuple, or</p></li>
<li><p>A list of tuples.</p></li>
</ul>
<p>A tuple translates to joint probabilities.
If nothing is given, it is replaced with the corpora’s vocabulary.</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The scores of each seed term for each candidate.
Bootstrapping computes a score for the cross-product of the seed set and candidates.
In other words, there is a score for every possible combination of terms in the seed set, and terms in the candidates.
The scores are returned as a dictionary.
The keys are these pairs, and the values are their scores.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<div class="section" id="id1">
<h3>Probability<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<span class="target" id="module-ate.bootstrapping.probability"></span><p>Probability-based bootstrapping approaches use principles founded in probability theory.
These include measures that measure correlation.
This correlation, in turn, is taken to signify the statistical significance between a seed term and a candidate term.</p>
<div class="section" id="module-ate.bootstrapping.probability.pmi">
<span id="pointwise-mutual-information-pmi"></span><h4>Pointwise Mutual Information (PMI)<a class="headerlink" href="#module-ate.bootstrapping.probability.pmi" title="Permalink to this headline">¶</a></h4>
<p>Pointwise Mutual Information (PMI) measures how much information one variable gives about another.
It is a symmetric measure, computed as:</p>
<div class="math notranslate nohighlight">
\[PMI(x,y) = \log( \frac{p(x,y)}{p(x)p(y)} )\]</div>
<p>where <cite>x</cite> and <cite>y</cite> are the two variables.</p>
<dl class="class">
<dt id="ate.bootstrapping.probability.pmi.PMIBootstrapper">
<em class="property">class </em><code class="sig-name descname">PMIBootstrapper</code><span class="sig-paren">(</span><em class="sig-param">base=2</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.bootstrapping.probability.pmi.PMIBootstrapper" title="Permalink to this definition">¶</a></dt>
<dd><p>The Pointwise Mutual Information (PMI) bootstrapper scores candidate terms based on how much they correlate with seed terms.</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><p><strong>base</strong> (<em>float</em>) – The base of the logarithm, defaults to 2.</p>
</dd>
</dl>
<dl class="method">
<dt id="ate.bootstrapping.probability.pmi.PMIBootstrapper.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">base=2</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.bootstrapping.probability.pmi.PMIBootstrapper.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the PMI bootstrapper with the logarithmic base to use in the calculation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>base</strong> (<em>float</em>) – The base of the logarithm, defaults to 2.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ate.bootstrapping.probability.pmi.PMIBootstrapper.bootstrap">
<code class="sig-name descname">bootstrap</code><span class="sig-paren">(</span><em class="sig-param">corpora</em>, <em class="sig-param">seed=None</em>, <em class="sig-param">candidates=None</em>, <em class="sig-param">cache=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.bootstrapping.probability.pmi.PMIBootstrapper.bootstrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the Pointwise Mutual-Information (PMI) between the seed set terms and the candidate terms..</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>corpora</strong> (<em>str</em><em> or </em><em>list of str</em>) – <p>A corpus, or corpora, of documents.
If a string is given, it is assumed to be one corpus.
If a list is given, it is assumed to be a list of corpora.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is assumed that the corpora were extracted using the tokenizer tool.
Therefore each line should be a JSON string representing a document.
Each document should have a <cite>tokens</cite> attribute.</p>
</div>
</p></li>
<li><p><strong>seed</strong> (<em>None</em><em> or </em><em>str</em><em> or </em><em>list of str</em><em> or </em><em>tuple</em><em> or </em><em>list of tuple</em>) – <p>The terms for which to compute the probability.
These terms are combined as a cross-product with all terms in <cite>candidates</cite>.
The terms can be provided as:</p>
<ul>
<li><p>A single word,</p></li>
<li><p>A list of terms,</p></li>
<li><p>A tuple, or</p></li>
<li><p>A list of tuples.</p></li>
</ul>
<p>A tuple translates to joint probabilities.
If nothing is given, it is replaced with the corpora’s vocabulary.</p>
</p></li>
<li><p><strong>candidates</strong> (<em>None</em><em> or </em><em>str</em><em> or </em><em>list of str</em><em> or </em><em>tuple</em><em> or </em><em>list of tuple</em>) – <p>The terms for which to compute the probability.
These terms are combined as a cross-product with all terms in <cite>seed</cite>.
The terms can be provided as:</p>
<ul>
<li><p>A single word,</p></li>
<li><p>A list of terms,</p></li>
<li><p>A tuple, or</p></li>
<li><p>A list of tuples.</p></li>
</ul>
<p>A tuple translates to joint probabilities.
If nothing is given, it is replaced with the corpora’s vocabulary.</p>
</p></li>
<li><p><strong>cache</strong> (<em>None</em><em> or </em><em>list of str</em>) – <p>A list of terms that are re-used often and which should be cached.
If an empty list or <cite>None</cite> is given, no cache is used.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Cache should be used when there is a lot of repetition.
For example, <cite>seed</cite> can be used as cache when <cite>seed</cite> is small and <cite>candidates</cite> is large.
If the data is small, using cache can be detrimental.</p>
</div>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The scores of each seed term for each candidate.
Bootstrapping computes a score for the cross-product of the seed set and candidates.
In other words, there is a score for every possible combination of terms in the seed set, and terms in the candidates.
The PMI scores are returned as a dictionary.
The keys are these pairs, and their PMI are the values.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ate.bootstrapping.probability.pmi.PMIBootstrapper._pmi">
<code class="sig-name descname">_pmi</code><span class="sig-paren">(</span><em class="sig-param">prob</em>, <em class="sig-param">x</em>, <em class="sig-param">y</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.bootstrapping.probability.pmi.PMIBootstrapper._pmi" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the Pointwise Mutual Information (PMI) of <cite>x</cite> and <cite>y</cite> based on the given probabilities.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>prob</strong> (<em>dict</em>) – A probability calculation, possibly calculated using the <a class="reference internal" href="#ate.stat.probability.p" title="ate.stat.probability.p"><code class="xref py py-func docutils literal notranslate"><span class="pre">ate.stat.probability.p()</span></code></a> function.
This is used as cache for the probabilities.
The keys are the tokens, including the joint probability of <cite>x</cite> and <cite>y</cite>, and the values are their probabilities.</p></li>
<li><p><strong>x</strong> (<em>str</em><em> or </em><em>tuple of str</em>) – The first token or tuple of tokens to use to calculate the PMI.</p></li>
<li><p><strong>y</strong> (<em>str</em><em> or </em><em>tuple of str</em>) – The second token or tuple of tokens to use to calculate the PMI.</p></li>
<li><p><strong>base</strong> (<em>float</em>) – The base of the logarithm, defaults to 2.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The PMI of <cite>x</cite> and <cite>y</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-ate.bootstrapping.probability.chi">
<span id="chi-square"></span><h4>Chi-Square<a class="headerlink" href="#module-ate.bootstrapping.probability.chi" title="Permalink to this headline">¶</a></h4>
<p>The chi-square statistic measures how often two variables appear in together.
It is calculated using a two-by-two contingency table as:</p>
<div class="math notranslate nohighlight">
\[CHI(x, y) = \frac{(A + B + C + D) \times (A \times D - C \times B)^2}{(A + C) \times (B + D) \times (A + B) \times (C + D) )}\]</div>
<p>where <cite>A</cite>, <cite>B</cite>, <cite>C</cite> and <cite>D</cite> are the cells in the contingency table.
The values <cite>A</cite>, <cite>B</cite>, <cite>C</cite> and <cite>D</cite> are placed in the contingency table as follows.</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Top-left,</p></li>
<li><p>Top-right,</p></li>
<li><p>Bottom-left, and</p></li>
<li><p>Bottom-right.</p></li>
</ol>
</div></blockquote>
<dl class="class">
<dt id="ate.bootstrapping.probability.chi.ChiBootstrapper">
<em class="property">class </em><code class="sig-name descname">ChiBootstrapper</code><a class="headerlink" href="#ate.bootstrapping.probability.chi.ChiBootstrapper" title="Permalink to this definition">¶</a></dt>
<dd><p>The chi-square bootstrapper scores candidate terms based on how often they appear with seed terms.</p>
<dl class="method">
<dt id="ate.bootstrapping.probability.chi.ChiBootstrapper.bootstrap">
<code class="sig-name descname">bootstrap</code><span class="sig-paren">(</span><em class="sig-param">corpora</em>, <em class="sig-param">seed=None</em>, <em class="sig-param">candidates=None</em>, <em class="sig-param">cache=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.bootstrapping.probability.chi.ChiBootstrapper.bootstrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the chi-square statistic of co-occurrence for the seed set terms and the candidate terms..</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>corpora</strong> (<em>str</em><em> or </em><em>list of str</em>) – <p>A corpus, or corpora, of documents.
If a string is given, it is assumed to be one corpus.
If a list is given, it is assumed to be a list of corpora.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is assumed that the corpora were extracted using the tokenizer tool.
Therefore each line should be a JSON string representing a document.
Each document should have a <cite>tokens</cite> attribute.</p>
</div>
</p></li>
<li><p><strong>seed</strong> (<em>None</em><em> or </em><em>str</em><em> or </em><em>list of str</em><em> or </em><em>tuple</em><em> or </em><em>list of tuple</em>) – <p>The terms for which to compute the probability.
These terms are combined as a cross-product with all terms in <cite>candidates</cite>.
The terms can be provided as:</p>
<ul>
<li><p>A single word,</p></li>
<li><p>A list of terms,</p></li>
<li><p>A tuple, or</p></li>
<li><p>A list of tuples.</p></li>
</ul>
<p>A tuple translates to joint probabilities.
If nothing is given, it is replaced with the corpora’s vocabulary.</p>
</p></li>
<li><p><strong>candidates</strong> (<em>None</em><em> or </em><em>str</em><em> or </em><em>list of str</em><em> or </em><em>tuple</em><em> or </em><em>list of tuple</em>) – <p>The terms for which to compute the probability.
These terms are combined as a cross-product with all terms in <cite>seed</cite>.
The terms can be provided as:</p>
<ul>
<li><p>A single word,</p></li>
<li><p>A list of terms,</p></li>
<li><p>A tuple, or</p></li>
<li><p>A list of tuples.</p></li>
</ul>
<p>A tuple translates to joint probabilities.
If nothing is given, it is replaced with the corpora’s vocabulary.</p>
</p></li>
<li><p><strong>cache</strong> (<em>None</em><em> or </em><em>list of str</em>) – <p>A list of terms that are re-used often and which should be cached.
If an empty list or <cite>None</cite> is given, no cache is used.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Cache should be used when there is a lot of repetition.
For example, <cite>seed</cite> can be used as cache when <cite>seed</cite> is small and <cite>candidates</cite> is large.
If the data is small, using cache can be detrimental.</p>
</div>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The scores of each seed term for each candidate.
Bootstrapping computes a score for the cross-product of the seed set and candidates.
In other words, there is a score for every possible combination of terms in the seed set, and terms in the candidates.
The chi-square statistic scores are returned as a dictionary.
The keys are these pairs, and their chi-square statistics are the values.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ate.bootstrapping.probability.chi.ChiBootstrapper._contingency_table">
<code class="sig-name descname">_contingency_table</code><span class="sig-paren">(</span><em class="sig-param">corpora</em>, <em class="sig-param">seed</em>, <em class="sig-param">candidates</em>, <em class="sig-param">cache=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.bootstrapping.probability.chi.ChiBootstrapper._contingency_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the contingency tables for all the pairs of terms in <cite>seed</cite> and <cite>candidates</cite>.
All the terms in <cite>seed</cite> are matched with all terms in <cite>candidates</cite> in a cross-product fashion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>corpora</strong> (<em>str</em><em> or </em><em>list of str</em>) – <p>A corpus, or corpora, of documents.
If a string is given, it is assumed to be one corpus.
If a list is given, it is assumed to be a list of corpora.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is assumed that the corpora were extracted using the tokenizer tool.
Therefore each line should be a JSON string representing a document.
Each document should have a <cite>tokens</cite> attribute.</p>
</div>
</p></li>
<li><p><strong>seed</strong> (<em>None</em><em> or </em><em>str</em><em> or </em><em>list of str</em><em> or </em><em>tuple</em><em> or </em><em>list of tuple</em>) – <p>The terms for which to compute the probability.
These terms are combined as a cross-product with all terms in <cite>candidates</cite>.
The terms can be provided as:</p>
<ul>
<li><p>A single word,</p></li>
<li><p>A list of terms,</p></li>
<li><p>A tuple, or</p></li>
<li><p>A list of tuples.</p></li>
</ul>
<p>A tuple translates to joint probabilities.
If nothing is given, it is replaced with the corpora’s vocabulary.</p>
</p></li>
<li><p><strong>candidates</strong> (<em>None</em><em> or </em><em>str</em><em> or </em><em>list of str</em><em> or </em><em>tuple</em><em> or </em><em>list of tuple</em>) – <p>The terms for which to compute the probability.
These terms are combined as a cross-product with all terms in <cite>seed</cite>.
The terms can be provided as:</p>
<ul>
<li><p>A single word,</p></li>
<li><p>A list of terms,</p></li>
<li><p>A tuple, or</p></li>
<li><p>A list of tuples.</p></li>
</ul>
<p>A tuple translates to joint probabilities.
If nothing is given, it is replaced with the corpora’s vocabulary.</p>
</p></li>
<li><p><strong>cache</strong> (<em>None</em><em> or </em><em>list of str</em>) – <p>A list of terms that are re-used often and which should be cached.
If an empty list or <cite>None</cite> is given, no cache is used.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Cache should be used when there is a lot of repetition.
For example, <cite>seed</cite> can be used as cache when <cite>seed</cite> is small and <cite>candidates</cite> is large.
If the data is small, using cache can be detrimental.</p>
</div>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>A dictionary of contingency tables.
The keys are the pairs of the terms.
The values are four-tuples representing the values of cells in the order:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Top-left,</p></li>
<li><p>Top-right,</p></li>
<li><p>Bottom-left, and</p></li>
<li><p>Bottom-right.</p></li>
</ol>
</div></blockquote>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ate.bootstrapping.probability.chi.ChiBootstrapper._chi">
<code class="sig-name descname">_chi</code><span class="sig-paren">(</span><em class="sig-param">table</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.bootstrapping.probability.chi.ChiBootstrapper._chi" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the chi-square statistic from the given table.
The chi-square statistic is 0 if the two variables are independent.
The higher the statistic, the more dependent the two variables are.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>table</strong> (<em>tuple of int</em>) – <p>The contingency table as a four-tuple.
The values are four-tuples representing the values of cells in the order:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Top-left,</p></li>
<li><p>Top-right,</p></li>
<li><p>Bottom-left, and</p></li>
<li><p>Bottom-right.</p></li>
</ol>
</div></blockquote>
</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The chi-square statistic.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="other.html" class="btn btn-neutral float-right" title="12. Other" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="ml.html" class="btn btn-neutral float-left" title="10. Machine Learning" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Nicholas Mamo

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>