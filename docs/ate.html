

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta content="The Automatic Term Extraction (ATE) library" name="description" />
<meta content="Python, TDT, ATE" name="keywords" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>11. Automatic Term Extraction (ATE) &mdash; EvenTDT 0.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="12. Other" href="other.html" />
    <link rel="prev" title="10. Machine Learning" href="ml.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> EvenTDT
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="config.html">0. Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="tools.html">1. Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="vsm.html">2. Vector Space Model (VSM)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nlp.html">3. Natural Language Processing (NLP)</a></li>
<li class="toctree-l1"><a class="reference internal" href="wikinterface.html">4. Wikinterface</a></li>
<li class="toctree-l1"><a class="reference internal" href="apd.html">5. Automatic Participant Detection (APD)</a></li>
<li class="toctree-l1"><a class="reference internal" href="tdt.html">6. Topic Detection and Tracking (TDT)</a></li>
<li class="toctree-l1"><a class="reference internal" href="summarization.html">7. Summarization</a></li>
<li class="toctree-l1"><a class="reference internal" href="twitter.html">8. Twitter</a></li>
<li class="toctree-l1"><a class="reference internal" href="consumers.html">9. Consumers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ml.html">10. Machine Learning</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">11. Automatic Term Extraction (ATE)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-ate.linguistic">Linguistic</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-ate.stat">Statistical</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-ate.application">Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-ate.bootstrapping">Bootstrapping</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-ate.bootstrapping.probability">Probability</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="other.html">12. Other</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">EvenTDT</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>11. Automatic Term Extraction (ATE)</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/ate.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="automatic-term-extraction-ate">
<h1>11. Automatic Term Extraction (ATE)<a class="headerlink" href="#automatic-term-extraction-ate" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-ate"></span><p>Package-level functions and classes that are likely to be useful to all ATE approaches.</p>
<dl class="function">
<dt id="ate.total_documents">
<code class="sig-name descname">total_documents</code><span class="sig-paren">(</span><em class="sig-param">corpora</em>, <em class="sig-param">focus=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.total_documents" title="Permalink to this definition">¶</a></dt>
<dd><p>Count the total number of documents in the given corpora.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>corpora</strong> (<em>str</em><em> or </em><em>list of str</em>) – <p>A corpus, or corpora, of documents.
If a string is given, it is assumed to be one corpus.
If a list is given, it is assumed to be a list of corpora.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is assumed that the corpora were extracted using the tokenizer tool.
Therefore each line should be a JSON string representing a document.
Each document should have a <cite>tokens</cite> attribute.</p>
</div>
</p></li>
<li><p><strong>focus</strong> (<em>None</em><em> or </em><em>str</em><em> or </em><em>list of str</em><em> or </em><em>tuple</em><em> or </em><em>list of tuple</em>) – <p>The tokens for which to compute the document frequency.
If nothing is given, the document frequency is calculated for all tokens.
The tokens can be provided as:</p>
<ul>
<li><p>A single word,</p></li>
<li><p>A list of tokens,</p></li>
<li><p>A tuple, or</p></li>
<li><p>A list of tuples.</p></li>
</ul>
<p>A tuple can be used to compute joint frequencies.</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The number of documents in the given corpora.
If one token or one tuple is given, the number of documents in which the token or tuple appears are returned.
If multiple tokens or tuples are given, a dictionary is given with the separate counts.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>int or dict</p>
</dd>
</dl>
</dd></dl>

<span class="target" id="module-ate.extractor"></span><p>The extractor outlines the functionality that all ATE approaches should offer.
The abstract class is very simple and all extractors must, at least, provide functionality to extract terms from a corpus or corpora.</p>
<dl class="class">
<dt id="ate.extractor.Extractor">
<em class="property">class </em><code class="sig-name descname">Extractor</code><a class="headerlink" href="#ate.extractor.Extractor" title="Permalink to this definition">¶</a></dt>
<dd><p>An abstract class that defines what all ATE extractors should be able to do.
This simple class necessitates only that all extractors accept a corpus or corpora and returns a list of terms.</p>
<dl class="method">
<dt id="ate.extractor.Extractor.extract">
<em class="property">abstract </em><code class="sig-name descname">extract</code><span class="sig-paren">(</span><em class="sig-param">corpora</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.extractor.Extractor.extract" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract terms from the given corpora.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>corpora</strong> (<em>str</em><em> or </em><em>list of str</em>) – A path to a corpus or a list of paths to corpora where to look for terms.
The basic extractor does not place any restrictions of the corpora.
Linguistic or hybrid approaches might need the original text to be available in the corpora.
For statistical approaches, a tokenized corpus might suffice.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A dictionary with terms as keys and their scores as values.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ate.extractor.Extractor.to_list">
<code class="sig-name descname">to_list</code><span class="sig-paren">(</span><em class="sig-param">corpora</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.extractor.Extractor.to_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the given corpora to a list of corpora.
This function can be invoked when the input is either a list or a single path.
If a list of corpora is provided, this function returns the original input.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>corpora</strong> (<em>str</em><em> or </em><em>list of str</em>) – A path to a corpus or paths to corpora.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A list of corpora.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list of str</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="ate.extractor.Extractor.__weakref__">
<code class="sig-name descname">__weakref__</code><a class="headerlink" href="#ate.extractor.Extractor.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ate.extractor.DummyExtractor">
<em class="property">class </em><code class="sig-name descname">DummyExtractor</code><a class="headerlink" href="#ate.extractor.DummyExtractor" title="Permalink to this definition">¶</a></dt>
<dd><p>A dummy extractor that does nothing and returns an empty list of terms.
It is used only for testing purposes.</p>
<dl class="method">
<dt id="ate.extractor.DummyExtractor.extract">
<code class="sig-name descname">extract</code><span class="sig-paren">(</span><em class="sig-param">corpora</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.extractor.DummyExtractor.extract" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an empty list of terms.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>corpora</strong> (<em>str</em><em> or </em><em>list of str</em>) – A path to a corpus or a list of paths to corpora where to look for terms.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An empty list of terms.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list of str</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<div class="section" id="module-ate.linguistic">
<span id="linguistic"></span><h2>Linguistic<a class="headerlink" href="#module-ate.linguistic" title="Permalink to this headline">¶</a></h2>
<p>General functions available to all ATE functions.</p>
<dl class="function">
<dt id="ate.linguistic.vocabulary">
<code class="sig-name descname">vocabulary</code><span class="sig-paren">(</span><em class="sig-param">corpora</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.linguistic.vocabulary" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract the vocabulary from the given corpora.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>corpora</strong> (<em>str</em><em> or </em><em>list of str</em>) – <p>A corpus, or corpora, of documents.
If a string is given, it is assumed to be one corpus.
If a list is given, it is assumed to be a list of corpora.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is assumed that the corpora were extracted using the tokenizer tool.
Therefore each line should be a JSON string representing a document.
Each document should have a <cite>tokens</cite> attribute.</p>
</div>
</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A list of tokens in the corpora.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list of str</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-ate.stat">
<span id="statistical"></span><h2>Statistical<a class="headerlink" href="#module-ate.stat" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-ate.stat.tfidf"></span><p>TF-IDF is a strong and common baseline for ATE tasks.
The approach scores tokens based on their accumulated TF-IDF score.</p>
<dl class="class">
<dt id="ate.stat.tfidf.TFIDFExtractor">
<em class="property">class </em><code class="sig-name descname">TFIDFExtractor</code><span class="sig-paren">(</span><em class="sig-param">scheme</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.stat.tfidf.TFIDFExtractor" title="Permalink to this definition">¶</a></dt>
<dd><p>The TF-IDF extractor uses a TF-IDF scheme to score all tokens in the given corpora.
The class expects tokenized corpora.</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><p><a class="reference internal" href="nlp.html#module-nlp.term_weighting.scheme" title="nlp.term_weighting.scheme"><strong>scheme</strong></a> (<a class="reference internal" href="nlp.html#nlp.term_weighting.tfidf.TFIDF" title="nlp.term_weighting.tfidf.TFIDF"><code class="xref py py-class docutils literal notranslate"><span class="pre">TFIDF</span></code></a>) – The scheme used by the TF-IDF extractor to score tokens.</p>
</dd>
</dl>
<dl class="method">
<dt id="ate.stat.tfidf.TFIDFExtractor.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">scheme</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.stat.tfidf.TFIDFExtractor.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the TF-IDF extractor with the given scheme.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>scheme</strong> (<a class="reference internal" href="nlp.html#nlp.term_weighting.tfidf.TFIDF" title="nlp.term_weighting.tfidf.TFIDF"><code class="xref py py-class docutils literal notranslate"><span class="pre">TFIDF</span></code></a>) – The scheme used by the TF-IDF extractor to score tokens.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ate.stat.tfidf.TFIDFExtractor.extract">
<code class="sig-name descname">extract</code><span class="sig-paren">(</span><em class="sig-param">corpora</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.stat.tfidf.TFIDFExtractor.extract" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract terms from the given corpora.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>corpora</strong> (<em>str</em><em> or </em><em>list of str</em>) – A path to a corpus or a list of paths to corpora where to look for terms.
This extractor expects the corpora to be tokenized.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A dictionary with terms as keys and their scores as values.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-ate.application">
<span id="application"></span><h2>Application<a class="headerlink" href="#module-ate.application" title="Permalink to this headline">¶</a></h2>
<p>Application-based approaches use the target application to learn the domain lexicon.</p>
<span class="target" id="module-ate.application.event"></span><p>Event-based ATE approaches use either event corpora or the output timelines to score and rank domain terms.</p>
<dl class="function">
<dt id="ate.application.event.EF">
<code class="sig-name descname">EF</code><span class="sig-paren">(</span><em class="sig-param">timelines</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.application.event.EF" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the event frequency of terms from the given timelines.
The event frequency is simply the number of events in which term appears in a development.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>timelines</strong> (<em>str</em><em> or </em><em>list of str</em>) – <p>The path to a timeline or a list of paths to timelines.
If a string is given, it is assumed to be one event timeline.
If a list is given, it is assumed to be a list of event timelines.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<dl class="simple">
<dt>It is assumed that the event timelines were extracted using the collection tool.</dt><dd><p>Therefore each file should be a JSON string representing a <a class="reference internal" href="summarization.html#summarization.timeline.timeline.Timeline" title="summarization.timeline.timeline.Timeline"><code class="xref py py-class docutils literal notranslate"><span class="pre">Timeline</span></code></a>.</p>
</dd>
</dl>
</div>
</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A dictionary with terms as keys and their event frequency as the values.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="ate.application.event.logEF">
<code class="sig-name descname">logEF</code><span class="sig-paren">(</span><em class="sig-param">timelines</em>, <em class="sig-param">base=2</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.application.event.logEF" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the logarithmic event frequency of terms from the given timelines.
The event frequency is simply the number of events in which term appears in a development.</p>
<p>This weighting scheme is based on the <a class="reference internal" href="#ate.application.event.EF" title="ate.application.event.EF"><code class="xref py py-func docutils literal notranslate"><span class="pre">EF()</span></code></a> weighting scheme.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>timelines</strong> (<em>str</em><em> or </em><em>list of str</em>) – <p>The path to a timeline or a list of paths to timelines.
If a string is given, it is assumed to be one event timeline.
If a list is given, it is assumed to be a list of event timelines.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<dl class="simple">
<dt>It is assumed that the event timelines were extracted using the collection tool.</dt><dd><p>Therefore each file should be a JSON string representing a <a class="reference internal" href="summarization.html#summarization.timeline.timeline.Timeline" title="summarization.timeline.timeline.Timeline"><code class="xref py py-class docutils literal notranslate"><span class="pre">Timeline</span></code></a>.</p>
</dd>
</dl>
</div>
</p></li>
<li><p><strong>base</strong> (<em>floa</em>) – The logarithmic base.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A dictionary with terms as keys and their event frequency as the values.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="ate.application.event.EFIDF">
<code class="sig-name descname">EFIDF</code><span class="sig-paren">(</span><em class="sig-param">timelines</em>, <em class="sig-param">idf</em>, <em class="sig-param">base=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.application.event.EFIDF" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the event-frequency-inverse-document-frequency metric for terms.
This is a local-global weighting scheme.
The local scheme is the event frequency, and the global scheme is the inverse-document-frequency.
If a logarithmic base is provided, the logarithmic event frequency is used instead.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>timelines</strong> (<em>str</em><em> or </em><em>list of str</em>) – <p>The path to a timeline or a list of paths to timelines.
If a string is given, it is assumed to be one event timeline.
If a list is given, it is assumed to be a list of event timelines.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<dl class="simple">
<dt>It is assumed that the event timelines were extracted using the collection tool.</dt><dd><p>Therefore each file should be a JSON string representing a <a class="reference internal" href="summarization.html#summarization.timeline.timeline.Timeline" title="summarization.timeline.timeline.Timeline"><code class="xref py py-class docutils literal notranslate"><span class="pre">Timeline</span></code></a>.</p>
</dd>
</dl>
</div>
</p></li>
<li><p><strong>idf</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">TFIDF</span></code>) – The IDF table to use to score terms.</p></li>
<li><p><strong>base</strong> (<em>floa</em>) – The logarithmic base.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A dictionary with terms as keys and their EF-IDF score as the values.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="ate.application.event.variability">
<code class="sig-name descname">variability</code><span class="sig-paren">(</span><em class="sig-param">term</em>, <em class="sig-param">idfs</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.application.event.variability" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate how variable the term is across events.
A term is highly-variable if it appears disproportionately in one or a few events.
A low variability indicates that the term appears consistently across all events.</p>
<p>The method follows the leave-one-out principle: each event is compared against all other events.
The final result is an average weightg according to the event sizes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>term</strong> (<em>str</em>) – The term for which to calculate the variability.</p></li>
<li><p><strong>idfs</strong> (list of <a class="reference internal" href="nlp.html#nlp.term_weighting.tfidf.TFIDF" title="nlp.term_weighting.tfidf.TFIDF"><code class="xref py py-class docutils literal notranslate"><span class="pre">TFIDF</span></code></a>) – A list of IDFs, one for each event.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The variability of the term.
A term is highly-variable if it appears disproportionately in one or a few events.
A low variability indicates that the term appears consistently across all events.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="ate.application.event._variability_contingency_table">
<code class="sig-name descname">_variability_contingency_table</code><span class="sig-paren">(</span><em class="sig-param">term</em>, <em class="sig-param">current</em>, <em class="sig-param">comparison</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.application.event._variability_contingency_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the contingency table comparing the term’s appearance in the current event versus other events.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>term</strong> (<em>str</em>) – The term for which to create the contingency table.</p></li>
<li><p><strong>current</strong> (<a class="reference internal" href="nlp.html#nlp.term_weighting.tfidf.TFIDF" title="nlp.term_weighting.tfidf.TFIDF"><code class="xref py py-class docutils literal notranslate"><span class="pre">TFIDF</span></code></a>) – The current event’s IDF table.</p></li>
<li><p><strong>comparison</strong> (list of <a class="reference internal" href="nlp.html#nlp.term_weighting.tfidf.TFIDF" title="nlp.term_weighting.tfidf.TFIDF"><code class="xref py py-class docutils literal notranslate"><span class="pre">TFIDF</span></code></a>) – A list of IDFs, one for each event.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The contingency table for the term, contrasting the current event with all other events.
The first row is the total number of documents in the current event.
The second row is the total number of documents in the comparison events.
The totals of both rows sum up to the total number of documents.
The contingency table is returned as a tuple with four floats.
These correspond to the first and second rows respectively.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple of float</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-ate.bootstrapping">
<span id="bootstrapping"></span><h2>Bootstrapping<a class="headerlink" href="#module-ate.bootstrapping" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-ate.bootstrapping.probability">
<span id="probability"></span><h3>Probability<a class="headerlink" href="#module-ate.bootstrapping.probability" title="Permalink to this headline">¶</a></h3>
<p>Methods that evaluate unithood or termhood based on probability.</p>
<dl class="function">
<dt id="ate.bootstrapping.probability.p">
<code class="sig-name descname">p</code><span class="sig-paren">(</span><em class="sig-param">corpora</em>, <em class="sig-param">focus=None</em>, <em class="sig-param">cache=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.bootstrapping.probability.p" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the probability of tokens appearing in the corpus.
The probability is computed in terms of all tokens.</p>
<p>Apart from calculating the probability of single tokens, the joint probability can be calculated by providing tuples.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The joint probability is the minimum count of any token in the joint set in each document.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>corpora</strong> (<em>str</em><em> or </em><em>list of str</em>) – <p>A corpus, or corpora, of documents.
If a string is given, it is assumed to be one corpus.
If a list is given, it is assumed to be a list of corpora.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is assumed that the corpora were extracted using the tokenizer tool.
Therefore each line should be a JSON string representing a document.
Each document should have a <cite>tokens</cite> attribute.</p>
</div>
</p></li>
<li><p><strong>focus</strong> (<em>None</em><em> or </em><em>str</em><em> or </em><em>list of str</em><em> or </em><em>tuple</em><em> or </em><em>list of tuple</em>) – <p>The tokens for which to compute the probability.
If nothing is given, the probability is calculated for all tokens.
The tokens can be provided as:</p>
<ul>
<li><p>A single word,</p></li>
<li><p>A list of tokens,</p></li>
<li><p>A tuple, or</p></li>
<li><p>A list of tuples.</p></li>
</ul>
<p>A tuple can be used to compute joint probabilities.</p>
</p></li>
<li><p><strong>cache</strong> (<em>list of str</em>) – <p>A list of terms that are re-used often and which should be cached.
If an empty list is given, no cache is used.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Cache should be used when there is a lot of repetition.
For example, <cite>x</cite> can be used as cache when <cite>x</cite> is small and <cite>y</cite> is large.
If the data is small, using cache can be detrimental.</p>
</div>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A dictionary with tokens as keys and probabilities as values.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="ate.bootstrapping.probability.PMI">
<code class="sig-name descname">PMI</code><span class="sig-paren">(</span><em class="sig-param">corpora</em>, <em class="sig-param">x</em>, <em class="sig-param">y</em>, <em class="sig-param">base=2</em>, <em class="sig-param">cache=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.bootstrapping.probability.PMI" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the Pointwise Mutual-Information (PMI) between two variables.
PMI is symmetric and computed as:</p>
<div class="math notranslate nohighlight">
\[PMI(x,y) = \log( \frac{p(x,y)}{p(x)p(y)} )\]</div>
<p>The function accepts multiple values for both variables, and returns the PMI separately.
The return value is a dictionary, where the keys are the cross product between <cite>x</cite> and <cite>y</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>corpora</strong> (<em>str</em><em> or </em><em>list of str</em>) – <p>A corpus, or corpora, of documents.
If a string is given, it is assumed to be one corpus.
If a list is given, it is assumed to be a list of corpora.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is assumed that the corpora were extracted using the tokenizer tool.
Therefore each line should be a JSON string representing a document.
Each document should have a <cite>tokens</cite> attribute.</p>
</div>
</p></li>
<li><p><strong>x</strong> (<em>str</em><em> or </em><em>list of str</em><em> or </em><em>tuple</em><em> or </em><em>list of tuple</em>) – <p>The tokens for which to compute the probability.
These tokens are combined as a cross-product with all tokens in <cite>y</cite>.
The tokens can be provided as:</p>
<ul>
<li><p>A single word,</p></li>
<li><p>A list of tokens,</p></li>
<li><p>A tuple, or</p></li>
<li><p>A list of tuples.</p></li>
</ul>
<p>A tuple translates to joint probabilities.
If nothing is given, it is replaced with the corpora’s vocabulary.</p>
</p></li>
<li><p><strong>y</strong> (<em>str</em><em> or </em><em>list of str</em><em> or </em><em>tuple</em><em> or </em><em>list of tuple</em>) – <p>The tokens for which to compute the probability.
These tokens are combined as a cross-product with all tokens in <cite>x</cite>.
The tokens can be provided as:</p>
<ul>
<li><p>A single word,</p></li>
<li><p>A list of tokens,</p></li>
<li><p>A tuple, or</p></li>
<li><p>A list of tuples.</p></li>
</ul>
<p>A tuple translates to joint probabilities.
If nothing is given, it is replaced with the corpora’s vocabulary.</p>
</p></li>
<li><p><strong>base</strong> (<em>float</em>) – The base of the logarithm, defaults to 2.</p></li>
<li><p><strong>cache</strong> (<em>list of str</em>) – <p>A list of terms that are re-used often and which should be cached.
If an empty list is given, no cache is used.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Cache should be used when there is a lot of repetition.
For example, <cite>x</cite> can be used as cache when <cite>x</cite> is small and <cite>y</cite> is large.
If the data is small, using cache can be detrimental.</p>
</div>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A dictionary with pairs of <cite>x</cite> and <cite>y</cite> variables as keys, and their PMi as values.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="ate.bootstrapping.probability._pmi">
<code class="sig-name descname">_pmi</code><span class="sig-paren">(</span><em class="sig-param">prob</em>, <em class="sig-param">x</em>, <em class="sig-param">y</em>, <em class="sig-param">base</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.bootstrapping.probability._pmi" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the Pointwise Mutual Information (PMI) of <cite>x</cite> and <cite>y</cite> based on the given probabilities.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>prob</strong> (<em>dict</em>) – A probability calculation, possibly calculated using the <code class="xref py py-func docutils literal notranslate"><span class="pre">ate.stat.probability.p()</span></code> function.
This is used as cache for the probabilities.
The keys are the tokens, including the joint probability of <cite>x</cite> and <cite>y</cite>, and the values are their probabilities.</p></li>
<li><p><strong>x</strong> (<em>str</em><em> or </em><em>tuple of str</em>) – The first token or tuple of tokens to use to calculate the PMI.</p></li>
<li><p><strong>y</strong> (<em>str</em><em> or </em><em>tuple of str</em>) – The second token or tuple of tokens to use to calculate the PMI.</p></li>
<li><p><strong>base</strong> (<em>float</em>) – The base of the logarithm, defaults to 2.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The PMI of <cite>x</cite> and <cite>y</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="ate.bootstrapping.probability.CHI">
<code class="sig-name descname">CHI</code><span class="sig-paren">(</span><em class="sig-param">corpora</em>, <em class="sig-param">x</em>, <em class="sig-param">y</em>, <em class="sig-param">cache=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.bootstrapping.probability.CHI" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the chi-square statistic on the given corpora for the two given tokens.
The statistic is based on how many documents tokens co-occur in.
The order of the two tokens does not matter since the chi-square statistic is symmetric.</p>
<p>All the tokens in <cite>x</cite> are matched with all tokens in <cite>y</cite> in a cross-product fashion.
The chi-square statistic is computed for each such pair (one token in <cite>x</cite>, one token in <cite>y</cite>).</p>
<p>The chi-square statistic is 0 if the two variables are independent.
The higher the statistic, the more dependent the two variables are.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>corpora</strong> (<em>str</em><em> or </em><em>list of str</em>) – <p>A corpus, or corpora, of documents.
If a string is given, it is assumed to be one corpus.
If a list is given, it is assumed to be a list of corpora.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is assumed that the corpora were extracted using the tokenizer tool.
Therefore each line should be a JSON string representing a document.
Each document should have a <cite>tokens</cite> attribute.</p>
</div>
</p></li>
<li><p><strong>x</strong> (<em>str</em><em> or </em><em>list of str</em>) – The first token or list of tokens in the comparison.
Alternatively, a list of tokens can be provided.
This is more efficient because it can allow caching.</p></li>
<li><p><strong>y</strong> (<em>str</em><em> or </em><em>list of str</em>) – The second token or list of tokens in the comparison.
Alternatively, a list of tokens can be provided.
This is more efficient because it can allow caching.</p></li>
<li><p><strong>cache</strong> (<em>list of str</em>) – <p>A list of terms that are re-used often and which should be cached.
If an empty list is given, no cache is used.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Cache should be used when there is a lot of repetition.
For example, <cite>x</cite> can be used as cache when <cite>x</cite> is small and <cite>y</cite> is large.
If the data is small, using cache can be detrimental.</p>
</div>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The chi-square statistic for all pairs of x and y as a dictionary.
The keys are the pairs, and the values the chi-square statistic.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="ate.bootstrapping.probability._contingency_table">
<code class="sig-name descname">_contingency_table</code><span class="sig-paren">(</span><em class="sig-param">corpora</em>, <em class="sig-param">x</em>, <em class="sig-param">y</em>, <em class="sig-param">cache=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.bootstrapping.probability._contingency_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the contingency tables for all the pairs of tokens in <cite>x</cite> and <cite>y</cite>.
All the tokens in <cite>x</cite> are matched with all tokens in <cite>y</cite> in a cross-product fashion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>corpora</strong> (<em>list of str</em>) – <p>The list of corpora to use to create the contingency table.
.. note:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>It is assumed that the corpora were extracted using the tokenizer tool.
Therefore each line should be a JSON string representing a document.
Each document should have a `tokens` attribute.
</pre></div>
</div>
</p></li>
<li><p><strong>x</strong> (<em>list of str</em>) – The first list of tokens to use to create the contingency tables.</p></li>
<li><p><strong>y</strong> (<em>list of str</em>) – The second list of tokens to use to create the contingency tables.</p></li>
<li><p><strong>cache</strong> (<em>list of str</em>) – <p>A list of terms that are re-used often and which should be cached.
If an empty list is given, no cache is used.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Cache should be used when there is a lot of repetition.
For example, <cite>x</cite> can be used as cache when <cite>x</cite> is small and <cite>y</cite> is large.
If the data is small, using cache can be detrimental.</p>
</div>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>A dictionary of contingency tables.
The keys are the pairs of the tokens.
The values are four-tuples representing the values of cells in the order:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Top-left,</p></li>
<li><p>Top-right,</p></li>
<li><p>Bottom-left, and</p></li>
<li><p>Bottom-right.</p></li>
</ol>
</div></blockquote>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="ate.bootstrapping.probability._chi">
<code class="sig-name descname">_chi</code><span class="sig-paren">(</span><em class="sig-param">table</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.bootstrapping.probability._chi" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the chi-square statistic from the given table.
The chi-square statistic is 0 if the two variables are independent.
The higher the statistic, the more dependent the two variables are.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>table</strong> (<em>tuple of int</em>) – <p>The contingency table as a four-tuple.
The values are four-tuples representing the values of cells in the order:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Top-left,</p></li>
<li><p>Top-right,</p></li>
<li><p>Bottom-left, and</p></li>
<li><p>Bottom-right.</p></li>
</ol>
</div></blockquote>
</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The chi-square statistic.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="ate.bootstrapping.probability._cache">
<code class="sig-name descname">_cache</code><span class="sig-paren">(</span><em class="sig-param">corpora</em>, <em class="sig-param">token</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.bootstrapping.probability._cache" title="Permalink to this definition">¶</a></dt>
<dd><p>Compile all the documents in the given corpora that mention the token.
These documents can be used as cache.
In this way, the files do not have to be re-opened and documents without the token do not have to be iterated over.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>corpora</strong> (<em>str</em><em> or </em><em>list of str</em>) – <p>A corpus, or corpora, of documents.
If a string is given, it is assumed to be one corpus.
If a list is given, it is assumed to be a list of corpora.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is assumed that the corpora were extracted using the tokenizer tool.
Therefore each line should be a JSON string representing a document.
Each document should have a <cite>tokens</cite> attribute.</p>
</div>
</p></li>
<li><p><strong>token</strong> (<em>str</em>) – The token to look for in the documents.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A list of documents, each represented as a dictionary, that contain the given token.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list of dict</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="ate.bootstrapping.probability.joint_vocabulary">
<code class="sig-name descname">joint_vocabulary</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">y</em><span class="sig-paren">)</span><a class="headerlink" href="#ate.bootstrapping.probability.joint_vocabulary" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the joint vocabulary by creating the cross-product from <cite>x</cite> and <cite>y</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>str</em><em> or </em><em>list of str</em><em> or </em><em>tuple</em><em> or </em><em>list of tuple</em>) – <p>The tokens for which to compute the probability.
These tokens are combined as a cross-product with all tokens in <cite>y</cite>.
The tokens can be provided as:</p>
<ul>
<li><p>A single word,</p></li>
<li><p>A list of tokens,</p></li>
<li><p>A tuple, or</p></li>
<li><p>A list of tuples.</p></li>
</ul>
<p>A tuple translates to joint probabilities.</p>
</p></li>
<li><p><strong>y</strong> (<em>str</em><em> or </em><em>list of str</em><em> or </em><em>tuple</em><em> or </em><em>list of tuple</em>) – <p>The tokens for which to compute the probability.
These tokens are combined as a cross-product with all tokens in <cite>x</cite>.
The tokens can be provided as:</p>
<ul>
<li><p>A single word,</p></li>
<li><p>A list of tokens,</p></li>
<li><p>A tuple, or</p></li>
<li><p>A list of tuples.</p></li>
</ul>
<p>A tuple translates to joint probabilities.</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The joint vocabulary, which is the cross-product of each item in <cite>x</cite> with each item in <cite>y</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list of tuple</p>
</dd>
</dl>
</dd></dl>

</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="other.html" class="btn btn-neutral float-right" title="12. Other" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="ml.html" class="btn btn-neutral float-left" title="10. Machine Learning" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Nicholas Mamo

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>