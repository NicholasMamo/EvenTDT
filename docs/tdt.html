

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta content="The Topic Detection and Tracking (TDT) implementation" name="description" />
<meta content="Python, TDT" name="keywords" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>6. Topic Detection and Tracking (TDT) &mdash; EvenTDT 0.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/eventdt.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="7. Summarization" href="summarization.html" />
    <link rel="prev" title="5. Automatic Participant Detection (APD)" href="apd.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> EvenTDT
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="config.html">0. Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="tools.html">1. Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="vsm.html">2. Vector Space Model (VSM)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nlp.html">3. Natural Language Processing (NLP)</a></li>
<li class="toctree-l1"><a class="reference internal" href="wikinterface.html">4. Wikinterface</a></li>
<li class="toctree-l1"><a class="reference internal" href="apd.html">5. Automatic Participant Detection (APD)</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">6. Topic Detection and Tracking (TDT)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-tdt.nutrition">Nutrition Stores</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-tdt.nutrition.memory">Memory Nutrition Store</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-tdt.algorithms">Algorithms</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-tdt.algorithms.zhao">Zhao et al. (2011)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-tdt.algorithms.cataldi">Cataldi et al. (2014)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-tdt.algorithms.eld">ELD - Mamo et al. (2019)</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="summarization.html">7. Summarization</a></li>
<li class="toctree-l1"><a class="reference internal" href="twitter.html">8. Twitter</a></li>
<li class="toctree-l1"><a class="reference internal" href="consumers.html">9. Consumers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ml.html">10. Machine Learning</a></li>
<li class="toctree-l1"><a class="reference internal" href="ate.html">11. Automatic Term Extraction (ATE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="other.html">12. Other</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">EvenTDT</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>6. Topic Detection and Tracking (TDT)</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/tdt.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
    <div class="section" id="topic-detection-and-tracking-tdt">
<h1>6. Topic Detection and Tracking (TDT)<a class="headerlink" href="#topic-detection-and-tracking-tdt" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-tdt"><span id="tdt"></span></span><p>The Topic Detection and Tracking (TDT) package is one of the most important parts of EvenTDT.
This package makes it easier to implement new TDT algorithms or to use existing ones.
It achieves this by providing:</p>
<ol class="arabic simple">
<li><p>Tools to help you implement new algorithms, such as the <code class="xref py py-class docutils literal notranslate"><span class="pre">NutritionStore</span></code>; and</p></li>
<li><p>A uniform interface for TDT algorithms in <a class="reference internal" href="#tdt.algorithms.TDTAlgorithm" title="tdt.algorithms.TDTAlgorithm"><code class="xref py py-class docutils literal notranslate"><span class="pre">TDTAlgorithm</span></code></a>.</p></li>
</ol>
<div class="section" id="module-tdt.nutrition">
<span id="nutrition-stores"></span><h2>Nutrition Stores<a class="headerlink" href="#module-tdt.nutrition" title="Permalink to this headline">¶</a></h2>
<p>The concept of nutrition was used predominantly by <a class="reference external" href="https://dl.acm.org/doi/abs/10.1145/2542182.2542189">Cataldi et al.</a>.
Later, it was adopted by in several papers, such as in <a class="reference external" href="https://link.springer.com/chapter/10.1007/978-3-319-74497-1_3">FIRE</a> and <a class="reference external" href="https://dl.acm.org/doi/abs/10.1145/3342220.3344921">ELD</a>.</p>
<p>Nutrition is most common in feature-pivot techniques as it is a general way of measuring the importance of features.
For example, <a class="reference external" href="https://dl.acm.org/doi/abs/10.1145/2542182.2542189">Cataldi et al.</a> used it to measure the popularity of a term.
Even when the term <cite>nutrition</cite> is not used, the importance of terms can be thought of as nutrition.</p>
<p>Nutrition is important because it often fuels another TDT metrid: burst.
Burst, introduced by <a class="reference external" href="https://link.springer.com/article/10.1023/A:1024940629314">Kleinberg</a>, measures the change in nutrition to find spikes in the use of terms, for example.
More generally, burst tries to identify a change in behavior, which may also be a sharp increase in tweeting volume.</p>
<p>The <a class="reference internal" href="#tdt.nutrition.NutritionStore" title="tdt.nutrition.NutritionStore"><code class="xref py py-class docutils literal notranslate"><span class="pre">NutritionStore</span></code></a> is meant to be an interface for any data structure that stores nutrition.
The interface contains the methods that all stores must implement.
For example, implementations can store data in a database or in memory.</p>
<p>All nutrition stores separate nutrition based on timestamps, which can represent, among others:</p>
<ul class="simple">
<li><p>The nutrition data at that particular timestamp, or</p></li>
<li><p>The nutrition data during a period of time represented by that timestamp.</p></li>
</ul>
<dl class="class">
<dt id="tdt.nutrition.NutritionStore">
<em class="property">class </em><code class="sig-name descname">NutritionStore</code><a class="headerlink" href="#tdt.nutrition.NutritionStore" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#tdt.nutrition.NutritionStore" title="tdt.nutrition.NutritionStore"><code class="xref py py-class docutils literal notranslate"><span class="pre">NutritionStore</span></code></a> base class does not make any assumptions about where the nutrition data is stored.
However, it defines a set of functions that need to be implemented.
In that way, all derived classes share a similar interface.</p>
<p>The nutrition store provides functions that cover not just storage, but also retrieval.
A common theme across all nutrition store instances is that they separate nutrition data into timestamps.
Timestamps can represent either a particular instance of time, or a period of time.
This depends on the application, and is not a feature of the nutrition store.</p>
<dl class="method">
<dt id="tdt.nutrition.NutritionStore.__init__">
<em class="property">abstract </em><code class="sig-name descname">__init__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tdt.nutrition.NutritionStore.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the nutrition store.
All nutrition stores use this function to initialize the storage or their connections to it.</p>
</dd></dl>

<dl class="method">
<dt id="tdt.nutrition.NutritionStore.add">
<em class="property">abstract </em><code class="sig-name descname">add</code><span class="sig-paren">(</span><em class="sig-param">timestamp</em>, <em class="sig-param">nutrition</em><span class="sig-paren">)</span><a class="headerlink" href="#tdt.nutrition.NutritionStore.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a nutrition data to the store at the given timestamp.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This function overwrites any data at the given timestamp.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>timestamp</strong> (<em>float</em><em> or </em><em>int</em>) – The timestamp of the nutrition data.</p></li>
<li><p><strong>nutrition</strong> (<em>any</em>) – The nutrition data to add.
The nutrition data can be any value.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tdt.nutrition.NutritionStore.get">
<em class="property">abstract </em><code class="sig-name descname">get</code><span class="sig-paren">(</span><em class="sig-param">timestmap</em><span class="sig-paren">)</span><a class="headerlink" href="#tdt.nutrition.NutritionStore.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the nutrition data at the given timestamp.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>timestamp</strong> (<em>float</em><em> or </em><em>int</em>) – The timestamp whose nutrition is to be returned.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The nutrition at the given timestamp.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>any</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tdt.nutrition.NutritionStore.all">
<em class="property">abstract </em><code class="sig-name descname">all</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tdt.nutrition.NutritionStore.all" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all the nutrition data.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>All the nutrition data in the nutrition store as a dictionary.
The keys are the timestamps, and the values are the nutrition data at those timestamps.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tdt.nutrition.NutritionStore.between">
<em class="property">abstract </em><code class="sig-name descname">between</code><span class="sig-paren">(</span><em class="sig-param">start</em>, <em class="sig-param">end</em><span class="sig-paren">)</span><a class="headerlink" href="#tdt.nutrition.NutritionStore.between" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the nutrition data between the given timestamps.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The start timestamp is inclusive, the end timestamp is exclusive.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>start</strong> (<em>float</em><em> or </em><em>int</em>) – The first timestamp that should be included in the returned nutrition data.
If no time window with the given timestamp exists, all returned time windows succeed it.</p></li>
<li><p><strong>end</strong> (<em>float</em><em> or </em><em>int</em>) – All the nutrition data from the beginning until the given timestamp.
Any nutrition data at the end timestamp is not returned.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>All the nutrition data between the given timestamps.
The start timestamp is inclusive, the end timestamp is exclusive.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tdt.nutrition.NutritionStore.since">
<code class="sig-name descname">since</code><span class="sig-paren">(</span><em class="sig-param">start</em><span class="sig-paren">)</span><a class="headerlink" href="#tdt.nutrition.NutritionStore.since" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the nutrition data since the given timestamp.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The start timestamp is inclusive.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>start</strong> (<em>float</em><em> or </em><em>int</em>) – The first timestamp that should be included in the returned nutrition data.
If no time window with the given timestamp exists, all returned time windows succeed it.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>All the nutrition data from the given timestamp onward.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tdt.nutrition.NutritionStore.until">
<code class="sig-name descname">until</code><span class="sig-paren">(</span><em class="sig-param">end</em><span class="sig-paren">)</span><a class="headerlink" href="#tdt.nutrition.NutritionStore.until" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a list of nutrition sets that came before the given timestamp.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The end timestamp is exclusive.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>end</strong> (<em>float</em><em> or </em><em>int</em>) – The timestamp before which nutrition data should be returned.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>All the nutrition data from the beginning until the given timestamp.
Any nutrition data at the end timestamp is not returned.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tdt.nutrition.NutritionStore.remove">
<em class="property">abstract </em><code class="sig-name descname">remove</code><span class="sig-paren">(</span><em class="sig-param">*args</em><span class="sig-paren">)</span><a class="headerlink" href="#tdt.nutrition.NutritionStore.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove nutrition data from the given list of timestamps.
The timestamps should be given as arguments.</p>
</dd></dl>

<dl class="method">
<dt id="tdt.nutrition.NutritionStore.copy">
<em class="property">abstract </em><code class="sig-name descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tdt.nutrition.NutritionStore.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the nutrition store.
The copy is a deep copy.
This means that all changes to the copy do not affect the original.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A copy of the nutrition store.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">NutritionStore</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="tdt.nutrition.NutritionStore.__weakref__">
<code class="sig-name descname">__weakref__</code><a class="headerlink" href="#tdt.nutrition.NutritionStore.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

</dd></dl>

<div class="section" id="module-tdt.nutrition.memory">
<span id="memory-nutrition-store"></span><h3>Memory Nutrition Store<a class="headerlink" href="#module-tdt.nutrition.memory" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="#tdt.nutrition.memory.MemoryNutritionStore" title="tdt.nutrition.memory.MemoryNutritionStore"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemoryNutritionStore</span></code></a> stores data in a Python dictionary in memory.
This store is simple and efficient because there is little overhead, unlike when connecting to a database, for example.
However, since all of the nutrition data is stored in memory, you need to pay attention to the <a class="reference internal" href="#tdt.nutrition.memory.MemoryNutritionStore" title="tdt.nutrition.memory.MemoryNutritionStore"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemoryNutritionStore</span></code></a>’s blueprint.
Like all <a class="reference internal" href="#tdt.nutrition.NutritionStore" title="tdt.nutrition.NutritionStore"><code class="xref py py-class docutils literal notranslate"><span class="pre">NutritionStore</span></code></a> instances, you can clear out old data to keep the memory requirements in check.</p>
<dl class="class">
<dt id="tdt.nutrition.memory.MemoryNutritionStore">
<em class="property">class </em><code class="sig-name descname">MemoryNutritionStore</code><a class="headerlink" href="#tdt.nutrition.memory.MemoryNutritionStore" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#tdt.nutrition.memory.MemoryNutritionStore" title="tdt.nutrition.memory.MemoryNutritionStore"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemoryNutritionStore</span></code></a> stores data in a Python dictionary.
The keys are the timestamps, and the value is the nutrition data at that timestamp.</p>
<p>The nutrition data can be several things:</p>
<ul class="simple">
<li><p>If nutrition represents the overall volume, the nutrition data can be an integer representing the number of documents observed at that timestamp.</p></li>
<li><p>If nutrition represents the number of times a term appears, the nutrition data can be a dictionary, with terms as keys and their frequency as the corresponding values.</p></li>
</ul>
<p>In addition, the <a class="reference internal" href="#tdt.nutrition.memory.MemoryNutritionStore" title="tdt.nutrition.memory.MemoryNutritionStore"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemoryNutritionStore</span></code></a> does not impose any restrictions on the nutrition data.
It can represent objects and different timestamps can have different data types.</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><p><strong>store</strong> (<em>dict</em>) – The nutrition store as a dictionary.
The keys are the timestamps, and the values are the nutrition data.
The nutrition data can be any value.</p>
</dd>
</dl>
<dl class="method">
<dt id="tdt.nutrition.memory.MemoryNutritionStore.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tdt.nutrition.memory.MemoryNutritionStore.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the nutrition store as a dictionary.</p>
</dd></dl>

<dl class="method">
<dt id="tdt.nutrition.memory.MemoryNutritionStore.add">
<code class="sig-name descname">add</code><span class="sig-paren">(</span><em class="sig-param">timestamp</em>, <em class="sig-param">nutrition</em><span class="sig-paren">)</span><a class="headerlink" href="#tdt.nutrition.memory.MemoryNutritionStore.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a nutrition data to the store at the given timestamp.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This function overwrites any data at the given timestamp.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>timestamp</strong> (<em>float</em><em> or </em><em>int</em>) – The timestamp of the nutrition data.</p></li>
<li><p><strong>nutrition</strong> (<em>any</em>) – The nutrition data to add.
The nutrition data can be any value.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tdt.nutrition.memory.MemoryNutritionStore.get">
<code class="sig-name descname">get</code><span class="sig-paren">(</span><em class="sig-param">timestamp</em><span class="sig-paren">)</span><a class="headerlink" href="#tdt.nutrition.memory.MemoryNutritionStore.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the nutrition data at the given timestamp.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>timestamp</strong> (<em>float</em><em> or </em><em>int</em>) – The timestamp whose nutrition is to be returned.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The nutrition at the given timestamp.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>any</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tdt.nutrition.memory.MemoryNutritionStore.all">
<code class="sig-name descname">all</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tdt.nutrition.memory.MemoryNutritionStore.all" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all the nutrition data.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>All the nutrition data in the nutrition store as a dictionary.
The keys are the timestamps, and the values are the nutrition data at those timestamps.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tdt.nutrition.memory.MemoryNutritionStore.between">
<code class="sig-name descname">between</code><span class="sig-paren">(</span><em class="sig-param">start</em>, <em class="sig-param">end</em><span class="sig-paren">)</span><a class="headerlink" href="#tdt.nutrition.memory.MemoryNutritionStore.between" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the nutrition data between the given timestamps.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The start timestamp is inclusive, the end timestamp is exclusive.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>start</strong> (<em>float</em><em> or </em><em>int</em>) – The first timestamp that should be included in the returned nutrition data.
If no time window with the given timestamp exists, all returned time windows succeed it.</p></li>
<li><p><strong>end</strong> (<em>float</em><em> or </em><em>int</em>) – All the nutrition data from the beginning until the given timestamp.
Any nutrition data at the end timestamp is not returned.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>All the nutrition data between the given timestamps.
The start timestamp is inclusive, the end timestamp is exclusive.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – When the start timestamp is on or after the end timestamp.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tdt.nutrition.memory.MemoryNutritionStore.remove">
<code class="sig-name descname">remove</code><span class="sig-paren">(</span><em class="sig-param">*args</em><span class="sig-paren">)</span><a class="headerlink" href="#tdt.nutrition.memory.MemoryNutritionStore.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove nutrition data from the given list of timestamps.
The timestamps should be given as arguments.</p>
</dd></dl>

<dl class="method">
<dt id="tdt.nutrition.memory.MemoryNutritionStore.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tdt.nutrition.memory.MemoryNutritionStore.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the nutrition store.
The copy is a deep copy.
This means that all changes to the copy do not affect the original.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A copy of the nutrition store.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#tdt.nutrition.memory.MemoryNutritionStore" title="tdt.nutrition.memory.MemoryNutritionStore"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemoryNutritionStore</span></code></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="module-tdt.algorithms">
<span id="algorithms"></span><span id="tdt-algorithms"></span><h2>Algorithms<a class="headerlink" href="#module-tdt.algorithms" title="Permalink to this headline">¶</a></h2>
<p>TDT algorithms are split broadly into document-pivot and feature-pivot techniques:</p>
<ul class="simple">
<li><p>Document-pivot approaches use clustering to identify <cite>what</cite> is being discussed (read more <a class="reference external" href="https://nyphoon.com/2020/07/27/document-pivot-methods-whats-happening/">here</a>), and</p></li>
<li><p>Feature-pivot approaches identify <cite>how</cite> people are talking (read more <a class="reference external" href="https://nyphoon.com/2020/08/06/feature-pivot-methods-did-something-happen/">here</a>).</p></li>
</ul>
<p>Since TDT approaches are so broad by nature, it is difficult to find a general pattern.
However, all algorithms must have a mechanism to detect topics from a specific type input.
This functionality is encapsulated in the <a class="reference internal" href="#tdt.algorithms.TDTAlgorithm" title="tdt.algorithms.TDTAlgorithm"><code class="xref py py-class docutils literal notranslate"><span class="pre">TDTAlgorithm</span></code></a>, which specifies only a <a class="reference internal" href="#tdt.algorithms.TDTAlgorithm.detect" title="tdt.algorithms.TDTAlgorithm.detect"><code class="xref py py-func docutils literal notranslate"><span class="pre">detect()</span></code></a> method.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Most TDT algorithms have a detection stage and a summarization stage.
EvenTDT separates the two into:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#tdt.algorithms.TDTAlgorithm" title="tdt.algorithms.TDTAlgorithm"><code class="xref py py-class docutils literal notranslate"><span class="pre">TDTAlgorithm</span></code></a> and</p></li>
<li><p><a class="reference internal" href="summarization.html#summarization.algorithms.SummarizationAlgorithm" title="summarization.algorithms.SummarizationAlgorithm"><code class="xref py py-class docutils literal notranslate"><span class="pre">SummarizationAlgorithm</span></code></a>.</p></li>
</ul>
<p>The reason why EvenTDT enforces this separation is that the two approaches tackle vastly different problems.
Well-designed approaches delineate the separation between the two.
If the <a class="reference internal" href="#tdt.algorithms.TDTAlgorithm" title="tdt.algorithms.TDTAlgorithm"><code class="xref py py-class docutils literal notranslate"><span class="pre">TDTAlgorithm</span></code></a> is meant to work closely together with the <a class="reference internal" href="summarization.html#summarization.algorithms.SummarizationAlgorithm" title="summarization.algorithms.SummarizationAlgorithm"><code class="xref py py-class docutils literal notranslate"><span class="pre">SummarizationAlgorithm</span></code></a>, then its output needs to be compatible with the summarization algorithm.</p>
</div>
<dl class="class">
<dt id="tdt.algorithms.TDTAlgorithm">
<em class="property">class </em><code class="sig-name descname">TDTAlgorithm</code><a class="headerlink" href="#tdt.algorithms.TDTAlgorithm" title="Permalink to this definition">¶</a></dt>
<dd><p>Since TDT algorithms vary greatly, there is no general state.
The <a class="reference internal" href="#tdt.algorithms.TDTAlgorithm" title="tdt.algorithms.TDTAlgorithm"><code class="xref py py-class docutils literal notranslate"><span class="pre">TDTAlgorithm</span></code></a>’s purpose is to create a standard interface to TDT algorithms.
Although the state and the parameters change from one algorithm to the other, all of them must implement the <a class="reference internal" href="#tdt.algorithms.TDTAlgorithm.detect" title="tdt.algorithms.TDTAlgorithm.detect"><code class="xref py py-func docutils literal notranslate"><span class="pre">detect()</span></code></a> method.</p>
<dl class="method">
<dt id="tdt.algorithms.TDTAlgorithm.detect">
<em class="property">abstract </em><code class="sig-name descname">detect</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#tdt.algorithms.TDTAlgorithm.detect" title="Permalink to this definition">¶</a></dt>
<dd><p>Detect breaking topics.
The parameters accepted by this function as well as the return value change according to the algorithm.</p>
</dd></dl>

<dl class="attribute">
<dt id="tdt.algorithms.TDTAlgorithm.__weakref__">
<code class="sig-name descname">__weakref__</code><a class="headerlink" href="#tdt.algorithms.TDTAlgorithm.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

</dd></dl>

<div class="section" id="module-tdt.algorithms.zhao">
<span id="zhao-et-al-2011"></span><h3>Zhao et al. (2011)<a class="headerlink" href="#module-tdt.algorithms.zhao" title="Permalink to this headline">¶</a></h3>
<p>Zhao et al.’s algorithm is the first algorithm to be deployed over specified events on Twitter.
This approach looks for spikes in the overall tweeting volume in the most recent time window.</p>
<p>To identify these spikes, the approach splits time windows of increasing length into two.
If the second half has a marked increase in volume the algorithm identifies the second half as a topic.
The decision of whether something happened is based on a ratio, taken to be 1.7 in the original paper.
In practice, this means that if the second half of a time-window has 70% more tweets than the first half, then it represents a topic.</p>
<p>The time window starts at 10 seconds and changes dynamically.
If the increase is not significant, then the time window is progressively increased to 20 seconds, 30 seconds and, finally, 60 seconds.
If none of these time windows report a large enough increase, then the algorithm detects no topic.</p>
<p>The algorithm is very efficient and is suitable to run in real-time.
However, since it works only using the overall tweeting volume, it can only detect whether something happened.
It cannot explain what happened, or what the most important features are.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This implementation is based on the algorithm presented in <a class="reference external" href="https://arxiv.org/abs/1106.4300">Human as Real-Time Sensors of Social and Physical Events: A Case Study of Twitter and Sports Games by Zhao et al. (2011)</a>.</p>
</div>
<dl class="class">
<dt id="tdt.algorithms.zhao.Zhao">
<em class="property">class </em><code class="sig-name descname">Zhao</code><span class="sig-paren">(</span><em class="sig-param">store</em>, <em class="sig-param">post_rate=1.7</em><span class="sig-paren">)</span><a class="headerlink" href="#tdt.algorithms.zhao.Zhao" title="Permalink to this definition">¶</a></dt>
<dd><p>In order to detect topics, Zhao et al.’s algorithm looks at the increase between two halves of a time window.
The original paper set this increase to 70%, but this implementation supports other values.</p>
<p>In addition to the ratio, since this approach is a feature-pivot technique also stores a <a class="reference internal" href="#tdt.nutrition.NutritionStore" title="tdt.nutrition.NutritionStore"><code class="xref py py-class docutils literal notranslate"><span class="pre">NutritionStore</span></code></a>.
This implementation uses a sliding time window.
Therefore the keys of the <a class="reference internal" href="#tdt.nutrition.NutritionStore" title="tdt.nutrition.NutritionStore"><code class="xref py py-class docutils literal notranslate"><span class="pre">NutritionStore</span></code></a> should be timestamps.
The values at each timestamp should be the number of documents observed at that timestamp.
The algorithm automatically separates the nutrition according to the varying sizes of the time window.</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>store</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">NutritionStore</span></code>) – The store contraining historical nutrition data.
The algorithm expects the nutrition values to represent the stream volume.
Therefore the keys should be the timestamps, and the values should integers representing the number of documents observed at that timestamp.</p></li>
<li><p><strong>post_rate</strong> (<em>float</em>) – The minimum increase between the two halves of the sliding time window to represent a burst.</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="tdt.algorithms.zhao.Zhao.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">store</em>, <em class="sig-param">post_rate=1.7</em><span class="sig-paren">)</span><a class="headerlink" href="#tdt.algorithms.zhao.Zhao.__init__" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>store</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">NutritionStore</span></code>) – The store contraining historical nutrition data.
The algorithm expects the nutrition values to represent the stream volume.
Therefore the keys should be the timestamps, and the values should integers representing the number of documents observed at that timestamp.</p></li>
<li><p><strong>post_rate</strong> (<em>float</em>) – The minimum increase between the two halves of the sliding time window to represent a burst.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tdt.algorithms.zhao.Zhao.detect">
<code class="sig-name descname">detect</code><span class="sig-paren">(</span><em class="sig-param">timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#tdt.algorithms.zhao.Zhao.detect" title="Permalink to this definition">¶</a></dt>
<dd><p>Detect topics using historical data from the nutrition store.
This function receives the timestamp and creates time windows of varying sizes that end at that timestamp.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>timestamp</strong> (<em>float</em><em> or </em><em>None</em>) – The timestamp at which to try to identify emerging topics.
If it is not given, the current timestamp is used.
This value is exclusive.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tuple with the start and end timestamp of the time window when there was a burst.
If there was no burst, <cite>False</cite> is returned.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple or bool</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-tdt.algorithms.cataldi">
<span id="cataldi-et-al-2014"></span><h3>Cataldi et al. (2014)<a class="headerlink" href="#module-tdt.algorithms.cataldi" title="Permalink to this headline">¶</a></h3>
<p>Cataldi et al.’s algorithm was among the first to introduce the notion of nutrition to calculate burst.
This feature-pivot technique calculates the importance of all terms, not just volume, and calls it nutrition.
Then, it periodically calculates the burst of these terms in three steps:</p>
<ol class="arabic simple">
<li><p>Calculate the burst of all terms by comparing how their importance changed over the past time windows.</p></li>
<li><p>Sort the terms in descending order of burst and calculate the drops between consecutive terms.</p></li>
<li><p>Find the maximal drop, called the critical drop index.
Any terms before the critical drop are said to be breaking.</p></li>
</ol>
<p>The burst calculation is based on time windows:</p>
<div class="math notranslate nohighlight">
\[burst_k^t = \sum_{x=t-s}^{t-1}(((nutr_k^t)^2 - (nutr_k^x)^2) \cdot \frac{1}{log(t - x + 1)})\]</div>
<p>where <span class="math notranslate nohighlight">\(t\)</span> is the current time window and <span class="math notranslate nohighlight">\(s\)</span> is the number of time windows to consider.
Note that because of the logarithm, old time windows have little effect.
The more time windows it considers, the more reliable the results, but removing very old time windows makes the algorithm more efficient.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This implementation is based on the algorithm presented in <a class="reference external" href="https://dl.acm.org/doi/abs/10.1145/2542182.2542189">Personalized Emerging Topic Detection Based on a Term Aging Model by Cataldi et al. (2014)</a>.</p>
</div>
<dl class="class">
<dt id="tdt.algorithms.cataldi.Cataldi">
<em class="property">class </em><code class="sig-name descname">Cataldi</code><span class="sig-paren">(</span><em class="sig-param">store</em><span class="sig-paren">)</span><a class="headerlink" href="#tdt.algorithms.cataldi.Cataldi" title="Permalink to this definition">¶</a></dt>
<dd><p>Cataldi et al.’s algorithm is relatively parameter-free.
Therefore the only state it maintains is the <a class="reference internal" href="#tdt.nutrition.NutritionStore" title="tdt.nutrition.NutritionStore"><code class="xref py py-class docutils literal notranslate"><span class="pre">NutritionStore</span></code></a>.</p>
<p>The keys of the <a class="reference internal" href="#tdt.nutrition.NutritionStore" title="tdt.nutrition.NutritionStore"><code class="xref py py-class docutils literal notranslate"><span class="pre">NutritionStore</span></code></a> should be timestamps that represent entire time windows.
The time window size depends on the application and how fast you expect the stream to change.
Each timestamp should have a dictionary with the nutritions of terms in it; the keys are the terms and the values are the corresponding nutrition values.</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><p><strong>store</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">NutritionStore</span></code>) – The store containing historical nutrition data.
The algorithm expects the timestamps to represent time windows.
Therefore the nutrition store should have dictionaries with timestamps as keys, and the nutrition of terms in a dictionary as values.
In other words, the timestamps should represent an entire time window, not just a particular timestamp.</p>
</dd>
</dl>
<dl class="method">
<dt id="tdt.algorithms.cataldi.Cataldi.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">store</em><span class="sig-paren">)</span><a class="headerlink" href="#tdt.algorithms.cataldi.Cataldi.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiate the TDT algorithm with the <a class="reference internal" href="#tdt.nutrition.NutritionStore" title="tdt.nutrition.NutritionStore"><code class="xref py py-class docutils literal notranslate"><span class="pre">NutritionStore</span></code></a> that will be used to detect topics.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>store</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">NutritionStore</span></code>) – The store containing historical nutrition data.
The algorithm expects the timestamps to represent time windows.
Therefore the nutrition store should have dictionaries with timestamps as keys, and the nutrition of terms in a dictionary as values.
In other words, the timestamps should represent an entire time window, not just a particular timestamp.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tdt.algorithms.cataldi.Cataldi.detect">
<code class="sig-name descname">detect</code><span class="sig-paren">(</span><em class="sig-param">timestamp</em>, <em class="sig-param">since=None</em><span class="sig-paren">)</span><a class="headerlink" href="#tdt.algorithms.cataldi.Cataldi.detect" title="Permalink to this definition">¶</a></dt>
<dd><p>Detect topics using historical data from the given nutrition store.</p>
<p>By default, like the original algorithm, this function considers all time windows in the <a class="reference internal" href="#tdt.nutrition.NutritionStore" title="tdt.nutrition.NutritionStore"><code class="xref py py-class docutils literal notranslate"><span class="pre">NutritionStore</span></code></a>.
However, since old time windows have little effect on the burst, fewer time windows may be considered without losing a lot of accuracy.
To consider fewer time windows, provide the <code class="docutils literal notranslate"><span class="pre">since</span></code> parameter—the timestamp from which point to start considering time windows.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>timestamp</strong> (<em>float</em>) – The timestamp at which to try to identify emerging topics.
This value is exclusive.</p></li>
<li><p><strong>since</strong> (<em>float</em><em> or </em><em>None</em>) – The timestamp since when nutrition should be considered.
If it is not given, all of the nutrition that is available is used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A list of breaking terms in the considered time window in descending order of their burst.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list of str</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-tdt.algorithms.eld">
<span id="eld-mamo-et-al-2019"></span><h3>ELD - Mamo et al. (2019)<a class="headerlink" href="#module-tdt.algorithms.eld" title="Permalink to this headline">¶</a></h3>
<p>Event TimeLine Detection (ELD) is a feature-pivot TDT approach designed to create interpretable results.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The original implementation of ELD is a combined document-pivot and feature-pivot TDT approach.
First, it clusters documents and then it applies the feature-pivot technique on large clusters.
However, the algorithm in this module is the feature-pivot technique.
The full implementation of ELD is in the <a class="reference internal" href="consumers.html#queues.consumers.algorithms.eld_consumer.ELDConsumer" title="queues.consumers.algorithms.eld_consumer.ELDConsumer"><code class="xref py py-class docutils literal notranslate"><span class="pre">ELDConsumer</span></code></a>.</p>
</div>
<p>ELD computes burst for each individual term.
The interpretation is in the form of a burst value that lies between -1 and 1:</p>
<ul class="simple">
<li><p>-1 indicates that a term has lost all popularity since the past checkpoints,</p></li>
<li><p>0 indicates that a term’s popularity has not changed over the past checkpoints, and</p></li>
<li><p>1 that the term has gone from completely unpopular to maximum popularity in the most recent checkpoint.</p></li>
</ul>
<p>Negative burst can be used to check when a topic is over.
This is because after the peak, when the topic slows down, the burst becomes negative or close to zero.</p>
<p>The checkpoints work like checkpoints.
The complete system routinely creates checkpoints that represent the importance of terms in a particular checkpoint.
For example, at timestamp 100, the checkpoint can represent the importance of terms between timestamps 90 and 100.</p>
<p>To calculate the burst, this algorithm compares the local context with the global context.
The local context refers to the importance of a term in a cluster.
The global context refers to the importance of a term in previous checkpoints, which consider all documents, not just those in a cluster.
Burst is calculated as:</p>
<div class="math notranslate nohighlight">
\[burst_k^t = \frac{\sum_{c=t-s}^{t-1}((nutr_{k,l} - nutr_{k,c}) \cdot \frac{1}{\sqrt{e^{t - c}}})}{\sum_{c=1}^s\frac{1}{\sqrt{e^c}}}\]</div>
<p>where <span class="math notranslate nohighlight">\(k\)</span> is the term for which burst is to be calculated.
<span class="math notranslate nohighlight">\(t\)</span> is the current checkpoint and <span class="math notranslate nohighlight">\(s\)</span> is the number of checkpoints to consider.
<span class="math notranslate nohighlight">\(nutr_{k,l}\)</span> is the nutrition of the term in the local context.
<span class="math notranslate nohighlight">\(nutr_{k,c}\)</span> is the nutrition of the term in the checkpoint <span class="math notranslate nohighlight">\(c\)</span>.</p>
<p>The square root in the burst calculation is the decay rate and is one of the parameters of this algorithm.
The higher the decay rate, the less importance old checkpoints receive.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>ELD borrows the terminology from Cataldi et al.’s previous work and algorithm: <a class="reference internal" href="#tdt.algorithms.cataldi.Cataldi" title="tdt.algorithms.cataldi.Cataldi"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cataldi</span></code></a>.
The importance of terms is called nutrition.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In reality, the bounds are not really between -1 and 1, but between <span class="math notranslate nohighlight">\(-x\)</span> and <span class="math notranslate nohighlight">\(x\)</span>, where <span class="math notranslate nohighlight">\(x\)</span> is the maximum nutrition of a term.
To get the burst bounds between -1 and 1, term nutritions need to be bound between 0 and 1 (that is, <span class="math notranslate nohighlight">\(x = 1\)</span>).
This is the original implementation in the <a class="reference internal" href="consumers.html#queues.consumers.algorithms.eld_consumer.ELDConsumer" title="queues.consumers.algorithms.eld_consumer.ELDConsumer"><code class="xref py py-class docutils literal notranslate"><span class="pre">ELDConsumer</span></code></a>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This implementation is based on the algorithm outlined in <a class="reference external" href="https://dl.acm.org/doi/abs/10.1145/3342220.3344921">ELD: Event TimeLine Detection – A Participant-Based Approach to Tracking Events by Mamo et al. (2019)</a>.</p>
</div>
<dl class="class">
<dt id="tdt.algorithms.eld.ELD">
<em class="property">class </em><code class="sig-name descname">ELD</code><span class="sig-paren">(</span><em class="sig-param">store</em>, <em class="sig-param">decay_rate=0.5</em><span class="sig-paren">)</span><a class="headerlink" href="#tdt.algorithms.eld.ELD" title="Permalink to this definition">¶</a></dt>
<dd><p>Mamo et al.’s ELD is a feature-pivot TDT algorithm to detect breaking terms.
The algorithm returns not only terms, but also the degree to which they are breaking.</p>
<p>The algorithm receives one parameter apart from the <a class="reference internal" href="#tdt.nutrition.NutritionStore" title="tdt.nutrition.NutritionStore"><code class="xref py py-class docutils literal notranslate"><span class="pre">NutritionStore</span></code></a>: the decay rate.
The decay rate is used to penalize old checkpoints and give recent checkpoints more importance in the burst calculation.</p>
<p>The keys of the <a class="reference internal" href="#tdt.nutrition.NutritionStore" title="tdt.nutrition.NutritionStore"><code class="xref py py-class docutils literal notranslate"><span class="pre">NutritionStore</span></code></a> should be timestamps that represent checkpoints, or time windows.
The checkpoint size depends on the application and how fast you expect the stream to change.
Each timestamp should have a dictionary with the nutritions of terms in it; the keys are the terms and the values are the corresponding nutrition values.</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>store</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">NutritionStore</span></code>) – The store containing historical nutrition data.
The algorithm expects the timestamps to represent checkpoints.
Therefore the nutrition store should have dictionaries with timestamps as keys, and the nutrition of terms in a dictionary as values.
In other words, the timestamps should represent an entire checkpoint, not just a particular timestamp.</p></li>
<li><p><strong>decay_rate</strong> (<em>float</em>) – The decay rate used by the algorithm.
The larger the decay rate, the less importance far-off windows have in the burst calculation.</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="tdt.algorithms.eld.ELD.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">store</em>, <em class="sig-param">decay_rate=0.5</em><span class="sig-paren">)</span><a class="headerlink" href="#tdt.algorithms.eld.ELD.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiate the TDT algorithm with the <a class="reference internal" href="#tdt.nutrition.NutritionStore" title="tdt.nutrition.NutritionStore"><code class="xref py py-class docutils literal notranslate"><span class="pre">NutritionStore</span></code></a> that will be used to detect topics and the decay rate.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>store</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">NutritionStore</span></code>) – The store containing historical nutrition data.
The algorithm expects the timestamps to represent checkpoints.
Therefore the nutrition store should have dictionaries with timestamps as keys, and the nutrition of terms in a dictionary as values.
In other words, the timestamps should represent an entire checkpoint, not just a particular timestamp.</p></li>
<li><p><strong>decay_rate</strong> (<em>float</em>) – The decay rate used by the algorithm.
The larger the decay rate, the less importance far-off windows have in the burst calculation.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tdt.algorithms.eld.ELD.detect">
<code class="sig-name descname">detect</code><span class="sig-paren">(</span><em class="sig-param">nutrition</em>, <em class="sig-param">since=None</em>, <em class="sig-param">until=None</em>, <em class="sig-param">min_burst=0</em><span class="sig-paren">)</span><a class="headerlink" href="#tdt.algorithms.eld.ELD.detect" title="Permalink to this definition">¶</a></dt>
<dd><p>Detect topics using historical data from the given nutrition store.</p>
<p>This function compares the nutrition of terms in the local context (the <code class="docutils literal notranslate"><span class="pre">nutrition</span></code> parameter) with the global context (the checkpoints in the class’ <a class="reference internal" href="#tdt.nutrition.NutritionStore" title="tdt.nutrition.NutritionStore"><code class="xref py py-class docutils literal notranslate"><span class="pre">NutritionStore</span></code></a>).
By default, this function uses all checkpoints until the given time window.
If no end timestamp (the <code class="docutils literal notranslate"><span class="pre">until</span></code> parameter) is given, the current timestamp is taken.</p>
<p>Fewer checkpoints can be used by providing the <code class="docutils literal notranslate"><span class="pre">since</span></code> and <code class="docutils literal notranslate"><span class="pre">until</span></code> parameters.
Old checkpoints have a smaller effect on the result than recent checkpoints so they can be removed with little effect.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function assumes that nutrition is always zero or positive.
As a result, the burst can be calculated only for terms that have a nutrition equal to or greater than the minimum burst.
The function makes an exception if the minimum burst is negative.
In this case, all terms have to be considered in the calculation.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The minimum burst is exclusive.
This is so that terms with a burst of 0 (no change from previous checkpoints) are excluded.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nutrition</strong> (<em>dict</em>) – The nutrition values of the local context.
The keys should be the terms, and the values the respective nutrition.</p></li>
<li><p><strong>since</strong> (<em>float</em><em> or </em><em>None</em>) – The timestamp since when nutrition should be considered.
If it is not given, all of the nutrition that is available until the <code class="docutils literal notranslate"><span class="pre">until</span></code> is used.</p></li>
<li><p><strong>until</strong> (<em>float</em><em> or </em><em>None</em>) – The timestamp until when nutrition should be considered.
If it is not given, all of the nutrition that is available since the <code class="docutils literal notranslate"><span class="pre">since</span></code> parameter is used.
If the algorithm is being used retrospectively, this parameter can represent the current timestamp to get only past nutrition.</p></li>
<li><p><strong>min_burst</strong> (<em>float</em>) – The minimum burst of a term to be considered emerging and returned.
This value is exclusive so that terms with an unchanging nutrition (a burst of 0) are not returned.
By default, only terms thet have a non-zero positive burst are returned.
These terms have seen their popularity increase.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The breaking terms and their burst as a dictionary.
The keys are the terms and the values are the respective burst values.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="summarization.html" class="btn btn-neutral float-right" title="7. Summarization" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="apd.html" class="btn btn-neutral float-left" title="5. Automatic Participant Detection (APD)" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Nicholas Mamo

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>