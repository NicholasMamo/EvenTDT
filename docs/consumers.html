

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta content="The consumer functionality of EvenTDT" name="description" />
<meta content="Python, TDT, queue, consumer" name="keywords" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>9. Consumers &mdash; EvenTDT 0.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/eventdt.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="10. Machine Learning" href="ml.html" />
    <link rel="prev" title="8. Twitter" href="twitter.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> EvenTDT
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="config.html">0. Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="tools.html">1. Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="vsm.html">2. Vector Space Model (VSM)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nlp.html">3. Natural Language Processing (NLP)</a></li>
<li class="toctree-l1"><a class="reference internal" href="wikinterface.html">4. Wikinterface</a></li>
<li class="toctree-l1"><a class="reference internal" href="apd.html">5. Automatic Participant Detection (APD)</a></li>
<li class="toctree-l1"><a class="reference internal" href="tdt.html">6. Topic Detection and Tracking (TDT)</a></li>
<li class="toctree-l1"><a class="reference internal" href="summarization.html">7. Summarization</a></li>
<li class="toctree-l1"><a class="reference internal" href="twitter.html">8. Twitter</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">9. Consumers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#the-queue-class">The Queue Class</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id1">Consumers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-queues.consumers">Real-Time Consumer</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-queues.consumers.buffered_consumer">Buffered (Windowed) Consumers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-queues.consumers.split_consumer">Split Consumers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#simple-consumers">Simple Consumers</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#module-queues.consumers.print_consumer">Print Consumer</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-queues.consumers.stat_consumer">Statistical Consumer</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-queues.consumers.algorithms">Algorithmic Consumers</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#module-queues.consumers.algorithms.zhao_consumer">Zhao et al. Consumer (2011)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-queues.consumers.algorithms.fire_consumer">FIRE Consumer - Mamo et al. (2017)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-queues.consumers.algorithms.eld_consumer">ELD Consumer - Mamo et al. (2019)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ml.html">10. Machine Learning</a></li>
<li class="toctree-l1"><a class="reference internal" href="ate.html">11. Automatic Term Extraction (ATE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="other.html">12. Other</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">EvenTDT</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>9. Consumers</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/consumers.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
    <div class="section" id="consumers">
<h1>9. Consumers<a class="headerlink" href="#consumers" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-queues"></span><p>EvenTDT collects tweets and processes them.
In-between collecting and processing, the tweets go into a queue data structure.
Later on, a <a class="reference internal" href="#id1"><span class="std std-ref">consumer</span></a> picks this data and processes it in the same order as it was received.
This functionality is implemented in a special class: the <a class="reference internal" href="#queues.Queue" title="queues.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a>.</p>
<div class="section" id="the-queue-class">
<h2>The Queue Class<a class="headerlink" href="#the-queue-class" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="#queues.Queue" title="queues.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a> is a first in, first out (FIFO) data structure.
In EvenTDT, this implementation is based on lists and queue-specific functionality is introduced as functions.</p>
<dl class="class">
<dt id="queues.Queue">
<em class="property">class </em><code class="sig-name descname">Queue</code><span class="sig-paren">(</span><em class="sig-param">*args</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.Queue" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#queues.Queue" title="queues.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a> data structure encapsulates a list with additional functions that mimick the workings of a queue.
The <a class="reference internal" href="#queues.Queue" title="queues.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a> is data-agnostic, so it can take in any kind of data, including other <a class="reference internal" href="#queues.Queue" title="queues.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a> instances.</p>
<p>As a FIFO structure, queue elements are added to the <a class="reference internal" href="#queues.Queue" title="queues.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a> at the end and removed from the beginning.
That means that the earlier an item has been in the <a class="reference internal" href="#queues.Queue" title="queues.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a>, the earlier it will be processed.</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><p><strong>queue</strong> (<em>list</em>) – The underlying list that is used by the <a class="reference internal" href="#queues.Queue" title="queues.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a> to mimick a queue’s workings.</p>
</dd>
</dl>
<dl class="method">
<dt id="queues.Queue.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">*args</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.Queue.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the queue.
The queue’s data can be given as normal arguments.</p>
</dd></dl>

<dl class="method">
<dt id="queues.Queue.enqueue">
<code class="sig-name descname">enqueue</code><span class="sig-paren">(</span><em class="sig-param">*args</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.Queue.enqueue" title="Permalink to this definition">¶</a></dt>
<dd><p>Add the given data to the queue.
All arguments can be provided as separate arguments.
So, to add one item, you can use:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">queue</span><span class="o">.</span><span class="n">enqueue</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>To add multiple items, you can use:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">queue</span><span class="o">.</span><span class="n">enqueue</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>You can also add a list, tuple or any other object to a <a class="reference internal" href="#queues.Queue" title="queues.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a>.
The following <a class="reference internal" href="#queues.Queue" title="queues.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a> would have a list and a tuple as the last two elements after calling the <a class="reference internal" href="#queues.Queue.enqueue" title="queues.Queue.enqueue"><code class="xref py py-func docutils literal notranslate"><span class="pre">enqueue()</span></code></a> function.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">queue</span><span class="o">.</span><span class="n">enqueue</span><span class="p">([</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">],</span> <span class="p">(</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span> <span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="queues.Queue.dequeue">
<code class="sig-name descname">dequeue</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#queues.Queue.dequeue" title="Permalink to this definition">¶</a></dt>
<dd><p>Get and remove the first element in the queue.
If the queue is empty, <code class="docutils literal notranslate"><span class="pre">None</span></code> is returned instead</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The first element in the queue.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>object or None</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.Queue.dequeue_all">
<code class="sig-name descname">dequeue_all</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#queues.Queue.dequeue_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Dequeue all elements in the queue.
Unlike the <a class="reference internal" href="#queues.Queue.empty" title="queues.Queue.empty"><code class="xref py py-func docutils literal notranslate"><span class="pre">empty()</span></code></a> function, this function returns all of the queue’s elements.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>All the elements in the queue.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.Queue.empty">
<code class="sig-name descname">empty</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#queues.Queue.empty" title="Permalink to this definition">¶</a></dt>
<dd><p>Empty the queue.
Unlike the <a class="reference internal" href="#queues.Queue.dequeue_all" title="queues.Queue.dequeue_all"><code class="xref py py-func docutils literal notranslate"><span class="pre">dequeue_all()</span></code></a> function, this function returns nothing.</p>
</dd></dl>

<dl class="method">
<dt id="queues.Queue.length">
<code class="sig-name descname">length</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#queues.Queue.length" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the length of the queue.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The length of the queue.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.Queue.head">
<code class="sig-name descname">head</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#queues.Queue.head" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the first element entered into the queue without removing it.
So, if a <a class="reference internal" href="#queues.Queue" title="queues.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a> has <cite>1, 2, 3</cite> as its data, calling <a class="reference internal" href="#queues.Queue.head" title="queues.Queue.head"><code class="xref py py-func docutils literal notranslate"><span class="pre">head()</span></code></a> would return <cite>1</cite>.
After this function call, the <a class="reference internal" href="#queues.Queue" title="queues.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a> still has <cite>1, 2, 3</cite> as its data.</p>
<p>If the queue is empty, <code class="docutils literal notranslate"><span class="pre">None</span></code> is returned instead</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The oldest element in the queue.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>object or None</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.Queue.tail">
<code class="sig-name descname">tail</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#queues.Queue.tail" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the last element entered into the queue without removing it.
So, if a <a class="reference internal" href="#queues.Queue" title="queues.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a> has <cite>1, 2, 3</cite> as its data, calling <a class="reference internal" href="#queues.Queue.tail" title="queues.Queue.tail"><code class="xref py py-func docutils literal notranslate"><span class="pre">tail()</span></code></a> would return <cite>3</cite>.
After this function call, the <a class="reference internal" href="#queues.Queue" title="queues.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a> still has <cite>1, 2, 3</cite> as its data.</p>
<p>If the queue is empty, <code class="docutils literal notranslate"><span class="pre">None</span></code> is returned instead</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The newest element in the queue.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>object or None</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="queues.Queue.__weakref__">
<code class="sig-name descname">__weakref__</code><a class="headerlink" href="#queues.Queue.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id1">
<span id="id2"></span><h2>Consumers<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-queues.consumers">
<span id="real-time-consumer"></span><h3>Real-Time Consumer<a class="headerlink" href="#module-queues.consumers" title="Permalink to this headline">¶</a></h3>
<p>After adding tweets to a <a class="reference internal" href="#queues.Queue" title="queues.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a>, consumers process that data.
Each consumer dequeues the accumulated data and performs some processing on it.</p>
<p>There is one class that is the base of all consumers: the basic <a class="reference internal" href="#queues.consumers.Consumer" title="queues.consumers.Consumer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Consumer</span></code></a>
From it stem all other consumers, including the <a class="reference internal" href="#queues.consumers.buffered_consumer.BufferedConsumer" title="queues.consumers.buffered_consumer.BufferedConsumer"><code class="xref py py-class docutils literal notranslate"><span class="pre">BufferedConsumer</span></code></a>.</p>
<p>These consumers are meant to be usable with minimal changes.
Although that makes them less flexible than building your own consumer, it also makes it easier to get started with EvenTDT.</p>
<p>Normally, you would either set up a stream using the <code class="xref py py-class docutils literal notranslate"><span class="pre">TweetListener</span></code> or by reading from a file using the <a class="reference internal" href="twitter.html#twitter.file.FileReader" title="twitter.file.FileReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">FileReader</span></code></a>.
These streams store tweets in a <code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code>—the same one that is given to any <a class="reference internal" href="#queues.consumers.Consumer" title="queues.consumers.Consumer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Consumer</span></code></a> class.
You can then run the <a class="reference internal" href="#queues.consumers.Consumer.run" title="queues.consumers.Consumer.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">run()</span></code></a> function.
More commonly, if you are not interested in the implementation details, you can run consumers using the <a class="reference internal" href="tools.html#module-tools.consume" title="tools.consume"><code class="xref py py-mod docutils literal notranslate"><span class="pre">consume</span></code></a> command-line tool.</p>
<p>The consumers package is the most central one in EvenTDT because it ties together all other packages.
Apart from some simple consumers, the package includes consumers based on algorithms presented in papers.
These complete solutions can be used as baselines to generate a <a class="reference internal" href="summarization.html#summarization.timeline.Timeline" title="summarization.timeline.Timeline"><code class="xref py py-class docutils literal notranslate"><span class="pre">Timeline</span></code></a> and later for summarization.
These consumers revolve around a <a class="reference internal" href="tdt.html#tdt.algorithms.TDTAlgorithm" title="tdt.algorithms.TDTAlgorithm"><code class="xref py py-class docutils literal notranslate"><span class="pre">TDTAlgorithm</span></code></a> and are meant to be as faithful as possible to the original approaches.</p>
<dl class="class">
<dt id="queues.consumers.Consumer">
<em class="property">class </em><code class="sig-name descname">Consumer</code><span class="sig-paren">(</span><em class="sig-param">queue</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.Consumer" title="Permalink to this definition">¶</a></dt>
<dd><p>The abstract <a class="reference internal" href="#queues.consumers.Consumer" title="queues.consumers.Consumer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Consumer</span></code></a> class outlines the necessary functions of any consumer.
All consumers follow a simple workflow.
After being initialized with a <a class="reference internal" href="#queues.Queue" title="queues.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a> that supplies data, the consumer run using the <a class="reference internal" href="#queues.consumers.Consumer.run" title="queues.consumers.Consumer.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">run()</span></code></a> function.</p>
<p>Consumers have two other state variables apart from the <a class="reference internal" href="#queues.Queue" title="queues.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a>: the <code class="docutils literal notranslate"><span class="pre">active</span></code> and <code class="docutils literal notranslate"><span class="pre">stopped</span></code> variables.
The <code class="docutils literal notranslate"><span class="pre">active</span></code> variable indicates whether the consumer is still accepting objects.
The <code class="docutils literal notranslate"><span class="pre">stopped</span></code> variable indicates whether the consumer has finished consuming all objects.
Generally, consumers keep accepting objects until the <code class="docutils literal notranslate"><span class="pre">active</span></code> variable is disabled, at which point they process the last objects and set the <code class="docutils literal notranslate"><span class="pre">stopped</span></code> flag to <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>queue</strong> (<a class="reference internal" href="#queues.Queue" title="queues.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a>) – The <a class="reference internal" href="#queues.Queue" title="queues.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a> that is to be consumed.</p></li>
<li><p><strong>active</strong> (<em>bool</em>) – A boolean indicating whether the consumer is still accepting data.</p></li>
<li><p><strong>stopped</strong> (<em>bool</em>) – A boolean indicating whether the consumer has finished processing.</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="queues.consumers.Consumer.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">queue</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.Consumer.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the consumer with its <a class="reference internal" href="#queues.Queue" title="queues.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>queue</strong> (<a class="reference internal" href="#queues.Queue" title="queues.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a>) – The queue that will be consumed.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.consumers.Consumer.run">
<em class="property">async </em><code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param">wait=0</em>, <em class="sig-param">max_inactivity=-1</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.Consumer.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the flags to indicate that the consumer is running and start consuming the <a class="reference internal" href="#queues.Queue" title="queues.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a>.</p>
<p>If the <a class="reference internal" href="#queues.Queue" title="queues.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a> is being populated by a <a class="reference internal" href="twitter.html#twitter.file.FileReader" title="twitter.file.FileReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">FileReader</span></code></a>, there might be an initial delay until the <a class="reference internal" href="#queues.Queue" title="queues.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a> receives any data.
This is because the <a class="reference internal" href="twitter.html#twitter.file.FileReader" title="twitter.file.FileReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">FileReader</span></code></a> supports skipping tweets, which introduces some latency.
When skipping a lot of time or lines, this latency can get very large.
You can use the <code class="docutils literal notranslate"><span class="pre">wait</span></code> parameter to delay running the consumer by a few seconds to wait for the <a class="reference internal" href="twitter.html#twitter.file.FileReader" title="twitter.file.FileReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">FileReader</span></code></a> to finish skipping part of the corpus.</p>
<p>In addition, corpora may be sparse with periods of time during which little data is fed to the consumer.
This can also happen when the <code class="xref py py-class docutils literal notranslate"><span class="pre">TweetListener</span></code> fails to collect tweets because of errors in the Twitter API.
The <code class="docutils literal notranslate"><span class="pre">max_inactivity</span></code> parameter is the allowance, in seconds, for how long the consumer should wait without receiving input before it decides no more data will arrive and stop.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>wait</strong> (<em>int</em>) – The time, in seconds, to wait until starting to consume the <a class="reference internal" href="#queues.Queue" title="queues.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a>.
This is used when the <a class="reference internal" href="twitter.html#twitter.file.FileReader" title="twitter.file.FileReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">FileReader</span></code></a> spends a lot of time skipping tweets.</p></li>
<li><p><strong>max_inactivity</strong> (<em>int</em>) – The maximum time, in seconds, to wait idly without input before stopping the consumer.
If it is negative, the consumer keeps waiting for input indefinitely.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The output of the consumption process.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>any</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.consumers.Consumer.stop">
<code class="sig-name descname">stop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.Consumer.stop" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a flag to stop accepting new tweets.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Contrary to the name of the function, the function sets the <code class="docutils literal notranslate"><span class="pre">active</span></code> flag to <code class="docutils literal notranslate"><span class="pre">False</span></code>, not the <code class="docutils literal notranslate"><span class="pre">stopped</span></code> flag to <code class="docutils literal notranslate"><span class="pre">True</span></code>.
This function merely asks the consumer to stop accepting new tweets for processing.
When the consumer actually stops, after it finishes processing whatever tweets it has, it sets the <code class="docutils literal notranslate"><span class="pre">stopped</span></code> flag to <code class="docutils literal notranslate"><span class="pre">True</span></code> itself.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="queues.consumers.Consumer.__weakref__">
<code class="sig-name descname">__weakref__</code><a class="headerlink" href="#queues.consumers.Consumer.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-queues.consumers.buffered_consumer">
<span id="buffered-windowed-consumers"></span><h3>Buffered (Windowed) Consumers<a class="headerlink" href="#module-queues.consumers.buffered_consumer" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="#queues.consumers.Consumer" title="queues.consumers.Consumer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Consumer</span></code></a> is designed to operate in real-time.
The <a class="reference internal" href="#queues.consumers.buffered_consumer.BufferedConsumer" title="queues.consumers.buffered_consumer.BufferedConsumer"><code class="xref py py-class docutils literal notranslate"><span class="pre">BufferedConsumer</span></code></a> builds on it, but it buffers input before processing.
Essentially, this buffering step transforms the <a class="reference internal" href="#queues.consumers.Consumer" title="queues.consumers.Consumer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Consumer</span></code></a> into a windowed approach.</p>
<p>The two <a class="reference internal" href="#queues.Queue" title="queues.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a> instances in the <a class="reference internal" href="#queues.consumers.buffered_consumer.BufferedConsumer" title="queues.consumers.buffered_consumer.BufferedConsumer"><code class="xref py py-class docutils literal notranslate"><span class="pre">BufferedConsumer</span></code></a> have these roles:</p>
<ul class="simple">
<li><p>Queue: The normal queue receives input from the <a class="reference internal" href="twitter.html#twitter.file.FileReader" title="twitter.file.FileReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">FileReader</span></code></a> or <code class="xref py py-class docutils literal notranslate"><span class="pre">TweetListener</span></code>.</p></li>
<li><p>Buffer: The <a class="reference internal" href="#queues.consumers.buffered_consumer.BufferedConsumer" title="queues.consumers.buffered_consumer.BufferedConsumer"><code class="xref py py-class docutils literal notranslate"><span class="pre">BufferedConsumer</span></code></a> constantly empties the normal queue into the buffer.
After every window, the algorithm processes the tweets collected so far in it.
While processing, the buffer continuesreceiving new tweets, which will be processed in the next time window.</p></li>
</ul>
<p>This package provides two types of buffered consumers:</p>
<ul class="simple">
<li><p>The <a class="reference internal" href="#queues.consumers.buffered_consumer.BufferedConsumer" title="queues.consumers.buffered_consumer.BufferedConsumer"><code class="xref py py-class docutils literal notranslate"><span class="pre">BufferedConsumer</span></code></a> bases its periodicity on the machine’s time.
Therefore it is opportune when running in a live environment.</p></li>
<li><p>The <a class="reference internal" href="#queues.consumers.buffered_consumer.SimulatedBufferedConsumer" title="queues.consumers.buffered_consumer.SimulatedBufferedConsumer"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimulatedBufferedConsumer</span></code></a> bases its periodicity on the tweets it is receiving.
It can be used both in a live environment, but especially when loading tweets from the <a class="reference internal" href="twitter.html#twitter.file.FileReader" title="twitter.file.FileReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">FileReader</span></code></a>.</p></li>
</ul>
<dl class="class">
<dt id="queues.consumers.buffered_consumer.BufferedConsumer">
<em class="property">class </em><code class="sig-name descname">BufferedConsumer</code><span class="sig-paren">(</span><em class="sig-param">queue</em>, <em class="sig-param">periodicity=60</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.buffered_consumer.BufferedConsumer" title="Permalink to this definition">¶</a></dt>
<dd><p>When calling the <a class="reference internal" href="#queues.consumers.buffered_consumer.BufferedConsumer.run" title="queues.consumers.buffered_consumer.BufferedConsumer.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">run()</span></code></a> function, the <a class="reference internal" href="#queues.consumers.buffered_consumer.BufferedConsumer" title="queues.consumers.buffered_consumer.BufferedConsumer"><code class="xref py py-class docutils literal notranslate"><span class="pre">BufferedConsumer</span></code></a> splits into two processes:</p>
<ol class="arabic simple">
<li><p>The consumption simply moves tweets from the <a class="reference internal" href="#queues.Queue" title="queues.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a> into the the buffer, another <a class="reference internal" href="#queues.Queue" title="queues.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a>.</p></li>
<li><p>The processing wakes up every time window to process the tweets collectd in the buffer so far.
While processing, the buffer receives new tweets, but these are only processed in the next time window.</p></li>
</ol>
<p>Apart from maintaining the buffer as a <a class="reference internal" href="#queues.Queue" title="queues.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a>, the state also includes the periodicity, or the length of the time window, in seconds.
This affects how often the buffer is processed.</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>periodicity</strong> (<em>int</em>) – The time window, in seconds, of the buffered consumer, or how often the consumer processes the buffer’s contents.</p></li>
<li><p><strong>buffer</strong> (<a class="reference internal" href="#queues.Queue" title="queues.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a>) – The buffer of objects that have to be processed.</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="queues.consumers.buffered_consumer.BufferedConsumer.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">queue</em>, <em class="sig-param">periodicity=60</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.buffered_consumer.BufferedConsumer.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the buffered consumer with its queue and periodicity.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>queue</strong> (<a class="reference internal" href="#queues.Queue" title="queues.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a>) – The queue that is consumed.</p></li>
<li><p><strong>periodicity</strong> (<em>int</em>) – The time window, in seconds, of the buffered consumer, or how often the consumer processes the buffer’s contents.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.consumers.buffered_consumer.BufferedConsumer.run">
<em class="property">async </em><code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param">wait=0</em>, <em class="sig-param">max_inactivity=-1</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.buffered_consumer.BufferedConsumer.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the flags to indicate that the consumer is running and start the buffered consumer’s two roles:</p>
<ol class="arabic simple">
<li><p>The consumption simply moves tweets from the <a class="reference internal" href="#queues.Queue" title="queues.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a> into the the buffer, another <a class="reference internal" href="#queues.Queue" title="queues.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a>.</p></li>
<li><p>The processing wakes up every time window to process the tweets collectd in the buffer so far.
While processing, the buffer receives new tweets, but these are only processed in the next time window.</p></li>
</ol>
<p>Similarly to the <a class="reference internal" href="#queues.consumers.Consumer" title="queues.consumers.Consumer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Consumer</span></code></a>, the buffered consumer also accepts the <code class="docutils literal notranslate"><span class="pre">wait</span></code> and <code class="docutils literal notranslate"><span class="pre">max_inactivity</span></code> parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>wait</strong> (<em>int</em>) – The time in seconds to wait until starting to understand the event.
This is used when the file listener spends a lot of time skipping documents.</p></li>
<li><p><strong>max_inactivity</strong> (<em>int</em>) – The maximum time in seconds to wait idly without input before stopping.
If it is negative, the consumer keeps waiting for input until the maximum time expires.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The output of the consumption process.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>any</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="queues.consumers.buffered_consumer.SimulatedBufferedConsumer">
<em class="property">class </em><code class="sig-name descname">SimulatedBufferedConsumer</code><span class="sig-paren">(</span><em class="sig-param">queue</em>, <em class="sig-param">periodicity</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.buffered_consumer.SimulatedBufferedConsumer" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#queues.consumers.buffered_consumer.SimulatedBufferedConsumer" title="queues.consumers.buffered_consumer.SimulatedBufferedConsumer"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimulatedBufferedConsumer</span></code></a> is exactly like the <a class="reference internal" href="#queues.consumers.buffered_consumer.BufferedConsumer" title="queues.consumers.buffered_consumer.BufferedConsumer"><code class="xref py py-class docutils literal notranslate"><span class="pre">BufferedConsumer</span></code></a>, but its periodicity is not real-time.
Whereas the <a class="reference internal" href="#queues.consumers.buffered_consumer.BufferedConsumer" title="queues.consumers.buffered_consumer.BufferedConsumer"><code class="xref py py-class docutils literal notranslate"><span class="pre">BufferedConsumer</span></code></a>’s time window is based on the machine’s time, the <a class="reference internal" href="#queues.consumers.buffered_consumer.SimulatedBufferedConsumer" title="queues.consumers.buffered_consumer.SimulatedBufferedConsumer"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimulatedBufferedConsumer</span></code></a> looks at the tweet’s timestamps.
This makes the <a class="reference internal" href="#queues.consumers.buffered_consumer.SimulatedBufferedConsumer" title="queues.consumers.buffered_consumer.SimulatedBufferedConsumer"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimulatedBufferedConsumer</span></code></a> ideal in situations where it is necessary to simulate the live environment, for example when using a <a class="reference internal" href="twitter.html#twitter.file.FileReader" title="twitter.file.FileReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">FileReader</span></code></a>.</p>
<dl class="method">
<dt id="queues.consumers.buffered_consumer.SimulatedBufferedConsumer.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">queue</em>, <em class="sig-param">periodicity</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.buffered_consumer.SimulatedBufferedConsumer.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the buffered consumer with its queue and periodicity.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>queue</strong> (<a class="reference internal" href="#queues.Queue" title="queues.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a>) – The queue that is consumed.</p></li>
<li><p><strong>periodicity</strong> (<em>int</em>) – The time window in seconds of the buffered consumer, or how often it is invoked.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-queues.consumers.split_consumer">
<span id="split-consumers"></span><h3>Split Consumers<a class="headerlink" href="#module-queues.consumers.split_consumer" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="#queues.consumers.split_consumer.SplitConsumer" title="queues.consumers.split_consumer.SplitConsumer"><code class="xref py py-class docutils literal notranslate"><span class="pre">SplitConsumer</span></code></a> builds on the base <a class="reference internal" href="#queues.consumers.Consumer" title="queues.consumers.Consumer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Consumer</span></code></a> class, but splits the incoming stream of tweets into several streams.
These streams are simply a list of <a class="reference internal" href="#queues.Queue" title="queues.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a> instances.</p>
<p>The <a class="reference internal" href="#queues.consumers.split_consumer.SplitConsumer" title="queues.consumers.split_consumer.SplitConsumer"><code class="xref py py-class docutils literal notranslate"><span class="pre">SplitConsumer</span></code></a> creates as many <a class="reference internal" href="#queues.consumers.Consumer" title="queues.consumers.Consumer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Consumer</span></code></a> instances as there <a class="reference internal" href="#queues.Queue" title="queues.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a> instances—one <a class="reference internal" href="#queues.Queue" title="queues.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a> for each <a class="reference internal" href="#queues.consumers.Consumer" title="queues.consumers.Consumer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Consumer</span></code></a>.
All consumers process the tweets in their own <a class="reference internal" href="#queues.Queue" title="queues.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a> as usual.</p>
<p>The way the consumer splits the stream depends entirely on the the implementation.
The consumer can assign each tweet to just one stream, to multiple streams, or even discard tweets.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <a class="reference internal" href="#queues.consumers.split_consumer.SplitConsumer" title="queues.consumers.split_consumer.SplitConsumer"><code class="xref py py-class docutils literal notranslate"><span class="pre">SplitConsumer</span></code></a> is based on the <a class="reference internal" href="#queues.consumers.Consumer" title="queues.consumers.Consumer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Consumer</span></code></a> class, so it operates in real-time.
All this means is that it sends tweets to the appropriate consumer without delay.
The processing, however, does not have to be in real-time.
The individual consumers that process the split streams can be based on the <a class="reference internal" href="#queues.consumers.buffered_consumer.BufferedConsumer" title="queues.consumers.buffered_consumer.BufferedConsumer"><code class="xref py py-class docutils literal notranslate"><span class="pre">BufferedConsumer</span></code></a> and process tweets in batches.</p>
</div>
<dl class="class">
<dt id="queues.consumers.split_consumer.SplitConsumer">
<em class="property">class </em><code class="sig-name descname">SplitConsumer</code><span class="sig-paren">(</span><em class="sig-param">queue</em>, <em class="sig-param">splits</em>, <em class="sig-param">consumer</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.split_consumer.SplitConsumer" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#queues.consumers.split_consumer.SplitConsumer" title="queues.consumers.split_consumer.SplitConsumer"><code class="xref py py-class docutils literal notranslate"><span class="pre">SplitConsumer</span></code></a> class acts as a supervisor.
It reads all of the incoming tweets and dispatches them to one of its consumers.</p>
<p>In its state, the consumer maintains a list of these conditions.
Associated with each condition is one class:<cite>~queues.consumers.Consumer</cite> that receives the tweets from that split.</p>
<p>This class mainly re-works the basic consumption method to decide where to send off tweets.
To change how the consumer works, you might need to override the following functions:</p>
<ul class="simple">
<li><p>&lt;Optional&gt; <code class="xref py py-func docutils literal notranslate"><span class="pre">_preprocess()</span></code>: Pre-process all incoming tweets.
This function is used whenever the child consumers all perform the same pre-processing tasks.
When tweets can be added to multiple streams, this function can improve efficiency.
By default, it does not change tweets.</p></li>
<li><p>&lt;Required&gt; <code class="xref py py-func docutils literal notranslate"><span class="pre">_satisfies()</span></code>: Check whether a tweet satisfies a condition.
This is the central function that all split consumers need to implement.
It decides how to route tweets to the different tweets.</p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">splits</span></code> and the <code class="xref py py-func docutils literal notranslate"><span class="pre">_satisfies()</span></code> are tightly-linked.
Each split becomes the input to the latter function.
For example, the following implementation of the <code class="xref py py-func docutils literal notranslate"><span class="pre">_satisfies()</span></code> function splits tweets according to their length.
Therefore it receives a range of tweet lengths, such as <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">140),</span> <span class="pre">(140,</span> <span class="pre">280)</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">_satisfies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">condition</span><span class="p">):</span>

        <span class="n">min_length</span><span class="p">,</span> <span class="n">max_length</span> <span class="o">=</span> <span class="n">condition</span>
        <span class="k">return</span> <span class="n">min_length</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="s1">&#39;text&#39;</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">max_length</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>splits</strong> (<em>list</em>) – A list of splits, or conditions that determine into which queue a tweet goes.
The type of the splits depends on what the <code class="xref py py-func docutils literal notranslate"><span class="pre">_satisfies()</span></code> function looks for.</p></li>
<li><p><a class="reference internal" href="#module-queues.consumers" title="queues.consumers"><strong>consumers</strong></a> (list of <a class="reference internal" href="#queues.consumers.Consumer" title="queues.consumers.Consumer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Consumer</span></code></a>) – The consumers that will receive the tweets from the different splits.
Each consumer corresponds to one split.</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="queues.consumers.split_consumer.SplitConsumer.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">queue</em>, <em class="sig-param">splits</em>, <em class="sig-param">consumer</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.split_consumer.SplitConsumer.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the consumer with its <a class="reference internal" href="#queues.Queue" title="queues.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a>.</p>
<p>For each given split, this function creates one <a class="reference internal" href="#queues.consumers.Consumer" title="queues.consumers.Consumer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Consumer</span></code></a> of the given type.
This consumer has its own queue, which receive tweets that satisfy the associated condition.</p>
<p>Any additional arguments or keyword arguments are passed on to the consumer’s constructor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>queue</strong> (<a class="reference internal" href="#queues.Queue" title="queues.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a>) – The queue that receives the entire stream.</p></li>
<li><p><strong>splits</strong> (<em>list</em><em> or </em><em>tuple</em>) – A list of splits, or conditions that determine into which queue a tweet goes.
The type of the splits depends on what the <code class="xref py py-func docutils literal notranslate"><span class="pre">_satisfies()</span></code> function looks for.</p></li>
<li><p><strong>consumer</strong> (<em>type</em>) – The type of <a class="reference internal" href="#queues.consumers.Consumer" title="queues.consumers.Consumer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Consumer</span></code></a> to create for each split.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.consumers.split_consumer.SplitConsumer.run">
<em class="property">async </em><code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param">wait=0</em>, <em class="sig-param">max_inactivity=-1</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.split_consumer.SplitConsumer.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the flags to indicate that the consumer is running and start consuming the <a class="reference internal" href="#queues.Queue" title="queues.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a>.
At the same time, the <a class="reference internal" href="#queues.consumers.split_consumer.SplitConsumer" title="queues.consumers.split_consumer.SplitConsumer"><code class="xref py py-class docutils literal notranslate"><span class="pre">SplitConsumer</span></code></a> starts running its own consumers.</p>
<p>If the <a class="reference internal" href="#queues.Queue" title="queues.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a> is being populated by a <a class="reference internal" href="twitter.html#twitter.file.FileReader" title="twitter.file.FileReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">FileReader</span></code></a>, there might be an initial delay until the <a class="reference internal" href="#queues.Queue" title="queues.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a> receives any data.
This is because the <a class="reference internal" href="twitter.html#twitter.file.FileReader" title="twitter.file.FileReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">FileReader</span></code></a> supports skipping tweets, which introduces some latency.
When skipping a lot of time or lines, this latency can get very large.
You can use the <code class="docutils literal notranslate"><span class="pre">wait</span></code> parameter to delay running the consumer by a few seconds to wait for the <a class="reference internal" href="twitter.html#twitter.file.FileReader" title="twitter.file.FileReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">FileReader</span></code></a> to finish skipping part of the corpus.</p>
<p>In addition, corpora may be sparse with periods of time during which little data is fed to the consumer.
This can also happen when the <code class="xref py py-class docutils literal notranslate"><span class="pre">TweetListener</span></code> fails to collect tweets because of errors in the Twitter API.
The <code class="docutils literal notranslate"><span class="pre">max_inactivity</span></code> parameter is the allowance, in seconds, for how long the consumer should wait without receiving input before it decides no more data will arrive and stop.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>wait</strong> (<em>int</em>) – The time, in seconds, to wait until starting to consume the <a class="reference internal" href="#queues.Queue" title="queues.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a>.
This is used when the <a class="reference internal" href="twitter.html#twitter.file.FileReader" title="twitter.file.FileReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">FileReader</span></code></a> spends a lot of time skipping tweets.</p></li>
<li><p><strong>max_inactivity</strong> (<em>int</em>) – The maximum time, in seconds, to wait idly without input before stopping the consumer.
If it is negative, the consumer keeps waiting for input indefinitely.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The output of the consumer, if any, as a tuple.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>any</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="queues.consumers.split_consumer.DummySplitConsumer">
<em class="property">class </em><code class="sig-name descname">DummySplitConsumer</code><span class="sig-paren">(</span><em class="sig-param">queue</em>, <em class="sig-param">splits</em>, <em class="sig-param">consumer</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.split_consumer.DummySplitConsumer" title="Permalink to this definition">¶</a></dt>
<dd><p>A dummy <a class="reference internal" href="#queues.consumers.split_consumer.SplitConsumer" title="queues.consumers.split_consumer.SplitConsumer"><code class="xref py py-class docutils literal notranslate"><span class="pre">SplitConsumer</span></code></a> that adds all tweets to all streams.
It is used only for testing purposes.</p>
</dd></dl>

</div>
<div class="section" id="simple-consumers">
<h3>Simple Consumers<a class="headerlink" href="#simple-consumers" title="Permalink to this headline">¶</a></h3>
<div class="section" id="module-queues.consumers.print_consumer">
<span id="print-consumer"></span><h4>Print Consumer<a class="headerlink" href="#module-queues.consumers.print_consumer" title="Permalink to this headline">¶</a></h4>
<p>The <a class="reference internal" href="#queues.consumers.print_consumer.PrintConsumer" title="queues.consumers.print_consumer.PrintConsumer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PrintConsumer</span></code></a> is a real-time consumer that performs no processing, expect to print the tweets as they arrive in the <a class="reference internal" href="#queues.Queue" title="queues.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a>.</p>
<dl class="class">
<dt id="queues.consumers.print_consumer.PrintConsumer">
<em class="property">class </em><code class="sig-name descname">PrintConsumer</code><span class="sig-paren">(</span><em class="sig-param">queue</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.print_consumer.PrintConsumer" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#queues.consumers.print_consumer.PrintConsumer" title="queues.consumers.print_consumer.PrintConsumer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PrintConsumer</span></code></a> maintains no special state.
It works in real-time, reading and printing tweets from the <a class="reference internal" href="#queues.Queue" title="queues.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a>, and discarding them immediately.</p>
</dd></dl>

</div>
<div class="section" id="module-queues.consumers.stat_consumer">
<span id="statistical-consumer"></span><h4>Statistical Consumer<a class="headerlink" href="#module-queues.consumers.stat_consumer" title="Permalink to this headline">¶</a></h4>
<p>The <a class="reference internal" href="#queues.consumers.stat_consumer.StatConsumer" title="queues.consumers.stat_consumer.StatConsumer"><code class="xref py py-class docutils literal notranslate"><span class="pre">StatConsumer</span></code></a> is a simple, windowed consumer that reports statistics about tweets periodically.
These statistics are very basic: the number of tweets received every minute.</p>
<dl class="class">
<dt id="queues.consumers.stat_consumer.StatConsumer">
<em class="property">class </em><code class="sig-name descname">StatConsumer</code><span class="sig-paren">(</span><em class="sig-param">queue</em>, <em class="sig-param">periodicity=60</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.stat_consumer.StatConsumer" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#queues.consumers.stat_consumer.StatConsumer" title="queues.consumers.stat_consumer.StatConsumer"><code class="xref py py-class docutils literal notranslate"><span class="pre">StatConsumer</span></code></a> maintains no special state.
After every time window, it empties the buffer and prints the number of tweets in it.</p>
</dd></dl>

</div>
</div>
<div class="section" id="module-queues.consumers.algorithms">
<span id="algorithmic-consumers"></span><span id="consumers-algorithms"></span><h3>Algorithmic Consumers<a class="headerlink" href="#module-queues.consumers.algorithms" title="Permalink to this headline">¶</a></h3>
<p>In addition to the base and simple consumers, EvenTDT includes consumers that replicate methods proposed in literature.
These approaches are as faithful to the original techniques as possible, although they depend a lot on the details available in the respective papers.</p>
<p>You can use these consumers as baselines or to have a working base from where to start implementing your own consumers.
To run these consumers, check out the <a class="reference internal" href="tools.html#module-tools.consume" title="tools.consume"><code class="xref py py-mod docutils literal notranslate"><span class="pre">consume</span></code></a> tool.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>In many cases, these consumers replicate most faithfully the TDT approach, not the summarization approach.</p>
</div>
<div class="section" id="module-queues.consumers.algorithms.zhao_consumer">
<span id="zhao-et-al-consumer-2011"></span><h4>Zhao et al. Consumer (2011)<a class="headerlink" href="#module-queues.consumers.algorithms.zhao_consumer" title="Permalink to this headline">¶</a></h4>
<p>The Zhao et al. consumer mimicks the implementation by the same authors.
It revolves around the <a class="reference internal" href="tdt.html#tdt.algorithms.zhao.Zhao" title="tdt.algorithms.zhao.Zhao"><code class="xref py py-class docutils literal notranslate"><span class="pre">Zhao</span></code></a> TDT algorithm.</p>
<p>This consumer is concernedd only with the TDT approach.
The summarization in the <code class="xref py py-class docutils literal notranslate"><span class="pre">ZhaoConsumer</span></code> uses the <a class="reference internal" href="summarization.html#summarization.algorithms.mmr.MMR" title="summarization.algorithms.mmr.MMR"><code class="xref py py-class docutils literal notranslate"><span class="pre">MMR</span></code></a> approach.</p>
<p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">ZhaoConsumer</span></code> uses a dynamic, sliding time-window to detect topics.
It splits each time-window into two halves, and checks whether the second half has experienced a surge in tweets.
If it has, then that half-time-window represents a topic.
Otherwise, a larger time-window is used.
You can read more about this approach in the <a class="reference internal" href="tdt.html#tdt.algorithms.zhao.Zhao" title="tdt.algorithms.zhao.Zhao"><code class="xref py py-class docutils literal notranslate"><span class="pre">Zhao</span></code></a> class.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This implementation is based on the algorithm presented in <a class="reference external" href="https://arxiv.org/abs/1106.4300">Human as Real-Time Sensors of Social and Physical Events: A Case Study of Twitter and Sports Games by Zhao et al. (2011)</a>.</p>
</div>
<dl class="class">
<dt id="queues.consumers.algorithms.zhao_consumer.ZhaoConsumer">
<em class="property">class </em><code class="sig-name descname">ZhaoConsumer</code><span class="sig-paren">(</span><em class="sig-param">queue</em>, <em class="sig-param">periodicity=5</em>, <em class="sig-param">scheme=None</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.algorithms.zhao_consumer.ZhaoConsumer" title="Permalink to this definition">¶</a></dt>
<dd><p>The Zhao et al. consumer is based on the implementation by the same authors.
The algorithm revolves around the <a class="reference internal" href="tdt.html#tdt.algorithms.zhao.Zhao" title="tdt.algorithms.zhao.Zhao"><code class="xref py py-class docutils literal notranslate"><span class="pre">Zhao</span></code></a> algorithm.
The algorithm examines changes in volume using a dynamic, sliding time-window.</p>
<p>The consumer naturally stores its periodicity, which defines the smallest dynamic sliding time-window.
Apart from that, it stores a <a class="reference internal" href="tdt.html#tdt.nutrition.NutritionStore" title="tdt.nutrition.NutritionStore"><code class="xref py py-class docutils literal notranslate"><span class="pre">NutritionStore</span></code></a>, which records the tweeting volume at each second, and a <a class="reference internal" href="nlp.html#nlp.weighting.TermWeightingScheme" title="nlp.weighting.TermWeightingScheme"><code class="xref py py-class docutils literal notranslate"><span class="pre">TermWeightingScheme</span></code></a> to create documents.</p>
<p>Finally, the consumer also maintains a list of <a class="reference internal" href="nlp.html#nlp.document.Document" title="nlp.document.Document"><code class="xref py py-class docutils literal notranslate"><span class="pre">Document</span></code></a> instances that cover the largest sliding time-window.
These documents can be used later for summarization by the <a class="reference internal" href="summarization.html#summarization.algorithms.mmr.MMR" title="summarization.algorithms.mmr.MMR"><code class="xref py py-class docutils literal notranslate"><span class="pre">MMR</span></code></a> algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>store</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">NutritionStore</span></code>) – The nutrition store used to store the volume.</p></li>
<li><p><strong>scheme</strong> (<a class="reference internal" href="nlp.html#nlp.weighting.TermWeightingScheme" title="nlp.weighting.TermWeightingScheme"><code class="xref py py-class docutils literal notranslate"><span class="pre">TermWeightingScheme</span></code></a>) – The term-weighting scheme used to create documents.</p></li>
<li><p><a class="reference internal" href="summarization.html#summarization.summary.Summary.documents" title="summarization.summary.Summary.documents"><strong>documents</strong></a> (<a class="reference internal" href="nlp.html#nlp.document.Document" title="nlp.document.Document"><code class="xref py py-class docutils literal notranslate"><span class="pre">Document</span></code></a>) – The documents that can still be used for summarization.
Older documents are automatically cleared.</p></li>
<li><p><a class="reference internal" href="tdt.html#module-tdt" title="tdt"><strong>tdt</strong></a> (<a class="reference internal" href="tdt.html#tdt.algorithms.zhao.Zhao" title="tdt.algorithms.zhao.Zhao"><code class="xref py py-class docutils literal notranslate"><span class="pre">Zhao</span></code></a>) – The TDT algorithm: Zhao et al.’s implementation.</p></li>
<li><p><a class="reference internal" href="summarization.html#module-summarization" title="summarization"><strong>summarization</strong></a> (<a class="reference internal" href="summarization.html#summarization.algorithms.mmr.MMR" title="summarization.algorithms.mmr.MMR"><code class="xref py py-class docutils literal notranslate"><span class="pre">MMR</span></code></a>) – The summarization algorithm to use.</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="queues.consumers.algorithms.zhao_consumer.ZhaoConsumer.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">queue</em>, <em class="sig-param">periodicity=5</em>, <em class="sig-param">scheme=None</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.algorithms.zhao_consumer.ZhaoConsumer.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the consumer with a <a class="reference internal" href="#queues.Queue" title="queues.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a>.
Simultaneously create a <a class="reference internal" href="tdt.html#tdt.nutrition.NutritionStore" title="tdt.nutrition.NutritionStore"><code class="xref py py-class docutils literal notranslate"><span class="pre">NutritionStore</span></code></a> and the <a class="reference internal" href="tdt.html#tdt.algorithms.zhao.Zhao" title="tdt.algorithms.zhao.Zhao"><code class="xref py py-class docutils literal notranslate"><span class="pre">Zhao</span></code></a> TDT algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>queue</strong> (<a class="reference internal" href="#queues.Queue" title="queues.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a>) – The queue that the consumer will consume later.</p></li>
<li><p><strong>periodicity</strong> (<em>int</em>) – The time-window in seconds of the buffered consumer, or how often it is invoked.
This defaults to 5 seconds, the same span as half the smallest time-window in Zhao et al.’s algorithm.</p></li>
<li><p><strong>scheme</strong> (None or <a class="reference internal" href="nlp.html#nlp.weighting.TermWeightingScheme" title="nlp.weighting.TermWeightingScheme"><code class="xref py py-class docutils literal notranslate"><span class="pre">TermWeightingScheme</span></code></a>) – The term-weighting scheme that is used to create dimensions.
If <code class="docutils literal notranslate"><span class="pre">None</span></code> is given, the <a class="reference internal" href="nlp.html#nlp.weighting.tf.TF" title="nlp.weighting.tf.TF"><code class="xref py py-class docutils literal notranslate"><span class="pre">TF</span></code></a> term-weighting scheme is used.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-queues.consumers.algorithms.fire_consumer">
<span id="fire-consumer-mamo-et-al-2017"></span><h4>FIRE Consumer - Mamo et al. (2017)<a class="headerlink" href="#module-queues.consumers.algorithms.fire_consumer" title="Permalink to this headline">¶</a></h4>
<p>Finding Important News REports (FIRE) is a time-windowed TDT consumer based on the algorithm by Mamo et al. (2017).</p>
<p>Whereas most TDT approaches are either document-pivot or feature-pivot techniques, FIRE combines the two.</p>
<ul class="simple">
<li><p>Document-pivot: At each time window, FIRE incrementally clusters the tweets and filters them to retain only the largest ones.</p></li>
<li><p>Feature-pivot: For each large cluster, FIRE applies the <a class="reference internal" href="tdt.html#tdt.algorithms.cataldi.Cataldi" title="tdt.algorithms.cataldi.Cataldi"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cataldi</span></code></a> feature-pivot method to identify if there are any breaking terms.</p></li>
</ul>
<p>In this implementation, the <a class="reference internal" href="summarization.html#summarization.timeline.Timeline" title="summarization.timeline.Timeline"><code class="xref py py-class docutils literal notranslate"><span class="pre">Timeline</span></code></a> performs the tracking task of TDT.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This implementation is based on the algorithm presented in <a class="reference external" href="https://link.springer.com/chapter/10.1007/978-3-319-74497-1_3">FIRE: Finding Important News REports by Mamo and Azzopardi (2017)</a>.</p>
</div>
<dl class="class">
<dt id="queues.consumers.algorithms.fire_consumer.FIREConsumer">
<em class="property">class </em><code class="sig-name descname">FIREConsumer</code><span class="sig-paren">(</span><em class="sig-param">queue</em>, <em class="sig-param">periodicity=60</em>, <em class="sig-param">scheme=None</em>, <em class="sig-param">sets=10</em>, <em class="sig-param">threshold=0.7</em>, <em class="sig-param">freeze_period=20</em>, <em class="sig-param">min_size=4</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.algorithms.fire_consumer.FIREConsumer" title="Permalink to this definition">¶</a></dt>
<dd><p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">FIREConsumer</span></code> is based on the paper by Mamo et al. (2017).</p>
<p>The algorithm is split into time-windows.
After each time-window, the consumer performs two tasks:</p>
<ol class="arabic simple">
<li><p>Firstly, it incrementally clusters the tweets using the <a class="reference internal" href="vsm.html#vsm.clustering.algorithms.temporal_no_k_means.TemporalNoKMeans" title="vsm.clustering.algorithms.temporal_no_k_means.TemporalNoKMeans"><code class="xref py py-class docutils literal notranslate"><span class="pre">TemporalNoKMeans</span></code></a>.</p></li>
<li><p>Secondly, it filters out small clusters using the <code class="docutils literal notranslate"><span class="pre">min_size</span></code> parameter.
FIRE uses the <a class="reference internal" href="tdt.html#tdt.algorithms.cataldi.Cataldi" title="tdt.algorithms.cataldi.Cataldi"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cataldi</span></code></a> on each cluster to identify if it has any breaking terms.
The comparison compares the nutrition of terms in the cluster (the local context) with the nutrition of terms in previous time-windows (the global context).
The global context is stored in a <a class="reference internal" href="tdt.html#tdt.nutrition.NutritionStore" title="tdt.nutrition.NutritionStore"><code class="xref py py-class docutils literal notranslate"><span class="pre">NutritionStore</span></code></a>.</p></li>
</ol>
<p>To convert tweets into <a class="reference internal" href="nlp.html#nlp.document.Document" title="nlp.document.Document"><code class="xref py py-class docutils literal notranslate"><span class="pre">Document</span></code></a> instances, the <code class="xref py py-class docutils literal notranslate"><span class="pre">FIREConsumer</span></code> also stores a <a class="reference internal" href="nlp.html#nlp.tokenizer.Tokenizer" title="nlp.tokenizer.Tokenizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tokenizer</span></code></a> and a <a class="reference internal" href="nlp.html#nlp.weighting.TermWeightingScheme" title="nlp.weighting.TermWeightingScheme"><code class="xref py py-class docutils literal notranslate"><span class="pre">TermWeightingScheme</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>store</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">NutritionStore</span></code>) – The nutrition store used to store the volume changes of individual terms.</p></li>
<li><p><strong>scheme</strong> (<a class="reference internal" href="nlp.html#nlp.weighting.TermWeightingScheme" title="nlp.weighting.TermWeightingScheme"><code class="xref py py-class docutils literal notranslate"><span class="pre">TermWeightingScheme</span></code></a>) – The term-weighting scheme used to create documents.</p></li>
<li><p><strong>sets</strong> (<em>int</em>) – The number of time windows that are considered when computing burst.
The higher this number, the more precise the calculations.
However, because of the decay in <a class="reference internal" href="tdt.html#tdt.algorithms.cataldi.Cataldi" title="tdt.algorithms.cataldi.Cataldi"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cataldi</span></code></a>, old time windows do not affect the result by a big margin.
Therefore old data can be removed safely.</p></li>
<li><p><strong>min_size</strong> (<em>int</em>) – The minimum size for a cluster to be considered to be a candidate breaking topic.
This value is inclusive.</p></li>
<li><p><strong>tokenizer</strong> (<a class="reference internal" href="nlp.html#nlp.tokenizer.Tokenizer" title="nlp.tokenizer.Tokenizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tokenizer</span></code></a>) – The tokenizer used to create documents.</p></li>
<li><p><strong>clustering</strong> (<a class="reference internal" href="vsm.html#vsm.clustering.algorithms.temporal_no_k_means.TemporalNoKMeans" title="vsm.clustering.algorithms.temporal_no_k_means.TemporalNoKMeans"><code class="xref py py-class docutils literal notranslate"><span class="pre">TemporalNoKMeans</span></code></a>) – The clustering algorithm to use.</p></li>
<li><p><a class="reference internal" href="summarization.html#module-summarization" title="summarization"><strong>summarization</strong></a> (<a class="reference internal" href="summarization.html#summarization.algorithms.mmr.MMR" title="summarization.algorithms.mmr.MMR"><code class="xref py py-class docutils literal notranslate"><span class="pre">MMR</span></code></a>) – The summarization algorithm to use.</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="queues.consumers.algorithms.fire_consumer.FIREConsumer.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">queue</em>, <em class="sig-param">periodicity=60</em>, <em class="sig-param">scheme=None</em>, <em class="sig-param">sets=10</em>, <em class="sig-param">threshold=0.7</em>, <em class="sig-param">freeze_period=20</em>, <em class="sig-param">min_size=4</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.algorithms.fire_consumer.FIREConsumer.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the consumer with a <a class="reference internal" href="#queues.Queue" title="queues.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a>.
Simultaneously create a <a class="reference internal" href="tdt.html#tdt.nutrition.NutritionStore" title="tdt.nutrition.NutritionStore"><code class="xref py py-class docutils literal notranslate"><span class="pre">NutritionStore</span></code></a> and the <a class="reference internal" href="tdt.html#tdt.algorithms.cataldi.Cataldi" title="tdt.algorithms.cataldi.Cataldi"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cataldi</span></code></a> TDT algorithm.
In addition, create the <a class="reference internal" href="summarization.html#summarization.algorithms.mmr.MMR" title="summarization.algorithms.mmr.MMR"><code class="xref py py-class docutils literal notranslate"><span class="pre">MMR</span></code></a> algorithm for summarization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>queue</strong> (<a class="reference internal" href="#queues.Queue" title="queues.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a>) – The queue that is consumed.</p></li>
<li><p><strong>periodicity</strong> (<em>int</em>) – The time window in seconds of the buffered consumer, or how often it is invoked.
This defaults to 5 seconds, the same span as half the smallest time window in Zhao et al.’s algorithm.</p></li>
<li><p><strong>scheme</strong> (None or <a class="reference internal" href="nlp.html#nlp.weighting.TermWeightingScheme" title="nlp.weighting.TermWeightingScheme"><code class="xref py py-class docutils literal notranslate"><span class="pre">TermWeightingScheme</span></code></a>) – The term-weighting scheme that is used to create dimensions.
If <cite>None</cite> is given, the <a class="reference internal" href="nlp.html#nlp.weighting.tf.TF" title="nlp.weighting.tf.TF"><code class="xref py py-class docutils literal notranslate"><span class="pre">TF</span></code></a> term-weighting scheme is used.</p></li>
<li><p><strong>sets</strong> (<em>int</em>) – The number of time windows that are considered when computing burst.
The higher this number, the more precise the calculations.
However, because of the decay in <a class="reference internal" href="tdt.html#tdt.algorithms.cataldi.Cataldi" title="tdt.algorithms.cataldi.Cataldi"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cataldi</span></code></a>, old time windows do not affect the result by a big margin.
Therefore old data can be removed safely.</p></li>
<li><p><strong>threshold</strong> (<em>float</em>) – The similarity threshold to use for the <a class="reference internal" href="vsm.html#vsm.clustering.algorithms.temporal_no_k_means.TemporalNoKMeans" title="vsm.clustering.algorithms.temporal_no_k_means.TemporalNoKMeans"><code class="xref py py-class docutils literal notranslate"><span class="pre">TemporalNoKMeans</span></code></a> incremental clustering approach.
Documents are added to an existing cluster if their similarity with the centroid is greater than or equal to this threshold.</p></li>
<li><p><strong>freeze_period</strong> (<em>float</em>) – The freeze period, in seconds, of the incremental clustering approach.</p></li>
<li><p><strong>min_size</strong> (<em>int</em>) – The minimum size for a cluster to be considered to be a candidate breaking topic.
This value is inclusive.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-queues.consumers.algorithms.eld_consumer">
<span id="eld-consumer-mamo-et-al-2019"></span><h4>ELD Consumer - Mamo et al. (2019)<a class="headerlink" href="#module-queues.consumers.algorithms.eld_consumer" title="Permalink to this headline">¶</a></h4>
<p>Event TimeLine Detection (ELD) is a real-time consumer based on the publication having the same name by Mamo et al. (2019).</p>
<p>ELD’s processing, unlike other <a class="reference internal" href="#id1"><span class="std std-ref">consumers</span></a>, splits processing into two steps:</p>
<ol class="arabic simple">
<li><p>Understand the event in terms of its participants and, superficially, its domain.
ELD does not really use the participants—it’s only a proof-of-concept.
The domain is a <a class="reference internal" href="nlp.html#nlp.weighting.TermWeightingScheme" title="nlp.weighting.TermWeightingScheme"><code class="xref py py-class docutils literal notranslate"><span class="pre">TermWeightingScheme</span></code></a> with an <a class="reference internal" href="nlp.html#nlp.weighting.global_schemes.idf.IDF" title="nlp.weighting.global_schemes.idf.IDF"><code class="xref py py-class docutils literal notranslate"><span class="pre">IDF</span></code></a> table based on the pre-event discussion.</p></li>
<li><p>Build a timeline for the event.
This approach is based on the <code class="xref py py-class docutils literal notranslate"><span class="pre">FIREConsumer</span></code>, in that it is a combination of document-pivot and feature-approaches.
First, it incrementally clusters incoming tweets, and then validates clusters, checking whether they contain breaking terms.
The check, again, uses the local-global comparison between clusters and previous time-windows, which ELD calls checkpoints.
Unlike the <code class="xref py py-class docutils literal notranslate"><span class="pre">FIREConsumer</span></code>, ELD uses a custom TDT feature-pivot approach: <a class="reference internal" href="tdt.html#tdt.algorithms.eld.ELD" title="tdt.algorithms.eld.ELD"><code class="xref py py-class docutils literal notranslate"><span class="pre">ELD</span></code></a>.</p></li>
</ol>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This implementation is based on the algorithm presented in <a class="reference external" href="https://dl.acm.org/doi/10.1145/3342220.3344921">ELD: Event TimeLine Detection – A Participant-Based Approach to Tracking Events by Mamo et al. (2019)</a>.</p>
</div>
<dl class="class">
<dt id="queues.consumers.algorithms.eld_consumer.ELDConsumer">
<em class="property">class </em><code class="sig-name descname">ELDConsumer</code><span class="sig-paren">(</span><em class="sig-param">queue</em>, <em class="sig-param">time_window=30</em>, <em class="sig-param">scheme=None</em>, <em class="sig-param">threshold=0.5</em>, <em class="sig-param">freeze_period=20</em>, <em class="sig-param">min_size=3</em>, <em class="sig-param">cooldown=1</em>, <em class="sig-param">max_intra_similarity=0.8</em>, <em class="sig-param">sets=10</em>, <em class="sig-param">min_burst=0.5</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.algorithms.eld_consumer.ELDConsumer" title="Permalink to this definition">¶</a></dt>
<dd><p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">ELDConsumer</span></code> is a real-time consumer with a custom algorithm to detect topics.
Unlike other <a class="reference internal" href="#id1"><span class="std std-ref">consumers</span></a>, the consumer has both a <code class="xref py py-func docutils literal notranslate"><span class="pre">run()</span></code> and a <code class="xref py py-func docutils literal notranslate"><span class="pre">understand()</span></code> functions.
The former is the normal processing step, whereas the <code class="xref py py-func docutils literal notranslate"><span class="pre">understand()</span></code> precedes the event.</p>
<p>During understanding, the <code class="xref py py-class docutils literal notranslate"><span class="pre">ELDConsumer</span></code> performs two tasks:</p>
<ol class="arabic simple">
<li><p>It detects the event’s participants using the pre-event chatter.
The <code class="xref py py-class docutils literal notranslate"><span class="pre">ELDConsumer</span></code> does not use these participants; it’s only a proof-of-concept.</p></li>
<li><p>It creates a <a class="reference internal" href="nlp.html#nlp.weighting.TermWeightingScheme" title="nlp.weighting.TermWeightingScheme"><code class="xref py py-class docutils literal notranslate"><span class="pre">TermWeightingScheme</span></code></a> with an <a class="reference internal" href="nlp.html#nlp.weighting.global_schemes.idf.IDF" title="nlp.weighting.global_schemes.idf.IDF"><code class="xref py py-class docutils literal notranslate"><span class="pre">IDF</span></code></a> table based on the pre-event discussion.</p></li>
</ol>
<p>During processing, the <code class="xref py py-class docutils literal notranslate"><span class="pre">ELDConsumer</span></code> creates checkpoints at every ‘time-window’.
These checkpoints represent the global context, or how the terms’ nutrition changed over time.
The <code class="xref py py-class docutils literal notranslate"><span class="pre">ELDConsumer</span></code> uses a <a class="reference internal" href="#queues.Queue" title="queues.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a> as a temporary buffer for tweets until they make up a checkpoint.
The consumer stores them in a <a class="reference internal" href="tdt.html#tdt.nutrition.memory.MemoryNutritionStore" title="tdt.nutrition.memory.MemoryNutritionStore"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemoryNutritionStore</span></code></a>.</p>
<p>The actual processing uses the <a class="reference internal" href="vsm.html#vsm.clustering.algorithms.temporal_no_k_means.TemporalNoKMeans" title="vsm.clustering.algorithms.temporal_no_k_means.TemporalNoKMeans"><code class="xref py py-class docutils literal notranslate"><span class="pre">TemporalNoKMeans</span></code></a> to create clusters.
The <code class="xref py py-class docutils literal notranslate"><span class="pre">ELDConsumer</span></code> goes over <a class="reference internal" href="vsm.html#vsm.clustering.cluster.Cluster" title="vsm.clustering.cluster.Cluster"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cluster</span></code></a> instances having a <code class="docutils literal notranslate"><span class="pre">min_size</span></code> and checks whether they have breaking terms.
The check uses the <a class="reference internal" href="tdt.html#tdt.algorithms.eld.ELD" title="tdt.algorithms.eld.ELD"><code class="xref py py-class docutils literal notranslate"><span class="pre">ELD</span></code></a> algorithm.
The <code class="xref py py-class docutils literal notranslate"><span class="pre">ELDConsumer</span></code> uses a <code class="docutils literal notranslate"><span class="pre">cooldown</span></code> parameter to avoid checking the same <a class="reference internal" href="vsm.html#vsm.clustering.cluster.Cluster" title="vsm.clustering.cluster.Cluster"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cluster</span></code></a> repeatedly in a short amount of time.
Since the <a class="reference internal" href="tdt.html#tdt.algorithms.eld.ELD" title="tdt.algorithms.eld.ELD"><code class="xref py py-class docutils literal notranslate"><span class="pre">ELD</span></code></a> algorithm uses a decay factor, a few <code class="docutils literal notranslate"><span class="pre">sets</span></code> (or checkpoints) can be used.
Furthermore, the <a class="reference internal" href="tdt.html#tdt.algorithms.eld.ELD" title="tdt.algorithms.eld.ELD"><code class="xref py py-class docutils literal notranslate"><span class="pre">ELD</span></code></a> algorithm’s output is interpretable, so the minimum burst—<code class="docutils literal notranslate"><span class="pre">min_burst</span></code>—can be set.</p>
<p>To convert tweets into <a class="reference internal" href="nlp.html#nlp.document.Document" title="nlp.document.Document"><code class="xref py py-class docutils literal notranslate"><span class="pre">Document</span></code></a> instances, the <code class="xref py py-class docutils literal notranslate"><span class="pre">ELDConsumer</span></code> also stores a <a class="reference internal" href="nlp.html#nlp.tokenizer.Tokenizer" title="nlp.tokenizer.Tokenizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tokenizer</span></code></a> and a <a class="reference internal" href="nlp.html#nlp.weighting.TermWeightingScheme" title="nlp.weighting.TermWeightingScheme"><code class="xref py py-class docutils literal notranslate"><span class="pre">TermWeightingScheme</span></code></a>.</p>
<p>Summarization uses the <a class="reference internal" href="summarization.html#summarization.algorithms.dgs.DGS" title="summarization.algorithms.dgs.DGS"><code class="xref py py-class docutils literal notranslate"><span class="pre">DGS</span></code></a> algorithm, which was developed as part of ELD.</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>time_window</strong> (<em>int</em>) – The size of the window after which checkpoints are created.</p></li>
<li><p><strong>scheme</strong> (<a class="reference internal" href="nlp.html#nlp.weighting.TermWeightingScheme" title="nlp.weighting.TermWeightingScheme"><code class="xref py py-class docutils literal notranslate"><span class="pre">TermWeightingScheme</span></code></a>) – The term-weighting scheme used to create documents.</p></li>
<li><p><strong>min_size</strong> (<em>int</em>) – The minimum size of a cluster to be considered valid.</p></li>
<li><p><strong>cooldown</strong> (<em>float</em>) – The minimum time, in seconds, between consecutive checks of a cluster.</p></li>
<li><p><strong>max_intra_similarity</strong> (<em>float</em>) – The maximum average similarity, between 0 and 1, of the cluster’s documents with the centroid.
Used to filter out clusters that include only retweets of the same, or almost identical documents.</p></li>
<li><p><strong>sets</strong> (<em>int</em>) – The number of time windows that are considered when computing burst.
The higher this number, the more precise the calculations.
However, because of the decay in <a class="reference internal" href="tdt.html#tdt.algorithms.eld.ELD" title="tdt.algorithms.eld.ELD"><code class="xref py py-class docutils literal notranslate"><span class="pre">ELD</span></code></a>, old time windows do not affect the result by a big margin.
Therefore old data can be removed safely.</p></li>
<li><p><strong>min_burst</strong> (<em>float</em>) – The minimum burst of a term to be considered emerging and returned.
This value is exclusive.</p></li>
<li><p><strong>store</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">NutritionStore</span></code>) – The nutrition store used in conjunction with extractin breaking news.</p></li>
<li><p><strong>buffer</strong> (<a class="reference internal" href="#queues.Queue" title="queues.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a>) – A buffer of tweets that have been processed, but which are not part of a checkpoint yet.</p></li>
<li><p><strong>tokenizer</strong> (<a class="reference internal" href="nlp.html#nlp.tokenizer.Tokenizer" title="nlp.tokenizer.Tokenizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tokenizer</span></code></a>) – The tokenizer used to create documents and create the IDF table, among others.</p></li>
<li><p><strong>clustering</strong> (<a class="reference internal" href="vsm.html#vsm.clustering.algorithms.temporal_no_k_means.TemporalNoKMeans" title="vsm.clustering.algorithms.temporal_no_k_means.TemporalNoKMeans"><code class="xref py py-class docutils literal notranslate"><span class="pre">TemporalNoKMeans</span></code></a>) – The clustering algorithm to use.</p></li>
<li><p><a class="reference internal" href="tdt.html#module-tdt" title="tdt"><strong>tdt</strong></a> (<a class="reference internal" href="tdt.html#tdt.algorithms.eld.ELD" title="tdt.algorithms.eld.ELD"><code class="xref py py-class docutils literal notranslate"><span class="pre">ELD</span></code></a>) – The TDT algorithm used to detect breaking developments.</p></li>
<li><p><a class="reference internal" href="summarization.html#module-summarization" title="summarization"><strong>summarization</strong></a> (<a class="reference internal" href="summarization.html#summarization.algorithms.dgs.DGS" title="summarization.algorithms.dgs.DGS"><code class="xref py py-class docutils literal notranslate"><span class="pre">DGS</span></code></a>) – The summarization algorithm used to create the timeline.</p></li>
<li><p><strong>cleaner</strong> (<a class="reference internal" href="nlp.html#nlp.cleaners.tweet_cleaner.TweetCleaner" title="nlp.cleaners.tweet_cleaner.TweetCleaner"><code class="xref py py-class docutils literal notranslate"><span class="pre">TweetCleaner</span></code></a>) – The cleaner used to make summaries more presentable.</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="queues.consumers.algorithms.eld_consumer.ELDConsumer.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">queue</em>, <em class="sig-param">time_window=30</em>, <em class="sig-param">scheme=None</em>, <em class="sig-param">threshold=0.5</em>, <em class="sig-param">freeze_period=20</em>, <em class="sig-param">min_size=3</em>, <em class="sig-param">cooldown=1</em>, <em class="sig-param">max_intra_similarity=0.8</em>, <em class="sig-param">sets=10</em>, <em class="sig-param">min_burst=0.5</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.algorithms.eld_consumer.ELDConsumer.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the consumer with a queue.
Simultaneously create a nutrition store and the topic detection algorithm container.
Initially, the IDF table should be empty.
It will be populated later when the ‘reconaissance’ period is finished.</p>
<p>The constructor also creates a buffer.
This buffer is used to store tweets until they are made into a checkpoint.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>queue</strong> (<a class="reference internal" href="#queues.Queue" title="queues.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a>) – The queue that is consumed.</p></li>
<li><p><strong>time_window</strong> (<em>int</em>) – The size of the window after which checkpoints are created.</p></li>
<li><p><strong>scheme</strong> (None or <a class="reference internal" href="nlp.html#nlp.weighting.TermWeightingScheme" title="nlp.weighting.TermWeightingScheme"><code class="xref py py-class docutils literal notranslate"><span class="pre">TermWeightingScheme</span></code></a>) – The term-weighting scheme that is used to create dimensions.
If <cite>None</cite> is given, the <a class="reference internal" href="nlp.html#nlp.weighting.tf.TF" title="nlp.weighting.tf.TF"><code class="xref py py-class docutils literal notranslate"><span class="pre">TF</span></code></a> term-weighting scheme is used.</p></li>
<li><p><strong>threshold</strong> (<em>float</em>) – The similarity threshold to use for the <a class="reference internal" href="vsm.html#vsm.clustering.algorithms.temporal_no_k_means.TemporalNoKMeans" title="vsm.clustering.algorithms.temporal_no_k_means.TemporalNoKMeans"><code class="xref py py-class docutils literal notranslate"><span class="pre">TemporalNoKMeans</span></code></a> incremental clustering approach.
Documents are added to an existing cluster if their similarity with the centroid is greater than or equal to this threshold.</p></li>
<li><p><strong>freeze_period</strong> (<em>float</em>) – The freeze period, in seconds, of the incremental clustering approach.</p></li>
<li><p><strong>min_size</strong> (<em>int</em>) – The minimum size of a cluster to be considered valid.</p></li>
<li><p><strong>cooldown</strong> (<em>float</em>) – The minimum time, in seconds, between consecutive checks of a cluster.</p></li>
<li><p><strong>max_intra_similarity</strong> (<em>float</em>) – The maximum average similarity, between 0 and 1, of the cluster’s documents with the centroid.
Used to filter out clusters that include only retweets of the same, or almost identical documents.</p></li>
<li><p><strong>sets</strong> (<em>int</em>) – The number of time windows that are considered when computing burst.
The higher this number, the more precise the calculations.
However, because of the decay in <a class="reference internal" href="tdt.html#tdt.algorithms.eld.ELD" title="tdt.algorithms.eld.ELD"><code class="xref py py-class docutils literal notranslate"><span class="pre">ELD</span></code></a>, old time windows do not affect the result by a big margin.
Therefore old data can be removed safely.</p></li>
<li><p><strong>min_burst</strong> (<em>float</em>) – The minimum burst of a term to be considered emerging and returned.
This value is exclusive.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.consumers.algorithms.eld_consumer.ELDConsumer.understand">
<em class="property">async </em><code class="sig-name descname">understand</code><span class="sig-paren">(</span><em class="sig-param">max_inactivity=-1</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.algorithms.eld_consumer.ELDConsumer.understand" title="Permalink to this definition">¶</a></dt>
<dd><p>Understanding precedes the event and is tasked with generating knowledge automatically.</p>
<p>During understanding, the <code class="xref py py-class docutils literal notranslate"><span class="pre">ELDConsumer</span></code> performs two tasks:</p>
<ol class="arabic simple">
<li><p>It detects the event’s participants using the pre-event chatter.
The <code class="xref py py-class docutils literal notranslate"><span class="pre">ELDConsumer</span></code> does not use these participants; it’s only a proof-of-concept.</p></li>
<li><p>It creates a <a class="reference internal" href="nlp.html#nlp.weighting.TermWeightingScheme" title="nlp.weighting.TermWeightingScheme"><code class="xref py py-class docutils literal notranslate"><span class="pre">TermWeightingScheme</span></code></a> with an <a class="reference internal" href="nlp.html#nlp.weighting.global_schemes.idf.IDF" title="nlp.weighting.global_schemes.idf.IDF"><code class="xref py py-class docutils literal notranslate"><span class="pre">IDF</span></code></a> table based on the pre-event discussion.
The consumer uses the <a class="reference internal" href="nlp.html#nlp.weighting.TermWeightingScheme" title="nlp.weighting.TermWeightingScheme"><code class="xref py py-class docutils literal notranslate"><span class="pre">TermWeightingScheme</span></code></a> while processing tweets in real-time.</p></li>
</ol>
<p>The function returns both as a dictionary.
The two keys are <code class="docutils literal notranslate"><span class="pre">scheme</span></code> and <cite>d`participants</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>max_inactivity</strong> (<em>int</em>) – The maximum time in seconds to wait idly without input before stopping.
If it is negative, it is ignored.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A dictionary containing the TF-IDF scheme and the event’s participants from the pre-event discussion.
The TF-IDF scheme is returned in the <cite>scheme</cite> key as a <a class="reference internal" href="nlp.html#nlp.weighting.tfidf.TFIDF" title="nlp.weighting.tfidf.TFIDF"><code class="xref py py-class docutils literal notranslate"><span class="pre">TFIDF</span></code></a> instance.
The participants are returned in the <cite>participants</cite> key a list of strings.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="ml.html" class="btn btn-neutral float-right" title="10. Machine Learning" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="twitter.html" class="btn btn-neutral float-left" title="8. Twitter" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Nicholas Mamo

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>