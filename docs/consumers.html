

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta content="The consumer functionality of EvenTDT" name="description" />
<meta content="Python, TDT, queue, consumer" name="keywords" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>9. Consumers &mdash; EvenTDT 0.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/eventdt.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="10. Machine Learning" href="ml.html" />
    <link rel="prev" title="8. Twitter" href="twitter.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> EvenTDT
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="config.html">0. Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="tools.html">1. Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="vsm.html">2. Vector Space Model (VSM)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nlp.html">3. Natural Language Processing (NLP)</a></li>
<li class="toctree-l1"><a class="reference internal" href="wikinterface.html">4. Wikinterface</a></li>
<li class="toctree-l1"><a class="reference internal" href="apd.html">5. Automatic Participant Detection (APD)</a></li>
<li class="toctree-l1"><a class="reference internal" href="tdt.html">6. Topic Detection and Tracking (TDT)</a></li>
<li class="toctree-l1"><a class="reference internal" href="summarization.html">7. Summarization</a></li>
<li class="toctree-l1"><a class="reference internal" href="twitter.html">8. Twitter</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">9. Consumers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#queues">Queues</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id1">Consumers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-queues.consumers.print_consumer">Simple Consumers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-queues.consumers.eld_consumer">Algorithms</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ml.html">10. Machine Learning</a></li>
<li class="toctree-l1"><a class="reference internal" href="ate.html">11. Automatic Term Extraction (ATE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="other.html">12. Other</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">EvenTDT</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>9. Consumers</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/consumers.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
    <div class="section" id="consumers">
<h1>9. Consumers<a class="headerlink" href="#consumers" title="Permalink to this headline">¶</a></h1>
<div class="section" id="queues">
<h2>Queues<a class="headerlink" href="#queues" title="Permalink to this headline">¶</a></h2>
<p>EvenTDT collects tweets and processes them.
In-between collecting and processing, the tweets go into a queue data structure.
In this way, the consumers can process the data in the same order as it was received.
The queue functionality is a special class.</p>
<span class="target" id="module-queues.queue"></span><p>Queues are first in, first out (FIFO) data structures.
This implementation is based on lists.
Queue-specific functionality is introduced as functions.</p>
<dl class="class">
<dt id="queues.queue.Queue">
<em class="property">class </em><code class="sig-name descname">Queue</code><span class="sig-paren">(</span><em class="sig-param">*args</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.queue.Queue" title="Permalink to this definition">¶</a></dt>
<dd><p>The queue data structure is based on a list.
The queue can take in any kind of data, including other queues.
New elements are added to the queue at the end.</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><p><a class="reference internal" href="#module-queues.queue" title="queues.queue"><strong>queue</strong></a> (<em>list</em>) – The queue data structure.</p>
</dd>
</dl>
<dl class="method">
<dt id="queues.queue.Queue.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">*args</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.queue.Queue.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the queue.
The queue’s data can be given as normal arguments.</p>
</dd></dl>

<dl class="method">
<dt id="queues.queue.Queue.enqueue">
<code class="sig-name descname">enqueue</code><span class="sig-paren">(</span><em class="sig-param">*args</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.queue.Queue.enqueue" title="Permalink to this definition">¶</a></dt>
<dd><p>Add the given data to the queue.
All arguments can be provided as arguments.</p>
</dd></dl>

<dl class="method">
<dt id="queues.queue.Queue.dequeue">
<code class="sig-name descname">dequeue</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#queues.queue.Queue.dequeue" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the first element in the queue.
If the queue is empty, <cite>None</cite> is returned instead</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The first element in the queue.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>object or None</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.queue.Queue.dequeue_all">
<code class="sig-name descname">dequeue_all</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#queues.queue.Queue.dequeue_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Dequeue all elements in the queue.
Unlike the <a class="reference internal" href="#queues.queue.Queue.empty" title="queues.queue.Queue.empty"><code class="xref py py-func docutils literal notranslate"><span class="pre">empty()</span></code></a> function, this function returns all of the queue’s elements.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>All the elements in the queue.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.queue.Queue.empty">
<code class="sig-name descname">empty</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#queues.queue.Queue.empty" title="Permalink to this definition">¶</a></dt>
<dd><p>Empty the queue.
Unlike the <a class="reference internal" href="#queues.queue.Queue.dequeue_all" title="queues.queue.Queue.dequeue_all"><code class="xref py py-func docutils literal notranslate"><span class="pre">dequeue_all()</span></code></a> function, this function returns nothing.</p>
</dd></dl>

<dl class="method">
<dt id="queues.queue.Queue.length">
<code class="sig-name descname">length</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#queues.queue.Queue.length" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the length of the queue.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The length of the queue.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.queue.Queue.head">
<code class="sig-name descname">head</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#queues.queue.Queue.head" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the first element entered into the queue without removing it.
If the queue is empty, <cite>None</cite> is returned instead</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The oldest element in the queue.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>object or None</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.queue.Queue.tail">
<code class="sig-name descname">tail</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#queues.queue.Queue.tail" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the last element entered into the queue without removing it.
If the queue is empty, <cite>None</cite> is returned instead</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The newest element in the queue.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>object or None</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="queues.queue.Queue.__weakref__">
<code class="sig-name descname">__weakref__</code><a class="headerlink" href="#queues.queue.Queue.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id1">
<span id="id2"></span><h2>Consumers<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>Queue data is consumed by consumers.
Each consumer dequeues the accumulated data and processes it or outputs it.
There are various base classes for consumers, covering both real-time and buffered consumption.</p>
<span class="target" id="module-queues.consumers.consumer"></span><p>All consumers follow a simple workflow.
After initialization with a queue, the consumer can be run using the <a class="reference internal" href="#queues.consumers.consumer.Consumer.run" title="queues.consumers.consumer.Consumer.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">run()</span></code></a> function.
That function prepares to start consuming the queue and calls the <code class="xref py py-func docutils literal notranslate"><span class="pre">_consume()</span></code> function.</p>
<p>Consumers have two other state variables apart from the queue: the <cite>active</cite> and <cite>stopped</cite> variables.
The <cite>active</cite> variable indicates whether the consumer is still accepting objects.
The <cite>stopped</cite> variable indicates whether the consumer has finished consuming all objects.
Generally, consumers keep accepting objects until the <cite>active</cite> variable is disabled.
At that point, they process the last objects and set the <cite>stopped</cite> flag to <cite>True</cite>.</p>
<dl class="class">
<dt id="queues.consumers.consumer.Consumer">
<em class="property">class </em><code class="sig-name descname">Consumer</code><span class="sig-paren">(</span><em class="sig-param">queue</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.consumer.Consumer" title="Permalink to this definition">¶</a></dt>
<dd><p>The abstract Consumer class outlines the necessary functions of a consumer.
It also defines the state of the consumer.</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><ul class="simple">
<li><p><a class="reference internal" href="#module-queues.queue" title="queues.queue"><strong>queue</strong></a> (<a class="reference internal" href="#queues.queue.Queue" title="queues.queue.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a>) – The queue that is to be consumed.</p></li>
<li><p><strong>active</strong> (<em>bool</em>) – A boolean indicating whether the consumer is still accepting data.</p></li>
<li><p><strong>stopped</strong> (<em>bool</em>) – A boolean indicating whether the consumer has finished processing.</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="queues.consumers.consumer.Consumer.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">queue</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.consumer.Consumer.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the Consumer with its queue.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>queue</strong> – The queue that will be consumed.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.consumers.consumer.Consumer.run">
<em class="property">async </em><code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param">wait=0</em>, <em class="sig-param">max_inactivity=-1</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.consumer.Consumer.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Invoke the consume method.
Since some listeners have a small delay, the consumer may wait a bit before starting to consume input.</p>
<p>Any additional arguments and keyword arguments are passed on to the <code class="xref py py-func docutils literal notranslate"><span class="pre">_consume()</span></code> function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>wait</strong> (<em>int</em>) – The time in seconds to wait until starting to consume the event.
This is used when the file listener spends a lot of time skipping tweets.</p></li>
<li><p><strong>max_inactivity</strong> (<em>int</em>) – The maximum time in seconds to wait idly without input before stopping.
If it is negative, the consumer keeps waiting for input until the maximum time expires.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The output of the consume method.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>any</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.consumers.consumer.Consumer.stop">
<code class="sig-name descname">stop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.consumer.Consumer.stop" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a flag to stop accepting new objects.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Contrary to the name of the function, the function sets the <cite>active</cite> flag, not the <cite>stopped</cite> flag.
This function merely asks that the consumer stops accepting new objects for processing.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="queues.consumers.consumer.Consumer.__weakref__">
<code class="sig-name descname">__weakref__</code><a class="headerlink" href="#queues.consumers.consumer.Consumer.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-queues.consumers.buffered_consumer"></span><p>A buffered consumer processes content in batches.</p>
<dl class="class">
<dt id="queues.consumers.buffered_consumer.BufferedConsumer">
<em class="property">class </em><code class="sig-name descname">BufferedConsumer</code><span class="sig-paren">(</span><em class="sig-param">queue</em>, <em class="sig-param">periodicity=60</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.buffered_consumer.BufferedConsumer" title="Permalink to this definition">¶</a></dt>
<dd><p>The buffered consumer adds the processing stage apart from the consumption.
The <code class="xref py py-func docutils literal notranslate"><span class="pre">_consume()</span></code> function function waits until objects become available in the queue.
The <code class="xref py py-func docutils literal notranslate"><span class="pre">_process()</span></code> function empties this buffer and processes it.
The two functions communicate with each other using a common queue, called a buffer.</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>periodicity</strong> (<em>int</em>) – The time window in seconds of the buffered consumer, or how often it is invoked.</p></li>
<li><p><a class="reference internal" href="#queues.consumers.eld_consumer.ELDConsumer.buffer" title="queues.consumers.eld_consumer.ELDConsumer.buffer"><strong>buffer</strong></a> (<a class="reference internal" href="#queues.queue.Queue" title="queues.queue.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a>) – The buffer of objects that have to be processed.</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="queues.consumers.buffered_consumer.BufferedConsumer.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">queue</em>, <em class="sig-param">periodicity=60</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.buffered_consumer.BufferedConsumer.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the buffered consumer with its queue and periodicity.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>queue</strong> (<a class="reference internal" href="#queues.queue.Queue" title="queues.queue.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a>) – The queue that is consumed.</p></li>
<li><p><strong>periodicity</strong> (<em>int</em>) – The time window in seconds of the buffered consumer, or how often it is invoked.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.consumers.buffered_consumer.BufferedConsumer.run">
<em class="property">async </em><code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param">wait=0</em>, <em class="sig-param">max_inactivity=-1</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.buffered_consumer.BufferedConsumer.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Invokes the consume and process method.</p>
<p>Any additional arguments and keyword arguments are passed on to the <code class="xref py py-class docutils literal notranslate"><span class="pre">_consume</span></code> and <code class="xref py py-class docutils literal notranslate"><span class="pre">_process</span></code> functions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>wait</strong> (<em>int</em>) – The time in seconds to wait until starting to understand the event.
This is used when the file listener spends a lot of time skipping documents.</p></li>
<li><p><strong>max_inactivity</strong> (<em>int</em>) – The maximum time in seconds to wait idly without input before stopping.
If it is negative, the consumer keeps waiting for input until the maximum time expires.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The output of the consume method.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>any</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="queues.consumers.buffered_consumer.SimulatedBufferedConsumer">
<em class="property">class </em><code class="sig-name descname">SimulatedBufferedConsumer</code><span class="sig-paren">(</span><em class="sig-param">queue</em>, <em class="sig-param">periodicity</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.buffered_consumer.SimulatedBufferedConsumer" title="Permalink to this definition">¶</a></dt>
<dd><p>The simulated buffered consumer is exactly like the buffered consumer, but its periodicity is not real-time.
Instead, it gets the time from the incoming message.
This class can be used in a simulated environment, such as when data has been collected.
In this case, it allows the data to be consumed at the rate that it is read.</p>
<dl class="method">
<dt id="queues.consumers.buffered_consumer.SimulatedBufferedConsumer.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">queue</em>, <em class="sig-param">periodicity</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.buffered_consumer.SimulatedBufferedConsumer.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the simulated buffered consumer with its queue, periodicity and buffer.
The timestamp parameter is the field that the sleep function checks to know when it should awake.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>queue</strong> (<a class="reference internal" href="#queues.queue.Queue" title="queues.queue.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a>) – The queue that is consumed.</p></li>
<li><p><strong>periodicity</strong> (<em>int</em>) – The time window in seconds of the buffered consumer, or how often it is invoked.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<div class="section" id="module-queues.consumers.print_consumer">
<span id="simple-consumers"></span><h3>Simple Consumers<a class="headerlink" href="#module-queues.consumers.print_consumer" title="Permalink to this headline">¶</a></h3>
<p>The print consumer outputs the queue’s elements as they arrive.</p>
<dl class="class">
<dt id="queues.consumers.print_consumer.PrintConsumer">
<em class="property">class </em><code class="sig-name descname">PrintConsumer</code><span class="sig-paren">(</span><em class="sig-param">queue</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.print_consumer.PrintConsumer" title="Permalink to this definition">¶</a></dt>
<dd><p>The print consumer prints queue messages and discards them.</p>
</dd></dl>

<span class="target" id="module-queues.consumers.stat_consumer"></span><p>The statistic consumer is a simple consumer that reports statistics about tweets periodically.</p>
<dl class="class">
<dt id="queues.consumers.stat_consumer.StatConsumer">
<em class="property">class </em><code class="sig-name descname">StatConsumer</code><span class="sig-paren">(</span><em class="sig-param">queue</em>, <em class="sig-param">periodicity=60</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.stat_consumer.StatConsumer" title="Permalink to this definition">¶</a></dt>
<dd><p>The statistic consumer is a simple consumer that reports statistics about tweets periodically.
The reporting is done based on the periodicity.</p>
</dd></dl>

</div>
<div class="section" id="module-queues.consumers.eld_consumer">
<span id="algorithms"></span><span id="consumers-algorithms"></span><h3>Algorithms<a class="headerlink" href="#module-queues.consumers.eld_consumer" title="Permalink to this headline">¶</a></h3>
<p>Event TimeLine Detection (ELD) is a consumer based on a publication of the same name.
The approach splits processing into two steps:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Understand the event, and</p></li>
<li><p>Build a timeline for it.</p></li>
</ol>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Implementation based on the algorithm presented in <a class="reference external" href="https://dl.acm.org/doi/10.1145/3342220.3344921">ELD: Event TimeLine Detection – A Participant-Based Approach to Tracking Events by Mamo et al. (2019)</a>.</p>
</div>
<dl class="class">
<dt id="queues.consumers.eld_consumer.ELDConsumer">
<em class="property">class </em><code class="sig-name descname">ELDConsumer</code><span class="sig-paren">(</span><em class="sig-param">queue</em>, <em class="sig-param">time_window=30</em>, <em class="sig-param">scheme=None</em>, <em class="sig-param">threshold=0.5</em>, <em class="sig-param">freeze_period=20</em>, <em class="sig-param">min_size=3</em>, <em class="sig-param">cooldown=1</em>, <em class="sig-param">max_intra_similarity=0.8</em>, <em class="sig-param">sets=10</em>, <em class="sig-param">min_burst=0.5</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.eld_consumer.ELDConsumer" title="Permalink to this definition">¶</a></dt>
<dd><p>The ELD consumer is a real-time consumer with a custom algorithm to detect topics.
It is siplit into two steps:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Understand the event, and</p></li>
<li><p>Build a timeline for it.</p></li>
</ol>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>time_window</strong> (<em>int</em>) – The time (in seconds) to spend consuming the queue.</p></li>
<li><p><strong>scheme</strong> (<a class="reference internal" href="nlp.html#nlp.weighting.TermWeightingScheme" title="nlp.weighting.TermWeightingScheme"><code class="xref py py-class docutils literal notranslate"><span class="pre">TermWeightingScheme</span></code></a>) – The term-weighting scheme used to create documents.</p></li>
<li><p><strong>min_size</strong> (<em>int</em>) – The minimum size of a cluster to be considered valid.</p></li>
<li><p><strong>cooldown</strong> (<em>float</em>) – The minimum time (in seconds) between consecutive checks of a cluster.</p></li>
<li><p><strong>max_intra_similarity</strong> (<em>float</em>) – The maximum average similarity, between 0 and 1, of the cluster’s documents with the centroid.
Used to filter out clusters that include only retweets of the same, or almost identical documents.</p></li>
<li><p><strong>sets</strong> (<em>int</em>) – The number of time windows that are considered when computing burst.
The higher this number, the more precise the calculations.
However, because of the decay in <a class="reference internal" href="tdt.html#tdt.algorithms.eld.ELD" title="tdt.algorithms.eld.ELD"><code class="xref py py-class docutils literal notranslate"><span class="pre">ELD</span></code></a>, old time windows do not affect the result by a big margin.
Therefore old data can be removed safely.</p></li>
<li><p><a class="reference internal" href="#queues.consumers.eld_consumer.ELDConsumer.min_burst" title="queues.consumers.eld_consumer.ELDConsumer.min_burst"><strong>min_burst</strong></a> (<em>float</em>) – The minimum burst of a term to be considered emerging and returned.
This value is exclusive.</p></li>
<li><p><strong>store</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">NutritionStore</span></code>) – The nutrition store used in conjunction with extractin breaking news.</p></li>
<li><p><a class="reference internal" href="#queues.consumers.eld_consumer.ELDConsumer.buffer" title="queues.consumers.eld_consumer.ELDConsumer.buffer"><strong>buffer</strong></a> (<a class="reference internal" href="#queues.queue.Queue" title="queues.queue.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a>) – A buffer of tweets that have been processed, but which are not part of a checkpoint yet.</p></li>
<li><p><strong>tokenizer</strong> (<a class="reference internal" href="nlp.html#nlp.tokenizer.Tokenizer" title="nlp.tokenizer.Tokenizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tokenizer</span></code></a>) – The tokenizer used to create documents and create the IDF table, among others.</p></li>
<li><p><strong>clustering</strong> (<a class="reference internal" href="vsm.html#vsm.clustering.algorithms.temporal_no_k_means.TemporalNoKMeans" title="vsm.clustering.algorithms.temporal_no_k_means.TemporalNoKMeans"><code class="xref py py-class docutils literal notranslate"><span class="pre">TemporalNoKMeans</span></code></a>) – The clustering algorithm to use.</p></li>
<li><p><a class="reference internal" href="tdt.html#module-tdt" title="tdt"><strong>tdt</strong></a> (<a class="reference internal" href="tdt.html#tdt.algorithms.eld.ELD" title="tdt.algorithms.eld.ELD"><code class="xref py py-class docutils literal notranslate"><span class="pre">ELD</span></code></a>) – The TDT algorithm used to detect breaking developments.</p></li>
<li><p><a class="reference internal" href="summarization.html#module-summarization" title="summarization"><strong>summarization</strong></a> (<a class="reference internal" href="summarization.html#summarization.algorithms.dgs.DGS" title="summarization.algorithms.dgs.DGS"><code class="xref py py-class docutils literal notranslate"><span class="pre">DGS</span></code></a>) – The summarization algorithm used to create the timeline.</p></li>
<li><p><strong>cleaner</strong> (<a class="reference internal" href="nlp.html#nlp.cleaners.tweet_cleaner.TweetCleaner" title="nlp.cleaners.tweet_cleaner.TweetCleaner"><code class="xref py py-class docutils literal notranslate"><span class="pre">TweetCleaner</span></code></a>) – The cleaner used to make summaries more presentable.</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="queues.consumers.eld_consumer.ELDConsumer.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">queue</em>, <em class="sig-param">time_window=30</em>, <em class="sig-param">scheme=None</em>, <em class="sig-param">threshold=0.5</em>, <em class="sig-param">freeze_period=20</em>, <em class="sig-param">min_size=3</em>, <em class="sig-param">cooldown=1</em>, <em class="sig-param">max_intra_similarity=0.8</em>, <em class="sig-param">sets=10</em>, <em class="sig-param">min_burst=0.5</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.eld_consumer.ELDConsumer.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the consumer with a queue.
Simultaneously create a nutrition store and the topic detection algorithm container.
Initially, the IDF table should be empty.
It will be populated later when the ‘reconaissance’ period is finished.</p>
<p>The constructor also creates a buffer.
This buffer is used to store tweets until they are made into a checkpoint.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>queue</strong> (<a class="reference internal" href="#queues.queue.Queue" title="queues.queue.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a>) – The queue that is consumed.</p></li>
<li><p><strong>time_window</strong> (<em>int</em>) – The size of the window after which checkpoints are created.</p></li>
<li><p><strong>scheme</strong> (None or <a class="reference internal" href="nlp.html#nlp.weighting.TermWeightingScheme" title="nlp.weighting.TermWeightingScheme"><code class="xref py py-class docutils literal notranslate"><span class="pre">TermWeightingScheme</span></code></a>) – The term-weighting scheme that is used to create dimensions.
If <cite>None</cite> is given, the <a class="reference internal" href="nlp.html#nlp.weighting.tf.TF" title="nlp.weighting.tf.TF"><code class="xref py py-class docutils literal notranslate"><span class="pre">TF</span></code></a> term-weighting scheme is used.</p></li>
<li><p><strong>threshold</strong> (<em>float</em>) – The similarity threshold to use for the <a class="reference internal" href="vsm.html#vsm.clustering.algorithms.temporal_no_k_means.TemporalNoKMeans" title="vsm.clustering.algorithms.temporal_no_k_means.TemporalNoKMeans"><code class="xref py py-class docutils literal notranslate"><span class="pre">TemporalNoKMeans</span></code></a> incremental clustering approach.
Documents are added to an existing cluster if their similarity with the centroid is greater than or equal to this threshold.</p></li>
<li><p><strong>freeze_period</strong> (<em>float</em>) – The freeze period, in seconds, of the incremental clustering approach.</p></li>
<li><p><strong>min_size</strong> (<em>int</em>) – The minimum size of a cluster to be considered valid.</p></li>
<li><p><strong>cooldown</strong> (<em>float</em>) – The minimum time (in seconds) between consecutive checks of a cluster.</p></li>
<li><p><strong>max_intra_similarity</strong> (<em>float</em>) – The maximum average similarity, between 0 and 1, of the cluster’s documents with the centroid.
Used to filter out clusters that include only retweets of the same, or almost identical documents.</p></li>
<li><p><strong>sets</strong> (<em>int</em>) – The number of time windows that are considered when computing burst.
The higher this number, the more precise the calculations.
However, because of the decay in <a class="reference internal" href="tdt.html#tdt.algorithms.eld.ELD" title="tdt.algorithms.eld.ELD"><code class="xref py py-class docutils literal notranslate"><span class="pre">ELD</span></code></a>, old time windows do not affect the result by a big margin.
Therefore old data can be removed safely.</p></li>
<li><p><strong>min_burst</strong> (<em>float</em>) – The minimum burst of a term to be considered emerging and returned.
This value is exclusive.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="queues.consumers.eld_consumer.ELDConsumer.min_burst">
<code class="sig-name descname">min_burst</code><em class="property"> = None</em><a class="headerlink" href="#queues.consumers.eld_consumer.ELDConsumer.min_burst" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the nutrition store and the buffer.
The buffer stores tweets that have been processed, but not yet added to a checkpoint.</p>
</dd></dl>

<dl class="attribute">
<dt id="queues.consumers.eld_consumer.ELDConsumer.buffer">
<code class="sig-name descname">buffer</code><em class="property"> = None</em><a class="headerlink" href="#queues.consumers.eld_consumer.ELDConsumer.buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the different components of the system.</p>
</dd></dl>

<dl class="method">
<dt id="queues.consumers.eld_consumer.ELDConsumer.understand">
<em class="property">async </em><code class="sig-name descname">understand</code><span class="sig-paren">(</span><em class="sig-param">max_inactivity=-1</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.eld_consumer.ELDConsumer.understand" title="Permalink to this definition">¶</a></dt>
<dd><p>Understanding is split into two tasks:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Construct the TF-IDF scheme used from the pre-event discussion, and</p></li>
<li><p>Identify the event’s participants.</p></li>
</ol>
</div></blockquote>
<p>The function returns both as a dictionary.
The two keys are <cite>scheme</cite> and <cite>participants</cite>.</p>
<p>Any additional arguments and keyword arguments are passed on to the <code class="xref py py-func docutils literal notranslate"><span class="pre">_construct_idf()</span></code> and <code class="xref py py-func docutils literal notranslate"><span class="pre">_detect_participants()</span></code> functions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>max_inactivity</strong> (<em>int</em>) – The maximum time in seconds to wait idly without input before stopping.
If it is negative, it is ignored.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A dictionary containing the TF-IDF scheme and the event’s participants from the pre-event discussion.
The TF-IDF scheme is returned in the <cite>scheme</cite> key as a <a class="reference internal" href="nlp.html#nlp.weighting.tfidf.TFIDF" title="nlp.weighting.tfidf.TFIDF"><code class="xref py py-class docutils literal notranslate"><span class="pre">TFIDF</span></code></a> instance.
The participants are returned in the <cite>participants</cite> key a list of strings.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<span class="target" id="module-queues.consumers.fire_consumer"></span><p>Finding Important News REports (FIRE) is a periodic TDT consumer.
It takes in tweets every time window, clusters them and finds the most important terms in each cluster.
In this implementation, the tracking happens through the timeline.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Implementation based on the algorithm presented in <a class="reference external" href="https://link.springer.com/chapter/10.1007/978-3-319-74497-1_3">FIRE: Finding Important News REports by Mamo and Azzopardi (2017)</a>.</p>
</div>
<dl class="class">
<dt id="queues.consumers.fire_consumer.FIREConsumer">
<em class="property">class </em><code class="sig-name descname">FIREConsumer</code><span class="sig-paren">(</span><em class="sig-param">queue</em>, <em class="sig-param">periodicity=60</em>, <em class="sig-param">scheme=None</em>, <em class="sig-param">sets=10</em>, <em class="sig-param">threshold=0.7</em>, <em class="sig-param">freeze_period=20</em>, <em class="sig-param">min_size=4</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.fire_consumer.FIREConsumer" title="Permalink to this definition">¶</a></dt>
<dd><p>The FIRE consumer is based on the implementation of the same name.
The algorithm clusters all tweets received in the same period and uses the Cataldi et al. algorithm to identify which ones are breaking.</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>store</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">NutritionStore</span></code>) – The nutrition store used to store the volume changes of individual terms.</p></li>
<li><p><strong>scheme</strong> (<a class="reference internal" href="nlp.html#nlp.weighting.TermWeightingScheme" title="nlp.weighting.TermWeightingScheme"><code class="xref py py-class docutils literal notranslate"><span class="pre">TermWeightingScheme</span></code></a>) – The term-weighting scheme used to create documents.</p></li>
<li><p><strong>sets</strong> (<em>int</em>) – The number of time windows that are considered when computing burst.
The higher this number, the more precise the calculations.
However, because of the decay in <a class="reference internal" href="tdt.html#tdt.algorithms.cataldi.Cataldi" title="tdt.algorithms.cataldi.Cataldi"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cataldi</span></code></a>, old time windows do not affect the result by a big margin.
Therefore old data can be removed safely.</p></li>
<li><p><strong>min_size</strong> (<em>int</em>) – The minimum size for a cluster to be considered to be a candidate breaking topic.
This value is inclusive.</p></li>
<li><p><strong>tokenizer</strong> (<a class="reference internal" href="nlp.html#nlp.tokenizer.Tokenizer" title="nlp.tokenizer.Tokenizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tokenizer</span></code></a>) – The tokenizer used to create documents.</p></li>
<li><p><strong>clustering</strong> (<a class="reference internal" href="vsm.html#vsm.clustering.algorithms.temporal_no_k_means.TemporalNoKMeans" title="vsm.clustering.algorithms.temporal_no_k_means.TemporalNoKMeans"><code class="xref py py-class docutils literal notranslate"><span class="pre">TemporalNoKMeans</span></code></a>) – The clustering algorithm to use.</p></li>
<li><p><a class="reference internal" href="summarization.html#module-summarization" title="summarization"><strong>summarization</strong></a> (<a class="reference internal" href="summarization.html#summarization.algorithms.mmr.MMR" title="summarization.algorithms.mmr.MMR"><code class="xref py py-class docutils literal notranslate"><span class="pre">MMR</span></code></a>) – The summarization algorithm to use.</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="queues.consumers.fire_consumer.FIREConsumer.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">queue</em>, <em class="sig-param">periodicity=60</em>, <em class="sig-param">scheme=None</em>, <em class="sig-param">sets=10</em>, <em class="sig-param">threshold=0.7</em>, <em class="sig-param">freeze_period=20</em>, <em class="sig-param">min_size=4</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.fire_consumer.FIREConsumer.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the consumer with a queue.
Simultaneously create a nutrition store and the topic detection algorithm container.
Initially, the IDF table should be empty.
It will be populated later when the ‘reconaissance’ period is finished.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>queue</strong> (<a class="reference internal" href="#queues.queue.Queue" title="queues.queue.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a>) – The queue that is consumed.</p></li>
<li><p><strong>periodicity</strong> (<em>int</em>) – The time window in seconds of the buffered consumer, or how often it is invoked.
This defaults to 5 seconds, the same span as half the smallest time window in Zhao et al.’s algorithm.</p></li>
<li><p><strong>scheme</strong> (None or <a class="reference internal" href="nlp.html#nlp.weighting.TermWeightingScheme" title="nlp.weighting.TermWeightingScheme"><code class="xref py py-class docutils literal notranslate"><span class="pre">TermWeightingScheme</span></code></a>) – The term-weighting scheme that is used to create dimensions.
If <cite>None</cite> is given, the <a class="reference internal" href="nlp.html#nlp.weighting.tf.TF" title="nlp.weighting.tf.TF"><code class="xref py py-class docutils literal notranslate"><span class="pre">TF</span></code></a> term-weighting scheme is used.</p></li>
<li><p><strong>sets</strong> (<em>int</em>) – The number of time windows that are considered when computing burst.
The higher this number, the more precise the calculations.
However, because of the decay in <a class="reference internal" href="tdt.html#tdt.algorithms.cataldi.Cataldi" title="tdt.algorithms.cataldi.Cataldi"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cataldi</span></code></a>, old time windows do not affect the result by a big margin.
Therefore old data can be removed safely.</p></li>
<li><p><strong>threshold</strong> (<em>float</em>) – The similarity threshold to use for the <a class="reference internal" href="vsm.html#vsm.clustering.algorithms.temporal_no_k_means.TemporalNoKMeans" title="vsm.clustering.algorithms.temporal_no_k_means.TemporalNoKMeans"><code class="xref py py-class docutils literal notranslate"><span class="pre">TemporalNoKMeans</span></code></a> incremental clustering approach.
Documents are added to an existing cluster if their similarity with the centroid is greater than or equal to this threshold.</p></li>
<li><p><strong>freeze_period</strong> (<em>float</em>) – The freeze period, in seconds, of the incremental clustering approach.</p></li>
<li><p><strong>min_size</strong> (<em>int</em>) – The minimum size for a cluster to be considered to be a candidate breaking topic.
This value is inclusive.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<span class="target" id="module-queues.consumers.zhao_consumer"></span><p>The Zhao et al. consumer is based on the implementation by the same authors.
The algorithm revolves around the <a class="reference internal" href="tdt.html#tdt.algorithms.zhao.Zhao" title="tdt.algorithms.zhao.Zhao"><code class="xref py py-class docutils literal notranslate"><span class="pre">Zhao</span></code></a> algorithm.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Implementation based on the algorithm presented in <a class="reference external" href="https://arxiv.org/abs/1106.4300">Human as Real-Time Sensors of Social and Physical Events: A Case Study of Twitter and Sports Games by Zhao et al. (2011)</a>.</p>
</div>
<dl class="class">
<dt id="queues.consumers.zhao_consumer.ZhaoConsumer">
<em class="property">class </em><code class="sig-name descname">ZhaoConsumer</code><span class="sig-paren">(</span><em class="sig-param">queue</em>, <em class="sig-param">periodicity=5</em>, <em class="sig-param">scheme=None</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.zhao_consumer.ZhaoConsumer" title="Permalink to this definition">¶</a></dt>
<dd><p>The Zhao et al. consumer is based on the implementation by the same authors.
The algorithm revolves around the <a class="reference internal" href="tdt.html#tdt.algorithms.zhao.Zhao" title="tdt.algorithms.zhao.Zhao"><code class="xref py py-class docutils literal notranslate"><span class="pre">Zhao</span></code></a> algorithm.
The algorithm examines changes in volume using a dynamic time window.</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>store</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">NutritionStore</span></code>) – The nutrition store used to store the volume.</p></li>
<li><p><strong>scheme</strong> (<a class="reference internal" href="nlp.html#nlp.weighting.TermWeightingScheme" title="nlp.weighting.TermWeightingScheme"><code class="xref py py-class docutils literal notranslate"><span class="pre">TermWeightingScheme</span></code></a>) – The term-weighting scheme used to create documents.</p></li>
<li><p><a class="reference internal" href="summarization.html#summarization.summary.Summary.documents" title="summarization.summary.Summary.documents"><strong>documents</strong></a> (<a class="reference internal" href="nlp.html#nlp.document.Document" title="nlp.document.Document"><code class="xref py py-class docutils literal notranslate"><span class="pre">Document</span></code></a>) – The documents that can still be used for summarization.
Older documents are automatically cleared.</p></li>
<li><p><a class="reference internal" href="tdt.html#module-tdt" title="tdt"><strong>tdt</strong></a> (<a class="reference internal" href="tdt.html#tdt.algorithms.zhao.Zhao" title="tdt.algorithms.zhao.Zhao"><code class="xref py py-class docutils literal notranslate"><span class="pre">Zhao</span></code></a>) – The TDT algorithm: Zhao et al.’s implementation.</p></li>
<li><p><a class="reference internal" href="summarization.html#module-summarization" title="summarization"><strong>summarization</strong></a> (<a class="reference internal" href="summarization.html#summarization.algorithms.mmr.MMR" title="summarization.algorithms.mmr.MMR"><code class="xref py py-class docutils literal notranslate"><span class="pre">MMR</span></code></a>) – The summarization algorithm to use.</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="queues.consumers.zhao_consumer.ZhaoConsumer.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">queue</em>, <em class="sig-param">periodicity=5</em>, <em class="sig-param">scheme=None</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.zhao_consumer.ZhaoConsumer.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the consumer with a queue.
Simultaneously create a nutrition store and the topic detection algorithm container.
Initially, the IDF table should be empty.
It will be populated later when the ‘reconaissance’ period is finished.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>queue</strong> (<a class="reference internal" href="#queues.queue.Queue" title="queues.queue.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a>) – The queue that is consumed.</p></li>
<li><p><strong>periodicity</strong> (<em>int</em>) – The time window in seconds of the buffered consumer, or how often it is invoked.
This defaults to 5 seconds, the same span as half the smallest time window in Zhao et al.’s algorithm.</p></li>
<li><p><strong>scheme</strong> (None or <a class="reference internal" href="nlp.html#nlp.weighting.TermWeightingScheme" title="nlp.weighting.TermWeightingScheme"><code class="xref py py-class docutils literal notranslate"><span class="pre">TermWeightingScheme</span></code></a>) – The term-weighting scheme that is used to create dimensions.
If <cite>None</cite> is given, the <a class="reference internal" href="nlp.html#nlp.weighting.tf.TF" title="nlp.weighting.tf.TF"><code class="xref py py-class docutils literal notranslate"><span class="pre">TF</span></code></a> term-weighting scheme is used.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="ml.html" class="btn btn-neutral float-right" title="10. Machine Learning" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="twitter.html" class="btn btn-neutral float-left" title="8. Twitter" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Nicholas Mamo

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>