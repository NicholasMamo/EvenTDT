

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta content="The consumer functionality of EvenTDT" name="description" />
<meta content="Python, TDT, queue, consumer" name="keywords" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>9. Consumers &mdash; EvenTDT 0.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/eventdt.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="10. Machine Learning" href="ml.html" />
    <link rel="prev" title="8. Twitter" href="twitter.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> EvenTDT
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="config.html">0. Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="tools.html">1. Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="vsm.html">2. Vector Space Model (VSM)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nlp.html">3. Natural Language Processing (NLP)</a></li>
<li class="toctree-l1"><a class="reference internal" href="wikinterface.html">4. Wikinterface</a></li>
<li class="toctree-l1"><a class="reference internal" href="apd.html">5. Automatic Participant Detection (APD)</a></li>
<li class="toctree-l1"><a class="reference internal" href="tdt.html">6. Topic Detection and Tracking (TDT)</a></li>
<li class="toctree-l1"><a class="reference internal" href="summarization.html">7. Summarization</a></li>
<li class="toctree-l1"><a class="reference internal" href="twitter.html">8. Twitter</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">9. Consumers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#queues">Queues</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id1">Consumers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-queues.consumers.print_consumer">Simple Consumers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-queues.consumers.eld_consumer">Algorithms</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ml.html">10. Machine Learning</a></li>
<li class="toctree-l1"><a class="reference internal" href="ate.html">11. Automatic Term Extraction (ATE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="other.html">12. Other</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">EvenTDT</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>9. Consumers</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/consumers.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
    <div class="section" id="consumers">
<h1>9. Consumers<a class="headerlink" href="#consumers" title="Permalink to this headline">¶</a></h1>
<div class="section" id="queues">
<h2>Queues<a class="headerlink" href="#queues" title="Permalink to this headline">¶</a></h2>
<p>EvenTDT collects tweets and processes them.
In-between collecting and processing, the tweets go into a queue data structure.
In this way, the consumers can process the data in the same order as it was received.
The queue functionality is a special class.</p>
<span class="target" id="module-queues.queue"></span><p>Queues are first in, first out (FIFO) data structures.
This implementation is based on lists.
Queue-specific functionality is introduced as functions.</p>
<dl class="class">
<dt id="queues.queue.Queue">
<em class="property">class </em><code class="sig-name descname">Queue</code><span class="sig-paren">(</span><em class="sig-param">*args</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.queue.Queue" title="Permalink to this definition">¶</a></dt>
<dd><p>The queue data structure is based on a list.
The queue can take in any kind of data, including other queues.
New elements are added to the queue at the end.</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><p><a class="reference internal" href="#module-queues.queue" title="queues.queue"><strong>queue</strong></a> (<em>list</em>) – The queue data structure.</p>
</dd>
</dl>
<dl class="method">
<dt id="queues.queue.Queue.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">*args</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.queue.Queue.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the queue.
The queue’s data can be given as normal arguments.</p>
</dd></dl>

<dl class="method">
<dt id="queues.queue.Queue.enqueue">
<code class="sig-name descname">enqueue</code><span class="sig-paren">(</span><em class="sig-param">*args</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.queue.Queue.enqueue" title="Permalink to this definition">¶</a></dt>
<dd><p>Add the given data to the queue.
All arguments can be provided as arguments.</p>
</dd></dl>

<dl class="method">
<dt id="queues.queue.Queue.dequeue">
<code class="sig-name descname">dequeue</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#queues.queue.Queue.dequeue" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the first element in the queue.
If the queue is empty, <cite>None</cite> is returned instead</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The first element in the queue.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>object or None</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.queue.Queue.dequeue_all">
<code class="sig-name descname">dequeue_all</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#queues.queue.Queue.dequeue_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Dequeue all elements in the queue.
Unlike the <a class="reference internal" href="#queues.queue.Queue.empty" title="queues.queue.Queue.empty"><code class="xref py py-func docutils literal notranslate"><span class="pre">empty()</span></code></a> function, this function returns all of the queue’s elements.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>All the elements in the queue.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.queue.Queue.empty">
<code class="sig-name descname">empty</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#queues.queue.Queue.empty" title="Permalink to this definition">¶</a></dt>
<dd><p>Empty the queue.
Unlike the <a class="reference internal" href="#queues.queue.Queue.dequeue_all" title="queues.queue.Queue.dequeue_all"><code class="xref py py-func docutils literal notranslate"><span class="pre">dequeue_all()</span></code></a> function, this function returns nothing.</p>
</dd></dl>

<dl class="method">
<dt id="queues.queue.Queue.length">
<code class="sig-name descname">length</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#queues.queue.Queue.length" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the length of the queue.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The length of the queue.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.queue.Queue.head">
<code class="sig-name descname">head</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#queues.queue.Queue.head" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the first element entered into the queue without removing it.
If the queue is empty, <cite>None</cite> is returned instead</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The oldest element in the queue.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>object or None</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.queue.Queue.tail">
<code class="sig-name descname">tail</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#queues.queue.Queue.tail" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the last element entered into the queue without removing it.
If the queue is empty, <cite>None</cite> is returned instead</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The newest element in the queue.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>object or None</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="queues.queue.Queue.__weakref__">
<code class="sig-name descname">__weakref__</code><a class="headerlink" href="#queues.queue.Queue.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id1">
<h2>Consumers<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>Queue data is consumed by consumers.
Each consumer dequeues the accumulated data and processes it or outputs it.
There are various base classes for consumers, covering both real-time and buffered consumption.</p>
<span class="target" id="module-queues.consumers.consumer"></span><p>All consumers follow a simple workflow.
After initialization with a queue, the consumer can be run using the <a class="reference internal" href="#queues.consumers.consumer.Consumer.run" title="queues.consumers.consumer.Consumer.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">run()</span></code></a> function.
That function prepares to start consuming the queue and calls the <a class="reference internal" href="#queues.consumers.consumer.Consumer._consume" title="queues.consumers.consumer.Consumer._consume"><code class="xref py py-func docutils literal notranslate"><span class="pre">_consume()</span></code></a> function.</p>
<p>Consumers have two other state variables apart from the queue: the <cite>active</cite> and <cite>stopped</cite> variables.
The <cite>active</cite> variable indicates whether the consumer is still accepting objects.
The <cite>stopped</cite> variable indicates whether the consumer has finished consuming all objects.
Generally, consumers keep accepting objects until the <cite>active</cite> variable is disabled.
At that point, they process the last objects and set the <cite>stopped</cite> flag to <cite>True</cite>.</p>
<dl class="class">
<dt id="queues.consumers.consumer.Consumer">
<em class="property">class </em><code class="sig-name descname">Consumer</code><span class="sig-paren">(</span><em class="sig-param">queue</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.consumer.Consumer" title="Permalink to this definition">¶</a></dt>
<dd><p>The abstract Consumer class outlines the necessary functions of a consumer.
It also defines the state of the consumer.</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><ul class="simple">
<li><p><a class="reference internal" href="#module-queues.queue" title="queues.queue"><strong>queue</strong></a> (<a class="reference internal" href="#queues.queue.Queue" title="queues.queue.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a>) – The queue that is to be consumed.</p></li>
<li><p><strong>active</strong> (<em>bool</em>) – A boolean indicating whether the consumer is still accepting data.</p></li>
<li><p><strong>stopped</strong> (<em>bool</em>) – A boolean indicating whether the consumer has finished processing.</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="queues.consumers.consumer.Consumer.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">queue</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.consumer.Consumer.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the Consumer with its queue.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>queue</strong> – The queue that will be consumed.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.consumers.consumer.Consumer.run">
<em class="property">async </em><code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param">wait=0</em>, <em class="sig-param">max_inactivity=-1</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.consumer.Consumer.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Invoke the consume method.
Since some listeners have a small delay, the consumer may wait a bit before starting to consume input.</p>
<p>Any additional arguments and keyword arguments are passed on to the <a class="reference internal" href="#queues.consumers.consumer.Consumer._consume" title="queues.consumers.consumer.Consumer._consume"><code class="xref py py-func docutils literal notranslate"><span class="pre">_consume()</span></code></a> function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>wait</strong> (<em>int</em>) – The time in seconds to wait until starting to consume the event.
This is used when the file listener spends a lot of time skipping tweets.</p></li>
<li><p><strong>max_inactivity</strong> (<em>int</em>) – The maximum time in seconds to wait idly without input before stopping.
If it is negative, the consumer keeps waiting for input until the maximum time expires.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The output of the consume method.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>any</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.consumers.consumer.Consumer.stop">
<code class="sig-name descname">stop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.consumer.Consumer.stop" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a flag to stop accepting new objects.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Contrary to the name of the function, the function sets the <cite>active</cite> flag, not the <cite>stopped</cite> flag.
This function merely asks that the consumer stops accepting new objects for processing.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="queues.consumers.consumer.Consumer._consume">
<em class="property">abstract async </em><code class="sig-name descname">_consume</code><span class="sig-paren">(</span><em class="sig-param">max_inactivity</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.consumer.Consumer._consume" title="Permalink to this definition">¶</a></dt>
<dd><p>Consume the queue.
This is the function where most processing occurs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>max_inactivity</strong> (<em>int</em>) – The maximum time in seconds to wait idly without input before stopping.
If it is negative, the consumer keeps waiting for input until the maximum time expires.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.consumers.consumer.Consumer._wait_for_input">
<em class="property">async </em><code class="sig-name descname">_wait_for_input</code><span class="sig-paren">(</span><em class="sig-param">max_inactivity</em>, <em class="sig-param">sleep=0.25</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.consumer.Consumer._wait_for_input" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait for input from the queue.
When input is received, the function returns True.
If no input is found for the given number of seconds, the function returns False.
If the maximum inactivity is negative, it is disregarded.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>max_inactivity</strong> (<em>int</em>) – The maximum time in seconds to wait idly without input before stopping.
If it is negative, it is ignored.</p></li>
<li><p><strong>sleep</strong> (<em>float</em>) – The number of seconds to sleep while waiting for input.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A boolean indicating whether the consumer should continue, or whether it has been idle for far too long.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.consumers.consumer.Consumer._started">
<code class="sig-name descname">_started</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.consumer.Consumer._started" title="Permalink to this definition">¶</a></dt>
<dd><p>A function that sets the active and stopped flags to indicate that the consumer has started operating.</p>
</dd></dl>

<dl class="method">
<dt id="queues.consumers.consumer.Consumer._stopped">
<code class="sig-name descname">_stopped</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.consumer.Consumer._stopped" title="Permalink to this definition">¶</a></dt>
<dd><p>A function that sets the active and stopped flags to indicate that the consumer has stopped operating.</p>
</dd></dl>

<dl class="attribute">
<dt id="queues.consumers.consumer.Consumer.__weakref__">
<code class="sig-name descname">__weakref__</code><a class="headerlink" href="#queues.consumers.consumer.Consumer.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-queues.consumers.buffered_consumer"></span><p>A buffered consumer processes content in batches.</p>
<dl class="class">
<dt id="queues.consumers.buffered_consumer.BufferedConsumer">
<em class="property">class </em><code class="sig-name descname">BufferedConsumer</code><span class="sig-paren">(</span><em class="sig-param">queue</em>, <em class="sig-param">periodicity=60</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.buffered_consumer.BufferedConsumer" title="Permalink to this definition">¶</a></dt>
<dd><p>The buffered consumer adds the processing stage apart from the consumption.
The <a class="reference internal" href="#queues.consumers.buffered_consumer.BufferedConsumer._consume" title="queues.consumers.buffered_consumer.BufferedConsumer._consume"><code class="xref py py-func docutils literal notranslate"><span class="pre">_consume()</span></code></a> function function waits until objects become available in the queue.
The <a class="reference internal" href="#queues.consumers.buffered_consumer.BufferedConsumer._process" title="queues.consumers.buffered_consumer.BufferedConsumer._process"><code class="xref py py-func docutils literal notranslate"><span class="pre">_process()</span></code></a> function empties this buffer and processes it.
The two functions communicate with each other using a common queue, called a buffer.</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>periodicity</strong> (<em>int</em>) – The time window in seconds of the buffered consumer, or how often it is invoked.</p></li>
<li><p><a class="reference internal" href="#queues.consumers.eld_consumer.ELDConsumer.buffer" title="queues.consumers.eld_consumer.ELDConsumer.buffer"><strong>buffer</strong></a> (<a class="reference internal" href="#queues.queue.Queue" title="queues.queue.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a>) – The buffer of objects that have to be processed.</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="queues.consumers.buffered_consumer.BufferedConsumer.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">queue</em>, <em class="sig-param">periodicity=60</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.buffered_consumer.BufferedConsumer.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the buffered consumer with its queue and periodicity.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>queue</strong> (<a class="reference internal" href="#queues.queue.Queue" title="queues.queue.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a>) – The queue that is consumed.</p></li>
<li><p><strong>periodicity</strong> (<em>int</em>) – The time window in seconds of the buffered consumer, or how often it is invoked.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.consumers.buffered_consumer.BufferedConsumer.run">
<em class="property">async </em><code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param">wait=0</em>, <em class="sig-param">max_inactivity=-1</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.buffered_consumer.BufferedConsumer.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Invokes the consume and process method.</p>
<p>Any additional arguments and keyword arguments are passed on to the <a class="reference internal" href="#queues.consumers.buffered_consumer.BufferedConsumer._consume" title="queues.consumers.buffered_consumer.BufferedConsumer._consume"><code class="xref py py-class docutils literal notranslate"><span class="pre">_consume</span></code></a> and <a class="reference internal" href="#queues.consumers.buffered_consumer.BufferedConsumer._process" title="queues.consumers.buffered_consumer.BufferedConsumer._process"><code class="xref py py-class docutils literal notranslate"><span class="pre">_process</span></code></a> functions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>wait</strong> (<em>int</em>) – The time in seconds to wait until starting to understand the event.
This is used when the file listener spends a lot of time skipping documents.</p></li>
<li><p><strong>max_inactivity</strong> (<em>int</em>) – The maximum time in seconds to wait idly without input before stopping.
If it is negative, the consumer keeps waiting for input until the maximum time expires.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The output of the consume method.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>any</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.consumers.buffered_consumer.BufferedConsumer._consume">
<em class="property">async </em><code class="sig-name descname">_consume</code><span class="sig-paren">(</span><em class="sig-param">max_inactivity</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.buffered_consumer.BufferedConsumer._consume" title="Permalink to this definition">¶</a></dt>
<dd><p>Consume the queue.
This function calls for processing in turn.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>max_inactivity</strong> (<em>int</em>) – The maximum time in seconds to wait idly without input before stopping.
If it is negative, the consumer keeps waiting for input until the maximum time expires.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.consumers.buffered_consumer.BufferedConsumer._process">
<em class="property">abstract async </em><code class="sig-name descname">_process</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.buffered_consumer.BufferedConsumer._process" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the buffered items.</p>
</dd></dl>

<dl class="method">
<dt id="queues.consumers.buffered_consumer.BufferedConsumer._sleep">
<em class="property">async </em><code class="sig-name descname">_sleep</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.buffered_consumer.BufferedConsumer._sleep" title="Permalink to this definition">¶</a></dt>
<dd><p>Sleep until the window is over.
At this point, the queue is emptied into a buffer for processing.
The function periodically checks if the consumer has been asked to stop.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="queues.consumers.buffered_consumer.SimulatedBufferedConsumer">
<em class="property">class </em><code class="sig-name descname">SimulatedBufferedConsumer</code><span class="sig-paren">(</span><em class="sig-param">queue</em>, <em class="sig-param">periodicity</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.buffered_consumer.SimulatedBufferedConsumer" title="Permalink to this definition">¶</a></dt>
<dd><p>The simulated buffered consumer is exactly like the buffered consumer, but its periodicity is not real-time.
Instead, it gets the time from the incoming message.
This class can be used in a simulated environment, such as when data has been collected.
In this case, it allows the data to be consumed at the rate that it is read.</p>
<dl class="method">
<dt id="queues.consumers.buffered_consumer.SimulatedBufferedConsumer.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">queue</em>, <em class="sig-param">periodicity</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.buffered_consumer.SimulatedBufferedConsumer.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the simulated buffered consumer with its queue, periodicity and buffer.
The timestamp parameter is the field that the sleep function checks to know when it should awake.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>queue</strong> (<a class="reference internal" href="#queues.queue.Queue" title="queues.queue.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a>) – The queue that is consumed.</p></li>
<li><p><strong>periodicity</strong> (<em>int</em>) – The time window in seconds of the buffered consumer, or how often it is invoked.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.consumers.buffered_consumer.SimulatedBufferedConsumer._sleep">
<em class="property">async </em><code class="sig-name descname">_sleep</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.buffered_consumer.SimulatedBufferedConsumer._sleep" title="Permalink to this definition">¶</a></dt>
<dd><p>Sleep until the window is over.
At this point, the queue is emptied into a buffer for processing.
The function periodically checks if the consumer has been asked to stop.</p>
</dd></dl>

</dd></dl>

<div class="section" id="module-queues.consumers.print_consumer">
<span id="simple-consumers"></span><h3>Simple Consumers<a class="headerlink" href="#module-queues.consumers.print_consumer" title="Permalink to this headline">¶</a></h3>
<p>The print consumer outputs the queue’s elements as they arrive.</p>
<dl class="class">
<dt id="queues.consumers.print_consumer.PrintConsumer">
<em class="property">class </em><code class="sig-name descname">PrintConsumer</code><span class="sig-paren">(</span><em class="sig-param">queue</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.print_consumer.PrintConsumer" title="Permalink to this definition">¶</a></dt>
<dd><p>The print consumer prints queue messages and discards them.</p>
<dl class="method">
<dt id="queues.consumers.print_consumer.PrintConsumer._consume">
<em class="property">async </em><code class="sig-name descname">_consume</code><span class="sig-paren">(</span><em class="sig-param">max_inactivity=5</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.print_consumer.PrintConsumer._consume" title="Permalink to this definition">¶</a></dt>
<dd><p>Consume the next elements from the queue.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>max_inactivity</strong> (<em>int</em>) – The maximum time in seconds to wait idly without input before stopping.
If it is negative, the consumer keeps waiting for input until the maximum time expires.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<span class="target" id="module-queues.consumers.stat_consumer"></span><p>The statistic consumer is a simple consumer that reports statistics about tweets periodically.</p>
<dl class="class">
<dt id="queues.consumers.stat_consumer.StatConsumer">
<em class="property">class </em><code class="sig-name descname">StatConsumer</code><span class="sig-paren">(</span><em class="sig-param">queue</em>, <em class="sig-param">periodicity=60</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.stat_consumer.StatConsumer" title="Permalink to this definition">¶</a></dt>
<dd><p>The statistic consumer is a simple consumer that reports statistics about tweets periodically.
The reporting is done based on the periodicity.</p>
<dl class="method">
<dt id="queues.consumers.stat_consumer.StatConsumer._process">
<em class="property">async </em><code class="sig-name descname">_process</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.stat_consumer.StatConsumer._process" title="Permalink to this definition">¶</a></dt>
<dd><p>Count and report the number of tweets received in the last period.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-queues.consumers.eld_consumer">
<span id="algorithms"></span><h3>Algorithms<a class="headerlink" href="#module-queues.consumers.eld_consumer" title="Permalink to this headline">¶</a></h3>
<p>Event TimeLine Detection (ELD) is a consumer based on a publication of the same name.
The approach splits processing into two steps:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Understand the event, and</p></li>
<li><p>Build a timeline for it.</p></li>
</ol>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Implementation based on the algorithm presented in <a class="reference external" href="https://dl.acm.org/doi/10.1145/3342220.3344921">ELD: Event TimeLine Detection – A Participant-Based Approach to Tracking Events by Mamo et al. (2019)</a>.</p>
</div>
<dl class="class">
<dt id="queues.consumers.eld_consumer.ELDConsumer">
<em class="property">class </em><code class="sig-name descname">ELDConsumer</code><span class="sig-paren">(</span><em class="sig-param">queue</em>, <em class="sig-param">time_window=30</em>, <em class="sig-param">scheme=None</em>, <em class="sig-param">threshold=0.5</em>, <em class="sig-param">freeze_period=20</em>, <em class="sig-param">min_size=3</em>, <em class="sig-param">cooldown=1</em>, <em class="sig-param">max_intra_similarity=0.8</em>, <em class="sig-param">sets=10</em>, <em class="sig-param">min_burst=0.5</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.eld_consumer.ELDConsumer" title="Permalink to this definition">¶</a></dt>
<dd><p>The ELD consumer is a real-time consumer with a custom algorithm to detect topics.
It is siplit into two steps:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Understand the event, and</p></li>
<li><p>Build a timeline for it.</p></li>
</ol>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>time_window</strong> (<em>int</em>) – The time (in seconds) to spend consuming the queue.</p></li>
<li><p><strong>scheme</strong> (<a class="reference internal" href="nlp.html#nlp.weighting.TermWeightingScheme" title="nlp.weighting.TermWeightingScheme"><code class="xref py py-class docutils literal notranslate"><span class="pre">TermWeightingScheme</span></code></a>) – The term-weighting scheme used to create documents.</p></li>
<li><p><strong>min_size</strong> (<em>int</em>) – The minimum size of a cluster to be considered valid.</p></li>
<li><p><strong>cooldown</strong> (<em>float</em>) – The minimum time (in seconds) between consecutive checks of a cluster.</p></li>
<li><p><strong>max_intra_similarity</strong> (<em>float</em>) – The maximum average similarity, between 0 and 1, of the cluster’s documents with the centroid.
Used to filter out clusters that include only retweets of the same, or almost identical documents.</p></li>
<li><p><strong>sets</strong> (<em>int</em>) – The number of time windows that are considered when computing burst.
The higher this number, the more precise the calculations.
However, because of the decay in <a class="reference internal" href="tdt.html#tdt.algorithms.eld.ELD" title="tdt.algorithms.eld.ELD"><code class="xref py py-class docutils literal notranslate"><span class="pre">ELD</span></code></a>, old time windows do not affect the result by a big margin.
Therefore old data can be removed safely.</p></li>
<li><p><a class="reference internal" href="#queues.consumers.eld_consumer.ELDConsumer.min_burst" title="queues.consumers.eld_consumer.ELDConsumer.min_burst"><strong>min_burst</strong></a> (<em>float</em>) – The minimum burst of a term to be considered emerging and returned.
This value is exclusive.</p></li>
<li><p><strong>store</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">NutritionStore</span></code>) – The nutrition store used in conjunction with extractin breaking news.</p></li>
<li><p><a class="reference internal" href="#queues.consumers.eld_consumer.ELDConsumer.buffer" title="queues.consumers.eld_consumer.ELDConsumer.buffer"><strong>buffer</strong></a> (<a class="reference internal" href="#queues.queue.Queue" title="queues.queue.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a>) – A buffer of tweets that have been processed, but which are not part of a checkpoint yet.</p></li>
<li><p><strong>tokenizer</strong> (<a class="reference internal" href="nlp.html#nlp.tokenizer.Tokenizer" title="nlp.tokenizer.Tokenizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tokenizer</span></code></a>) – The tokenizer used to create documents and create the IDF table, among others.</p></li>
<li><p><strong>clustering</strong> (<a class="reference internal" href="vsm.html#vsm.clustering.algorithms.temporal_no_k_means.TemporalNoKMeans" title="vsm.clustering.algorithms.temporal_no_k_means.TemporalNoKMeans"><code class="xref py py-class docutils literal notranslate"><span class="pre">TemporalNoKMeans</span></code></a>) – The clustering algorithm to use.</p></li>
<li><p><a class="reference internal" href="tdt.html#module-tdt" title="tdt"><strong>tdt</strong></a> (<a class="reference internal" href="tdt.html#tdt.algorithms.eld.ELD" title="tdt.algorithms.eld.ELD"><code class="xref py py-class docutils literal notranslate"><span class="pre">ELD</span></code></a>) – The TDT algorithm used to detect breaking developments.</p></li>
<li><p><a class="reference internal" href="summarization.html#module-summarization" title="summarization"><strong>summarization</strong></a> (<a class="reference internal" href="summarization.html#summarization.algorithms.dgs.DGS" title="summarization.algorithms.dgs.DGS"><code class="xref py py-class docutils literal notranslate"><span class="pre">DGS</span></code></a>) – The summarization algorithm used to create the timeline.</p></li>
<li><p><strong>cleaner</strong> (<a class="reference internal" href="nlp.html#nlp.cleaners.tweet_cleaner.TweetCleaner" title="nlp.cleaners.tweet_cleaner.TweetCleaner"><code class="xref py py-class docutils literal notranslate"><span class="pre">TweetCleaner</span></code></a>) – The cleaner used to make summaries more presentable.</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="queues.consumers.eld_consumer.ELDConsumer.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">queue</em>, <em class="sig-param">time_window=30</em>, <em class="sig-param">scheme=None</em>, <em class="sig-param">threshold=0.5</em>, <em class="sig-param">freeze_period=20</em>, <em class="sig-param">min_size=3</em>, <em class="sig-param">cooldown=1</em>, <em class="sig-param">max_intra_similarity=0.8</em>, <em class="sig-param">sets=10</em>, <em class="sig-param">min_burst=0.5</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.eld_consumer.ELDConsumer.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the consumer with a queue.
Simultaneously create a nutrition store and the topic detection algorithm container.
Initially, the IDF table should be empty.
It will be populated later when the ‘reconaissance’ period is finished.</p>
<p>The constructor also creates a buffer.
This buffer is used to store tweets until they are made into a checkpoint.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>queue</strong> (<a class="reference internal" href="#queues.queue.Queue" title="queues.queue.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a>) – The queue that is consumed.</p></li>
<li><p><strong>time_window</strong> (<em>int</em>) – The size of the window after which checkpoints are created.</p></li>
<li><p><strong>scheme</strong> (None or <a class="reference internal" href="nlp.html#nlp.weighting.TermWeightingScheme" title="nlp.weighting.TermWeightingScheme"><code class="xref py py-class docutils literal notranslate"><span class="pre">TermWeightingScheme</span></code></a>) – The term-weighting scheme that is used to create dimensions.
If <cite>None</cite> is given, the <a class="reference internal" href="nlp.html#nlp.weighting.tf.TF" title="nlp.weighting.tf.TF"><code class="xref py py-class docutils literal notranslate"><span class="pre">TF</span></code></a> term-weighting scheme is used.</p></li>
<li><p><strong>threshold</strong> (<em>float</em>) – The similarity threshold to use for the <a class="reference internal" href="vsm.html#vsm.clustering.algorithms.temporal_no_k_means.TemporalNoKMeans" title="vsm.clustering.algorithms.temporal_no_k_means.TemporalNoKMeans"><code class="xref py py-class docutils literal notranslate"><span class="pre">TemporalNoKMeans</span></code></a> incremental clustering approach.
Documents are added to an existing cluster if their similarity with the centroid is greater than or equal to this threshold.</p></li>
<li><p><strong>freeze_period</strong> (<em>float</em>) – The freeze period, in seconds, of the incremental clustering approach.</p></li>
<li><p><strong>min_size</strong> (<em>int</em>) – The minimum size of a cluster to be considered valid.</p></li>
<li><p><strong>cooldown</strong> (<em>float</em>) – The minimum time (in seconds) between consecutive checks of a cluster.</p></li>
<li><p><strong>max_intra_similarity</strong> (<em>float</em>) – The maximum average similarity, between 0 and 1, of the cluster’s documents with the centroid.
Used to filter out clusters that include only retweets of the same, or almost identical documents.</p></li>
<li><p><strong>sets</strong> (<em>int</em>) – The number of time windows that are considered when computing burst.
The higher this number, the more precise the calculations.
However, because of the decay in <a class="reference internal" href="tdt.html#tdt.algorithms.eld.ELD" title="tdt.algorithms.eld.ELD"><code class="xref py py-class docutils literal notranslate"><span class="pre">ELD</span></code></a>, old time windows do not affect the result by a big margin.
Therefore old data can be removed safely.</p></li>
<li><p><strong>min_burst</strong> (<em>float</em>) – The minimum burst of a term to be considered emerging and returned.
This value is exclusive.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="queues.consumers.eld_consumer.ELDConsumer.min_burst">
<code class="sig-name descname">min_burst</code><em class="property"> = None</em><a class="headerlink" href="#queues.consumers.eld_consumer.ELDConsumer.min_burst" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the nutrition store and the buffer.
The buffer stores tweets that have been processed, but not yet added to a checkpoint.</p>
</dd></dl>

<dl class="attribute">
<dt id="queues.consumers.eld_consumer.ELDConsumer.buffer">
<code class="sig-name descname">buffer</code><em class="property"> = None</em><a class="headerlink" href="#queues.consumers.eld_consumer.ELDConsumer.buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the different components of the system.</p>
</dd></dl>

<dl class="method">
<dt id="queues.consumers.eld_consumer.ELDConsumer.understand">
<em class="property">async </em><code class="sig-name descname">understand</code><span class="sig-paren">(</span><em class="sig-param">max_inactivity=-1</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.eld_consumer.ELDConsumer.understand" title="Permalink to this definition">¶</a></dt>
<dd><p>Understanding is split into two tasks:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Construct the TF-IDF scheme used from the pre-event discussion, and</p></li>
<li><p>Identify the event’s participants.</p></li>
</ol>
</div></blockquote>
<p>The function returns both as a dictionary.
The two keys are <cite>scheme</cite> and <cite>participants</cite>.</p>
<p>Any additional arguments and keyword arguments are passed on to the <a class="reference internal" href="#queues.consumers.eld_consumer.ELDConsumer._construct_idf" title="queues.consumers.eld_consumer.ELDConsumer._construct_idf"><code class="xref py py-func docutils literal notranslate"><span class="pre">_construct_idf()</span></code></a> and <a class="reference internal" href="#queues.consumers.eld_consumer.ELDConsumer._detect_participants" title="queues.consumers.eld_consumer.ELDConsumer._detect_participants"><code class="xref py py-func docutils literal notranslate"><span class="pre">_detect_participants()</span></code></a> functions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>max_inactivity</strong> (<em>int</em>) – The maximum time in seconds to wait idly without input before stopping.
If it is negative, it is ignored.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A dictionary containing the TF-IDF scheme and the event’s participants from the pre-event discussion.
The TF-IDF scheme is returned in the <cite>scheme</cite> key as a <a class="reference internal" href="nlp.html#nlp.weighting.tfidf.TFIDF" title="nlp.weighting.tfidf.TFIDF"><code class="xref py py-class docutils literal notranslate"><span class="pre">TFIDF</span></code></a> instance.
The participants are returned in the <cite>participants</cite> key a list of strings.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.consumers.eld_consumer.ELDConsumer._construct_idf">
<em class="property">async </em><code class="sig-name descname">_construct_idf</code><span class="sig-paren">(</span><em class="sig-param">max_inactivity</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.eld_consumer.ELDConsumer._construct_idf" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct the TF-IDF table from the pre-event discussion.
All of the tweets processed by these documents are added to a buffer so they can be used by the APD task.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>max_inactivity</strong> (<em>int</em>) – The maximum time in seconds to wait idly without input before stopping.
If it is negative, it is ignored.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The constructed TF-IDF scheme.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="nlp.html#nlp.weighting.tfidf.TFIDF" title="nlp.weighting.tfidf.TFIDF"><code class="xref py py-class docutils literal notranslate"><span class="pre">TFIDF</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.consumers.eld_consumer.ELDConsumer._detect_participants">
<em class="property">async </em><code class="sig-name descname">_detect_participants</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.eld_consumer.ELDConsumer._detect_participants" title="Permalink to this definition">¶</a></dt>
<dd><p>Detect participants from the received documents.</p>
<p>ELD assumes that all participants are named entities.
Therefore the APD process is based on the <a class="reference internal" href="apd.html#apd.extractors.local.entity_extractor.EntityExtractor" title="apd.extractors.local.entity_extractor.EntityExtractor"><code class="xref py py-class docutils literal notranslate"><span class="pre">EntityExtractor</span></code></a>.</p>
<p>This function assumes that it follows the <a class="reference internal" href="#queues.consumers.eld_consumer.ELDConsumer._construct_idf" title="queues.consumers.eld_consumer.ELDConsumer._construct_idf"><code class="xref py py-func docutils literal notranslate"><span class="pre">_construct_idf()</span></code></a> function.
Therefore the documents it uses are those added to the buffer.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A list of participants.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>list of str</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.consumers.eld_consumer.ELDConsumer._consume">
<em class="property">async </em><code class="sig-name descname">_consume</code><span class="sig-paren">(</span><em class="sig-param">max_inactivity</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.eld_consumer.ELDConsumer._consume" title="Permalink to this definition">¶</a></dt>
<dd><p>Consume and process the documents in the queue.
Processed documents are added to the buffer.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>max_inactivity</strong> (<em>int</em>) – The maximum time in seconds to wait idly without input before stopping.
If it is negative, the consumer keeps waiting for input until the maximum time expires.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The constructed timeline.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="summarization.html#summarization.timeline.Timeline" title="summarization.timeline.Timeline"><code class="xref py py-class docutils literal notranslate"><span class="pre">Timeline</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.consumers.eld_consumer.ELDConsumer._filter_tweets">
<code class="sig-name descname">_filter_tweets</code><span class="sig-paren">(</span><em class="sig-param">tweets</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.eld_consumer.ELDConsumer._filter_tweets" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter the given tweets based on <a class="reference internal" href="#queues.consumers.fire_consumer.FIREConsumer" title="queues.consumers.fire_consumer.FIREConsumer"><code class="xref py py-class docutils literal notranslate"><span class="pre">FIREConsumer</span></code></a>’s filtering rules and new rules.
FIRE’s rules are:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>The tweet has to be in English,</p></li>
<li><p>The tweet must contain no more than 2 hashtags,</p></li>
<li><p>The tweet’s author must have favorited at least one tweet, and</p></li>
<li><p>The tweet’s author must have at least one follower for every thousand tweets they’ve published.</p></li>
</ol>
</div></blockquote>
<p>The new rules are:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>The tweet cannot have more than one URL because too many URLs are indicative of pre-planned content, and</p></li>
<li><p>The biography of the tweet’s author cannot be empty because that is indicative of bots.</p></li>
</ol>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>tweets</strong> (<em>list of dict</em>) – A list of tweets to filter.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A list of filtered tweets.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.consumers.eld_consumer.ELDConsumer._to_documents">
<code class="sig-name descname">_to_documents</code><span class="sig-paren">(</span><em class="sig-param">tweets</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.eld_consumer.ELDConsumer._to_documents" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the given tweets into documents.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>tweets</strong> (<em>list of dict</em>) – A list of tweets.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A list of documents created from the tweets in the same order as the given tweets.
Documents are normalized and store the original tweet in the <cite>tweet</cite> attribute.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list of <a class="reference internal" href="nlp.html#nlp.document.Document" title="nlp.document.Document"><code class="xref py py-class docutils literal notranslate"><span class="pre">Document</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.consumers.eld_consumer.ELDConsumer._latest_timestamp">
<code class="sig-name descname">_latest_timestamp</code><span class="sig-paren">(</span><em class="sig-param">documents</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.eld_consumer.ELDConsumer._latest_timestamp" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the latest timestamp from the given documents.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>documents</strong> (list of <a class="reference internal" href="nlp.html#nlp.document.Document" title="nlp.document.Document"><code class="xref py py-class docutils literal notranslate"><span class="pre">Document</span></code></a>) – The list of documents from where to get the latest timestamp.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The latest timestamp in the given document set.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>int</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – When there are no documents to consider.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.consumers.eld_consumer.ELDConsumer._create_checkpoint">
<code class="sig-name descname">_create_checkpoint</code><span class="sig-paren">(</span><em class="sig-param">timestamp</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.eld_consumer.ELDConsumer._create_checkpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>After every time window has elapsed, use all the buffered documents to create a new checkpoint.
The checkpoint creates a new nutrition set stored in the nutrition store.
This nutrition set represents a snapshot of the time window.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The ELD consumer follows a real-time process.
Since there could be a backlog, the function ensures that documents published after the given timestamp are not added to the checkpoint.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>timestamp</strong> (<em>int</em>) – The timestamp of the new checkpoint.
The nutrition data is from documents published in the time window that ends at this timestamp.
Newer documents are left in the buffer.
This timestamp is inclusive.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.consumers.eld_consumer.ELDConsumer._remove_old_checkpoints">
<code class="sig-name descname">_remove_old_checkpoints</code><span class="sig-paren">(</span><em class="sig-param">timestamp</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.eld_consumer.ELDConsumer._remove_old_checkpoints" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove old checkpoints.
The checkpoints that are removed depend on:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>The number of sets that should be retained, and</p></li>
<li><p>The length of the time window of the consumer.</p></li>
</ol>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>timestamp</strong> (<em>int</em>) – The timestamp of the new checkpoint.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.consumers.eld_consumer.ELDConsumer._cluster">
<code class="sig-name descname">_cluster</code><span class="sig-paren">(</span><em class="sig-param">documents</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.eld_consumer.ELDConsumer._cluster" title="Permalink to this definition">¶</a></dt>
<dd><p>Cluster the given documents.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>documents</strong> (list of <a class="reference internal" href="nlp.html#nlp.document.Document" title="nlp.document.Document"><code class="xref py py-class docutils literal notranslate"><span class="pre">Document</span></code></a>) – The documents to cluster.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The list of clusters that are still active and that have changed.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list of <a class="reference internal" href="vsm.html#vsm.clustering.cluster.Cluster" title="vsm.clustering.cluster.Cluster"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cluster</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.consumers.eld_consumer.ELDConsumer._filter_clusters">
<code class="sig-name descname">_filter_clusters</code><span class="sig-paren">(</span><em class="sig-param">clusters</em>, <em class="sig-param">timestamp</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.eld_consumer.ELDConsumer._filter_clusters" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a list of clusters that should be checked for emerging topics.
The filtering rules are:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>A cluster must have a minimum number of tweets, indicating popularity.</p></li>
<li><p>A cluster must not have been checked very recently.                     This keeps from checking clusters for breaking topics too often.                        Instead, clusters are checked only after some time has passed to save some time.</p></li>
<li><p>A cluster’s documents must not be quasi-identical to each other.                        This might indicate a slew of retweets.                         When something happens, people do not wait until someone writes something.                      Instead, they themselves create conversation;</p></li>
<li><p>A cluster may not have been deemed to be bursty already.                        Clusters that are bursty may keep collecting tweets for the summary.                            However, they may not be added twice to the same timeline node.</p></li>
<li><p>A cluster must not have more than one URL per tweet on average.                         URLs include both links and media.                      They indicate premeditation, usually spam, when all tweets contain them.</p></li>
<li><p>No more than half of a cluster’s tweets may be replies.</p></li>
</ol>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>clusters</strong> (list of <a class="reference internal" href="vsm.html#vsm.clustering.cluster.Cluster" title="vsm.clustering.cluster.Cluster"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cluster</span></code></a>) – The active clusters, which represent candidate topics.</p></li>
<li><p><strong>timestamp</strong> (<em>int</em>) – The current timestamp, used to check how long ago the cluster was last checked.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A list of clusters that should be checked for emerging terms.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list of <a class="reference internal" href="vsm.html#vsm.clustering.cluster.Cluster" title="vsm.clustering.cluster.Cluster"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cluster</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.consumers.eld_consumer.ELDConsumer._detect_topics">
<code class="sig-name descname">_detect_topics</code><span class="sig-paren">(</span><em class="sig-param">cluster</em>, <em class="sig-param">timestamp</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.eld_consumer.ELDConsumer._detect_topics" title="Permalink to this definition">¶</a></dt>
<dd><p>Detect topics using historical data from the given nutrition store.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cluster</strong> (<a class="reference internal" href="vsm.html#vsm.clustering.cluster.Cluster" title="vsm.clustering.cluster.Cluster"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cluster</span></code></a>) – The cluster for which to identify breaking topics.</p></li>
<li><p><strong>timestamp</strong> (<em>int</em>) – The current timestamp.
Sets older than this timestamp are used to calculate the burst.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The breaking terms and their burst as a dictionary.
The keys are the terms and the values are the respective burst values.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.consumers.eld_consumer.ELDConsumer._score_documents">
<code class="sig-name descname">_score_documents</code><span class="sig-paren">(</span><em class="sig-param">documents</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.eld_consumer.ELDConsumer._score_documents" title="Permalink to this definition">¶</a></dt>
<dd><p>Score the given documents.
The score is the product of two scores:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>A brevity score, based on <cite>BLEU: a Method for Automatic Evaluation of Machine Translation by Papineni et al. (2002) &lt;https://dl.acm.org/doi/10.3115/1073083.1073135&gt;</cite>; and</p></li>
<li><p>An emotion score, which is the complement of the fraction of tokens that are capitalized.</p></li>
</ol>
</div></blockquote>
<p>Any additional arguments and keyword arguments are passed on to the functions that calculate the scores.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>documents</strong> (list of <a class="reference internal" href="nlp.html#nlp.document.Document" title="nlp.document.Document"><code class="xref py py-class docutils literal notranslate"><span class="pre">Document</span></code></a>) – The list of documents to score.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A list of documents ranked in descending order of their score.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list of <a class="reference internal" href="nlp.html#nlp.document.Document" title="nlp.document.Document"><code class="xref py py-class docutils literal notranslate"><span class="pre">Document</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.consumers.eld_consumer.ELDConsumer._brevity_score">
<code class="sig-name descname">_brevity_score</code><span class="sig-paren">(</span><em class="sig-param">text</em>, <em class="sig-param">r=10</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.eld_consumer.ELDConsumer._brevity_score" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the brevity score, bounded between 0 and 1.
This score is based on <cite>BLEU: a Method for Automatic Evaluation of Machine Translation by Papineni et al. (2002) &lt;https://dl.acm.org/doi/10.3115/1073083.1073135&gt;</cite>:</p>
<div class="math notranslate nohighlight">
\[score = max(1, e^{1 - \frac{r}{c}})\]</div>
<p>where <span class="math notranslate nohighlight">\(c\)</span> is the number of tokens in the text, and <span class="math notranslate nohighlight">\(r\)</span> is the ideal number of tokens.</p>
<p>The score is 1 even when the tweet is longer than the desired length.
In this way, the brevity score is more akin to a brevity penalty.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>text</strong> (<em>str</em>) – The text to score.
The text is tokanized by the function.</p></li>
<li><p><strong>r</strong> (<em>str</em>) – The ideal number of tokens in the text.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The brevity score, bounded between 0 and 1.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.consumers.eld_consumer.ELDConsumer._emotion_score">
<code class="sig-name descname">_emotion_score</code><span class="sig-paren">(</span><em class="sig-param">text</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.eld_consumer.ELDConsumer._emotion_score" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the emotion in the text.
This is based on the number of capitalized characters.
The higher the score, the less emotional the tweet.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is not always desirable for the score to be 1.
That would mean that there is absolutely no capitalization at all.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>text</strong> (<em>str</em>) – The text to score.
The text is tokanized by the function.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The emotion score, bounded between 0 and 1.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<span class="target" id="module-queues.consumers.fire_consumer"></span><p>Finding Important News REports (FIRE) is a periodic TDT consumer.
It takes in tweets every time window, clusters them and finds the most important terms in each cluster.
In this implementation, the tracking happens through the timeline.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Implementation based on the algorithm presented in <a class="reference external" href="https://link.springer.com/chapter/10.1007/978-3-319-74497-1_3">FIRE: Finding Important News REports by Mamo and Azzopardi (2017)</a>.</p>
</div>
<dl class="class">
<dt id="queues.consumers.fire_consumer.FIREConsumer">
<em class="property">class </em><code class="sig-name descname">FIREConsumer</code><span class="sig-paren">(</span><em class="sig-param">queue</em>, <em class="sig-param">periodicity=60</em>, <em class="sig-param">scheme=None</em>, <em class="sig-param">sets=10</em>, <em class="sig-param">threshold=0.7</em>, <em class="sig-param">freeze_period=20</em>, <em class="sig-param">min_size=4</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.fire_consumer.FIREConsumer" title="Permalink to this definition">¶</a></dt>
<dd><p>The FIRE consumer is based on the implementation of the same name.
The algorithm clusters all tweets received in the same period and uses the Cataldi et al. algorithm to identify which ones are breaking.</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>store</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">NutritionStore</span></code>) – The nutrition store used to store the volume changes of individual terms.</p></li>
<li><p><strong>scheme</strong> (<a class="reference internal" href="nlp.html#nlp.weighting.TermWeightingScheme" title="nlp.weighting.TermWeightingScheme"><code class="xref py py-class docutils literal notranslate"><span class="pre">TermWeightingScheme</span></code></a>) – The term-weighting scheme used to create documents.</p></li>
<li><p><strong>sets</strong> (<em>int</em>) – The number of time windows that are considered when computing burst.
The higher this number, the more precise the calculations.
However, because of the decay in <a class="reference internal" href="tdt.html#tdt.algorithms.cataldi.Cataldi" title="tdt.algorithms.cataldi.Cataldi"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cataldi</span></code></a>, old time windows do not affect the result by a big margin.
Therefore old data can be removed safely.</p></li>
<li><p><strong>min_size</strong> (<em>int</em>) – The minimum size for a cluster to be considered to be a candidate breaking topic.
This value is inclusive.</p></li>
<li><p><strong>tokenizer</strong> (<a class="reference internal" href="nlp.html#nlp.tokenizer.Tokenizer" title="nlp.tokenizer.Tokenizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tokenizer</span></code></a>) – The tokenizer used to create documents.</p></li>
<li><p><strong>clustering</strong> (<a class="reference internal" href="vsm.html#vsm.clustering.algorithms.temporal_no_k_means.TemporalNoKMeans" title="vsm.clustering.algorithms.temporal_no_k_means.TemporalNoKMeans"><code class="xref py py-class docutils literal notranslate"><span class="pre">TemporalNoKMeans</span></code></a>) – The clustering algorithm to use.</p></li>
<li><p><a class="reference internal" href="summarization.html#module-summarization" title="summarization"><strong>summarization</strong></a> (<a class="reference internal" href="summarization.html#summarization.algorithms.mmr.MMR" title="summarization.algorithms.mmr.MMR"><code class="xref py py-class docutils literal notranslate"><span class="pre">MMR</span></code></a>) – The summarization algorithm to use.</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="queues.consumers.fire_consumer.FIREConsumer.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">queue</em>, <em class="sig-param">periodicity=60</em>, <em class="sig-param">scheme=None</em>, <em class="sig-param">sets=10</em>, <em class="sig-param">threshold=0.7</em>, <em class="sig-param">freeze_period=20</em>, <em class="sig-param">min_size=4</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.fire_consumer.FIREConsumer.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the consumer with a queue.
Simultaneously create a nutrition store and the topic detection algorithm container.
Initially, the IDF table should be empty.
It will be populated later when the ‘reconaissance’ period is finished.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>queue</strong> (<a class="reference internal" href="#queues.queue.Queue" title="queues.queue.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a>) – The queue that is consumed.</p></li>
<li><p><strong>periodicity</strong> (<em>int</em>) – The time window in seconds of the buffered consumer, or how often it is invoked.
This defaults to 5 seconds, the same span as half the smallest time window in Zhao et al.’s algorithm.</p></li>
<li><p><strong>scheme</strong> (None or <a class="reference internal" href="nlp.html#nlp.weighting.TermWeightingScheme" title="nlp.weighting.TermWeightingScheme"><code class="xref py py-class docutils literal notranslate"><span class="pre">TermWeightingScheme</span></code></a>) – The term-weighting scheme that is used to create dimensions.
If <cite>None</cite> is given, the <a class="reference internal" href="nlp.html#nlp.weighting.tf.TF" title="nlp.weighting.tf.TF"><code class="xref py py-class docutils literal notranslate"><span class="pre">TF</span></code></a> term-weighting scheme is used.</p></li>
<li><p><strong>sets</strong> (<em>int</em>) – The number of time windows that are considered when computing burst.
The higher this number, the more precise the calculations.
However, because of the decay in <a class="reference internal" href="tdt.html#tdt.algorithms.cataldi.Cataldi" title="tdt.algorithms.cataldi.Cataldi"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cataldi</span></code></a>, old time windows do not affect the result by a big margin.
Therefore old data can be removed safely.</p></li>
<li><p><strong>threshold</strong> (<em>float</em>) – The similarity threshold to use for the <a class="reference internal" href="vsm.html#vsm.clustering.algorithms.temporal_no_k_means.TemporalNoKMeans" title="vsm.clustering.algorithms.temporal_no_k_means.TemporalNoKMeans"><code class="xref py py-class docutils literal notranslate"><span class="pre">TemporalNoKMeans</span></code></a> incremental clustering approach.
Documents are added to an existing cluster if their similarity with the centroid is greater than or equal to this threshold.</p></li>
<li><p><strong>freeze_period</strong> (<em>float</em>) – The freeze period, in seconds, of the incremental clustering approach.</p></li>
<li><p><strong>min_size</strong> (<em>int</em>) – The minimum size for a cluster to be considered to be a candidate breaking topic.
This value is inclusive.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.consumers.fire_consumer.FIREConsumer._process">
<em class="property">async </em><code class="sig-name descname">_process</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.fire_consumer.FIREConsumer._process" title="Permalink to this definition">¶</a></dt>
<dd><p>Find breaking develpoments based on how people are talking.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The constructed timeline.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="summarization.html#summarization.timeline.Timeline" title="summarization.timeline.Timeline"><code class="xref py py-class docutils literal notranslate"><span class="pre">Timeline</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.consumers.fire_consumer.FIREConsumer._filter_tweets">
<code class="sig-name descname">_filter_tweets</code><span class="sig-paren">(</span><em class="sig-param">tweets</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.fire_consumer.FIREConsumer._filter_tweets" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter the given tweets based on FIRE’s filtering rules.
The rules are:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>The tweet has to be in English,</p></li>
<li><p>The tweet must contain no more than 2 hashtags,</p></li>
<li><p>The tweet’s author must have favorited at least one tweet, and</p></li>
<li><p>The tweet’s author must have at least one follower for every thousand tweets they’ve published.</p></li>
</ol>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>tweets</strong> (<em>list of dict</em>) – A list of tweets to filter.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A list of filtered tweets.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.consumers.fire_consumer.FIREConsumer._to_documents">
<code class="sig-name descname">_to_documents</code><span class="sig-paren">(</span><em class="sig-param">tweets</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.fire_consumer.FIREConsumer._to_documents" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the given tweets into documents.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>tweets</strong> (<em>list of dict</em>) – A list of tweets.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A list of documents created from the tweets in the same order as the given tweets.
Documents are normalized and store the original tweet in the <cite>tweet</cite> attribute.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list of <a class="reference internal" href="nlp.html#nlp.document.Document" title="nlp.document.Document"><code class="xref py py-class docutils literal notranslate"><span class="pre">Document</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.consumers.fire_consumer.FIREConsumer._latest_timestamp">
<code class="sig-name descname">_latest_timestamp</code><span class="sig-paren">(</span><em class="sig-param">documents</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.fire_consumer.FIREConsumer._latest_timestamp" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the latest timestamp from the given documents.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>documents</strong> (list of <a class="reference internal" href="nlp.html#nlp.document.Document" title="nlp.document.Document"><code class="xref py py-class docutils literal notranslate"><span class="pre">Document</span></code></a>) – The list of documents from where to get the latest timestamp.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The latest timestamp in the given document set.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>int</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – When there are no documents to consider.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.consumers.fire_consumer.FIREConsumer._filter_documents">
<code class="sig-name descname">_filter_documents</code><span class="sig-paren">(</span><em class="sig-param">documents</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.fire_consumer.FIREConsumer._filter_documents" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter the given documents based on FIRE’s scoring.
The score is based on the fraction of unique tokens:</p>
<div class="math notranslate nohighlight">
\[s_d = \ln(|d|) * \frac{|d_u|}{|d|}\]</div>
<p>where <span class="math notranslate nohighlight">\(s_d\)</span> is the computed score.
<span class="math notranslate nohighlight">\(|d|\)</span> and <span class="math notranslate nohighlight">\(|d_u|\)</span> are the number of tokens, and the number of unique tokens in the document respectively.
Documents that have no tokens are immediately discarded.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>documets</strong> – A list of documents.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A list of filtered documents.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.consumers.fire_consumer.FIREConsumer._create_checkpoint">
<code class="sig-name descname">_create_checkpoint</code><span class="sig-paren">(</span><em class="sig-param">timestamp</em>, <em class="sig-param">documents</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.fire_consumer.FIREConsumer._create_checkpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>After every time window has elapsed, create a checkpoint from the documents.
These checkpoints store a snapshot of how much each different term was used at the time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>timestamp</strong> (<em>int</em>) – The timestamp of the new checkpoint.</p></li>
<li><p><strong>documents</strong> (list of <a class="reference internal" href="nlp.html#nlp.document.Document" title="nlp.document.Document"><code class="xref py py-class docutils literal notranslate"><span class="pre">Document</span></code></a>) – The list of documents that form the checkpoint.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.consumers.fire_consumer.FIREConsumer._remove_old_checkpoints">
<code class="sig-name descname">_remove_old_checkpoints</code><span class="sig-paren">(</span><em class="sig-param">timestamp</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.fire_consumer.FIREConsumer._remove_old_checkpoints" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove old checkpoints.
The checkpoints that are removed depend on the number of sets that should be retained and the periodicity of the consumer.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>timestamp</strong> (<em>int</em>) – The timestamp of the new checkpoint.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.consumers.fire_consumer.FIREConsumer._cluster">
<code class="sig-name descname">_cluster</code><span class="sig-paren">(</span><em class="sig-param">documents</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.fire_consumer.FIREConsumer._cluster" title="Permalink to this definition">¶</a></dt>
<dd><p>Cluster the given documents.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>documets</strong> – The documents to cluster.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The list of clusters that have changed.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list of <code class="xref py py-class docutils literal notranslate"><span class="pre">Cluster</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.consumers.fire_consumer.FIREConsumer._filter_clusters">
<code class="sig-name descname">_filter_clusters</code><span class="sig-paren">(</span><em class="sig-param">clusters</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.fire_consumer.FIREConsumer._filter_clusters" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter clusters that are too small.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>clusters</strong> (list of <a class="reference internal" href="vsm.html#vsm.clustering.cluster.Cluster" title="vsm.clustering.cluster.Cluster"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cluster</span></code></a>) – A list of clusters to filter.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A list of filtered clusters.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list of <a class="reference internal" href="vsm.html#vsm.clustering.cluster.Cluster" title="vsm.clustering.cluster.Cluster"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cluster</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.consumers.fire_consumer.FIREConsumer._detect_topics">
<code class="sig-name descname">_detect_topics</code><span class="sig-paren">(</span><em class="sig-param">cluster</em>, <em class="sig-param">timestamp</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.fire_consumer.FIREConsumer._detect_topics" title="Permalink to this definition">¶</a></dt>
<dd><p>Detect topics from the given cluster.
This method makes a copy of the nutrition store.
It replaces the data at the given timestamp with a pseudo-checkpoint.
This checkpoint is constructed using only data from the cluster.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cluster</strong> (<a class="reference internal" href="vsm.html#vsm.clustering.cluster.Cluster" title="vsm.clustering.cluster.Cluster"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cluster</span></code></a>) – The cluster for which to identify breaking topics.</p></li>
<li><p><strong>timestamp</strong> (<em>int</em>) – The current timestamp.
Sets older than this timestamp are used to calculate the burst.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A list of emerging terms from the cluster.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<span class="target" id="module-queues.consumers.zhao_consumer"></span><p>The Zhao et al. consumer is based on the implementation by the same authors.
The algorithm revolves around the <a class="reference internal" href="tdt.html#tdt.algorithms.zhao.Zhao" title="tdt.algorithms.zhao.Zhao"><code class="xref py py-class docutils literal notranslate"><span class="pre">Zhao</span></code></a> algorithm.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Implementation based on the algorithm presented in <a class="reference external" href="https://arxiv.org/abs/1106.4300">Human as Real-Time Sensors of Social and Physical Events: A Case Study of Twitter and Sports Games by Zhao et al. (2011)</a>.</p>
</div>
<dl class="class">
<dt id="queues.consumers.zhao_consumer.ZhaoConsumer">
<em class="property">class </em><code class="sig-name descname">ZhaoConsumer</code><span class="sig-paren">(</span><em class="sig-param">queue</em>, <em class="sig-param">periodicity=5</em>, <em class="sig-param">scheme=None</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.zhao_consumer.ZhaoConsumer" title="Permalink to this definition">¶</a></dt>
<dd><p>The Zhao et al. consumer is based on the implementation by the same authors.
The algorithm revolves around the <a class="reference internal" href="tdt.html#tdt.algorithms.zhao.Zhao" title="tdt.algorithms.zhao.Zhao"><code class="xref py py-class docutils literal notranslate"><span class="pre">Zhao</span></code></a> algorithm.
The algorithm examines changes in volume using a dynamic time window.</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>store</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">NutritionStore</span></code>) – The nutrition store used to store the volume.</p></li>
<li><p><strong>scheme</strong> (<a class="reference internal" href="nlp.html#nlp.weighting.TermWeightingScheme" title="nlp.weighting.TermWeightingScheme"><code class="xref py py-class docutils literal notranslate"><span class="pre">TermWeightingScheme</span></code></a>) – The term-weighting scheme used to create documents.</p></li>
<li><p><a class="reference internal" href="summarization.html#summarization.summary.Summary.documents" title="summarization.summary.Summary.documents"><strong>documents</strong></a> (<a class="reference internal" href="nlp.html#nlp.document.Document" title="nlp.document.Document"><code class="xref py py-class docutils literal notranslate"><span class="pre">Document</span></code></a>) – The documents that can still be used for summarization.
Older documents are automatically cleared.</p></li>
<li><p><a class="reference internal" href="tdt.html#module-tdt" title="tdt"><strong>tdt</strong></a> (<a class="reference internal" href="tdt.html#tdt.algorithms.zhao.Zhao" title="tdt.algorithms.zhao.Zhao"><code class="xref py py-class docutils literal notranslate"><span class="pre">Zhao</span></code></a>) – The TDT algorithm: Zhao et al.’s implementation.</p></li>
<li><p><a class="reference internal" href="summarization.html#module-summarization" title="summarization"><strong>summarization</strong></a> (<a class="reference internal" href="summarization.html#summarization.algorithms.mmr.MMR" title="summarization.algorithms.mmr.MMR"><code class="xref py py-class docutils literal notranslate"><span class="pre">MMR</span></code></a>) – The summarization algorithm to use.</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="queues.consumers.zhao_consumer.ZhaoConsumer.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">queue</em>, <em class="sig-param">periodicity=5</em>, <em class="sig-param">scheme=None</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.zhao_consumer.ZhaoConsumer.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the consumer with a queue.
Simultaneously create a nutrition store and the topic detection algorithm container.
Initially, the IDF table should be empty.
It will be populated later when the ‘reconaissance’ period is finished.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>queue</strong> (<a class="reference internal" href="#queues.queue.Queue" title="queues.queue.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a>) – The queue that is consumed.</p></li>
<li><p><strong>periodicity</strong> (<em>int</em>) – The time window in seconds of the buffered consumer, or how often it is invoked.
This defaults to 5 seconds, the same span as half the smallest time window in Zhao et al.’s algorithm.</p></li>
<li><p><strong>scheme</strong> (None or <a class="reference internal" href="nlp.html#nlp.weighting.TermWeightingScheme" title="nlp.weighting.TermWeightingScheme"><code class="xref py py-class docutils literal notranslate"><span class="pre">TermWeightingScheme</span></code></a>) – The term-weighting scheme that is used to create dimensions.
If <cite>None</cite> is given, the <a class="reference internal" href="nlp.html#nlp.weighting.tf.TF" title="nlp.weighting.tf.TF"><code class="xref py py-class docutils literal notranslate"><span class="pre">TF</span></code></a> term-weighting scheme is used.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.consumers.zhao_consumer.ZhaoConsumer._process">
<em class="property">async </em><code class="sig-name descname">_process</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.zhao_consumer.ZhaoConsumer._process" title="Permalink to this definition">¶</a></dt>
<dd><p>Find breaking develpoments based on changes in volume.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The constructed timeline.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="summarization.html#summarization.timeline.Timeline" title="summarization.timeline.Timeline"><code class="xref py py-class docutils literal notranslate"><span class="pre">Timeline</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.consumers.zhao_consumer.ZhaoConsumer._to_documents">
<code class="sig-name descname">_to_documents</code><span class="sig-paren">(</span><em class="sig-param">tweets</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.zhao_consumer.ZhaoConsumer._to_documents" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the given tweets into documents.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>tweets</strong> (<em>list of dict</em>) – A list of tweets.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A list of documents created from the tweets in the same order as the given tweets.
Documents are normalized and store the original tweet in the <cite>tweet</cite> attribute.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list of <a class="reference internal" href="nlp.html#nlp.document.Document" title="nlp.document.Document"><code class="xref py py-class docutils literal notranslate"><span class="pre">Document</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.consumers.zhao_consumer.ZhaoConsumer._latest_timestamp">
<code class="sig-name descname">_latest_timestamp</code><span class="sig-paren">(</span><em class="sig-param">documents</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.zhao_consumer.ZhaoConsumer._latest_timestamp" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the latest timestamp from the given documents.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>documents</strong> (list of <a class="reference internal" href="nlp.html#nlp.document.Document" title="nlp.document.Document"><code class="xref py py-class docutils literal notranslate"><span class="pre">Document</span></code></a>) – The list of documents from where to get the latest timestamp.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The latest timestamp in the given document set.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>int</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – When there are no documents to consider.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.consumers.zhao_consumer.ZhaoConsumer._add_documents">
<code class="sig-name descname">_add_documents</code><span class="sig-paren">(</span><em class="sig-param">documents</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.zhao_consumer.ZhaoConsumer._add_documents" title="Permalink to this definition">¶</a></dt>
<dd><p>Add the given documents to the list of stored documents.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>documents</strong> (list of <a class="reference internal" href="nlp.html#nlp.document.Document" title="nlp.document.Document"><code class="xref py py-class docutils literal notranslate"><span class="pre">Document</span></code></a>) – The list of documents to store in this consumer.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.consumers.zhao_consumer.ZhaoConsumer._documents_since">
<code class="sig-name descname">_documents_since</code><span class="sig-paren">(</span><em class="sig-param">since</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.zhao_consumer.ZhaoConsumer._documents_since" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all the documents since the given timestamp.
The documents are ordered chronologically.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>since</strong> (<em>float</em>) – The timestamp since when all documents should be returned.
This value is inclusive.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The list of documents added since the given timestamp.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list of <a class="reference internal" href="nlp.html#nlp.document.Document" title="nlp.document.Document"><code class="xref py py-class docutils literal notranslate"><span class="pre">Document</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.consumers.zhao_consumer.ZhaoConsumer._remove_documents_before">
<code class="sig-name descname">_remove_documents_before</code><span class="sig-paren">(</span><em class="sig-param">until</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.zhao_consumer.ZhaoConsumer._remove_documents_before" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all the documents published before the given timestamp.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>until</strong> (<em>float</em>) – The timestamp until when all documents should be removed.
This value is exclusive.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.consumers.zhao_consumer.ZhaoConsumer._create_checkpoint">
<code class="sig-name descname">_create_checkpoint</code><span class="sig-paren">(</span><em class="sig-param">documents</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.zhao_consumer.ZhaoConsumer._create_checkpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Create checkpoints from the documents in the
After every time window has elapsed, create a checkpoint from the documents.
These documents are used to create a nutrition set for the nutrition store.
This nutrition set represents a snapshot of the time window.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>documents</strong> (list of <a class="reference internal" href="nlp.html#nlp.document.Document" title="nlp.document.Document"><code class="xref py py-class docutils literal notranslate"><span class="pre">Document</span></code></a>) – The list of documents that form the checkpoint.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="queues.consumers.zhao_consumer.ZhaoConsumer._detect_topics">
<code class="sig-name descname">_detect_topics</code><span class="sig-paren">(</span><em class="sig-param">timestamp</em><span class="sig-paren">)</span><a class="headerlink" href="#queues.consumers.zhao_consumer.ZhaoConsumer._detect_topics" title="Permalink to this definition">¶</a></dt>
<dd><p>Detect breaking topics using the Zhao et al. algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>timestamp</strong> (<em>float</em>) – The timestamp at which point topics are detected.
This value is exclusive.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tuple with the start and end timestamp of the time window when there was a burst.
Note that this is a half-window, not the entire window.
If there was an increase in the second half of the last 60 seconds, the last 30 seconds are returned.
If there was no burst, <cite>False</cite> is returned.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple or bool</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="ml.html" class="btn btn-neutral float-right" title="10. Machine Learning" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="twitter.html" class="btn btn-neutral float-left" title="8. Twitter" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Nicholas Mamo

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>