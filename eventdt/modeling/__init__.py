"""
The event modeling package contains classes and functions that make it easier to formally represent events.
"""

import copy
from datetime import datetime
import os
import sys

path = os.path.join(os.path.dirname(__file__), '..')
if path not in sys.path:
    sys.path.append(path)

from objects import Attributable, Exportable

class EventModel(Attributable, Exportable):
    """
    The :class:`~modeling.EventModel` represents events using the `five Ws and one H` as attributes.
    The class always initializes the six attributes and does not impose any restrictions on the class.
    Nevertheless, event modelers might impose their own restrictions, such as using :class:`datetime.datetime` instances for the When.
    """

    def __init__(self, who=None, what=None, where=None, when=None, why=None, how=None, *args, **kwargs):
        """
        Create the event model from the `five Ws and one H`.
        The constructor stores the six aspects as attributes.

        :param who: The person or persons involved in the event.
        :type who: Any
        :param what: The subject, action or changes of an event.
        :type what: Any
        :param where: The location where the event is taking place.
        :type where: Any
        :param when: The time or time periods when the event takes place.
        :type when: Any
        :param why: The reasons why an event occurred, which could be another :class:`~modeling.EventModel`.
        :type why: Any
        :param how: The reasons how an event occurred, which could be another :class:`~modeling.EventModel`.
        :type how: Any
        """

        super(EventModel, self).__init__(*args, **kwargs)
        self.attributes.update({ 'who': who, 'what': what, 'where': where,
                                 'when': when, 'why': why, 'how': how })

    def to_array(self):
        """
        Export the :class:`~modeling.EventModel` as ``dict``.
        This ``dict`` has two keys:

            1. The class name, used when re-creating the :class:`~modeling.EventModel`; and
            2. The :class:`~modeling.EventModel`'s attributes as a ``dict``

        :return: The :class:`~modeling.EventModel` as ``dict``.
        :rtype: dict
        """

        return {
            'class': str(EventModel),
            'attributes': copy.deepcopy(self.attributes)
        }

    @staticmethod
    def from_array(array):
        """
        Create an instance of the :class:`~modeling.EventModel` from the given ``dict``.
        This function expects the array to have been generated by the :func:`~Vector.to_array`, and must have two keys:

            1. The class name; and
            2. The :class:`~modeling.EventModel`'s attributes as a ``dict``.

        :param array: The ``dict`` with the attributes to create the :class:`~modeling.EventModel`.
        :type array: dict

        :return: A new instance of the :class:`~modeling.EventModel` with the same attributes stored in the object.
        :rtype: :class:`~modeling.EventModel`
        """

        attributes = array.get('attributes')
        return EventModel(who=attributes.get('who'), what=attributes.get('what'), where=attributes.get('where'),
                          when=attributes.get('when'), why=attributes.get('why'), how=attributes.get('how'),
                          attributes=copy.deepcopy(attributes))

    def __str__(self):
        """
        Get the string representation of the model.
        This function returns the set attributes of the `five Ws and one H`.

        :return: The string representation of the summary.
        :rtype: str
        """

        _str = ''

        _str += f"Who: { self.who }\n" if self.who else ''
        _str += f"What: { self.what }\n" if self.what else ''
        _str += f"Where: { self.where }\n" if self.where else ''

        if type(self.when) is list:
            _str += f"When: { [ datetime.fromtimestamp(when) for when in self.when ] }\n" if self.when else ''
        else:
            _str += f"When: { datetime.fromtimestamp(self.when) }\n" if self.when else ''

        _str += f"Why: { self.why }\n" if self.why else ''
        _str += f"How: { self.how }\n" if self.how else ''

        return _str
